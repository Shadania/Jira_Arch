ID,Quotation Name,Document,Quotation Content,Comment,Codes,Reference,Density,Modified by
1:1,It is difcult to modify the set of ColumnFamliies in an existing clust…,CASSANDRA-44,It is difcult to modify the set of ColumnFamliies in an existing cluster,,User requirement,3:50 - 3:121,1,arjan
1:2,ColumnFamilies may be added when cassandr is not running by editing th…,CASSANDRA-44,"ColumnFamilies may be added when cassandr is not running by editing the confguration fle.
If you need to delete or re-order CFs, you must  1) kill cassandra  2) start it again and wait for log replay to fnish  3) kill cassandra AGAIN  Alternatively on Cassandra 0.4.2 or later:  1) run nodeprobe fush and wait for it to fnish  2) kill cassandra  Then:  4) make your edits (now there is no data in the commitlog)  5) manually remove the sstable fles (-Data.db, -Index.db, and -Filter.db) for the CFs you removed,  and rename fles for CFs you renamed  6) start cassandra and your edits should take efect",,Run-time quality issues,3:141 - 3:742,1,arjan
1:81,jbellis,CASSANDRA-44,jbellis,,Comment,3:828 - 3:834,1,arjan
1:3,Maintaining CF defnitions looks like a good use case for Zookeeper to…,CASSANDRA-44,Maintaining CF defnitions looks like a good use case for Zookeeper to me.,,"Architectural solution benefits and drawbacks
Other system architectural solutions",3:837 - 3:909,2,arjan
1:4,"We  could do it like this:  2- on startup, a cassandra node must conta…",CASSANDRA-44,"We  could do it like this:  2
- on startup, a cassandra node must contact zookeeper and read the column family data.
this is the only time it will abort if ZK is not available.
- when an operation is requested for a columnfamily that does not exist, the node checks  zookeeper to see if that column has been added  - additionally, we can check every hour or so for new columns and removed columns. so  removed CFs could accept ops for a while after ofcially being ""removed."" - adding and re-  moving CFs would be done with a web interface. (I’m strongly in favor of moving the web  UI to Jython; it’s much better suited for this than raw Java.)  At the znode level, we would have /columfamilies/[tablename]/[columnfamily1|columnfamily2|...]  where the columnfamily znodes contain the sort information and any other attributes that  was previously being stored in TableMetadata.
Notes to keep adminning a ZK ensemble relatively painless:  - use the Cassandra seed nodes as the ZK ensemble members. (Both seed nodes and ZK  require a relatively small number of machines in the cluster to participate.) We can ship a  confg fle so that cassandra will continue to Just Work on localhost.
",,Architectural design configuration,3:911 - 4:1158,1,arjan
1:82,jbellis,CASSANDRA-44,jbellis,,Comment,4:1173 - 4:1179,1,arjan
1:5,Brett pointed out on IRC that we’d want to start the namespace with /c…,CASSANDRA-44,Brett pointed out on IRC that we’d want to start the namespace with /cassan-  dra/[clustername],,Architectural component behavior and structure,4:1182 - 4:1276,1,arjan
1:6,to avoid collisions with other ZK users and cassandra clusters.,CASSANDRA-44," to avoid collisions with other ZK users and cassandra clusters.
",,Architectural solution benefits and drawbacks,4:1277 - 4:1342,1,arjan
1:83,junrao,CASSANDRA-44,junrao,,Comment,4:1424 - 4:1429,1,arjan
1:8,"Changing CFs has implications on the logs. Today, the log header has a…",CASSANDRA-44,"Changing CFs has implications on the logs. Today, the log header has an entry for  each CF. Those entries are preallocated at startup and may not be easy to adjust.
",,Technical debt,4:1432 - 4:1596,1,arjan
1:12,Can you point out the relevant code?,CASSANDRA-44,"Can you point out the relevant code?
",,,4:1610 - 4:1646,1,arjan
1:13,You can trace from db.CommitLogHeader.turnon/turnof.,CASSANDRA-44,"You can trace from db.CommitLogHeader.turnon/turnof.
",,,4:1659 - 4:1712,1,arjan
1:84,jbellis,CASSANDRA-44,jbellis,,Comment,4:1716 - 4:1722,1,arjan
1:14,I think that if you were to wipe the system/ and commitlog/ directorie…,CASSANDRA-44,"I think that if you were to wipe the system/ and commitlog/ directories (after  shutdown, restart, shutdown to make sure everything from the commitlog gets replayed into  sstables) then restart w/ a new confg, it would work fne.
Do test this before trying it on important data though! :)  7. jbellis: and by shutdown of course I mean ""kill."" :)",,"Assumptions
User requirement",4:1725 - 4:2069,2,arjan
1:85,jbellis,CASSANDRA-44,jbellis,,Comment,4:2075 - 4:2081,1,arjan
1:15,Note that per CASSANDRA-211 we shouldn’t jam this into the existing pe…,CASSANDRA-44,Note that per CASSANDRA-211 we shouldn’t jam this into the existing per-node  web ui.,,Contextual constraints,4:2085 - 4:2169,1,arjan
1:86,jbellis,CASSANDRA-44,jbellis,,Comment,4:2176 - 4:2182,1,arjan
1:16,"So what we’ll want to do is add a preamble to the commitlog stating ""t…",CASSANDRA-44,"So what we’ll want to do is add a preamble to the commitlog stating ""these are the  columnfamilies and the indexes i am mapping them to in this commitlog.""",,Architectural design configuration,4:2185 - 4:2339,1,arjan
1:17,so if we add or  delete CFs we won’t screw up that ordering.,CASSANDRA-44,"so if we add or  delete CFs we won’t screw up that ordering.
",,Architectural solution benefits and drawbacks,4:2341 - 4:2402,1,arjan
1:87,jbellis,CASSANDRA-44,jbellis,,Comment,4:2407 - 4:2413,1,arjan
1:18,Or if we are using ZK (for instance) to hold CF defnitions,CASSANDRA-44, Or if we are using ZK (for instance) to hold CF defnitions,,Architectural design configuration,4:2415 - 4:2473,1,arjan
1:19,such that we can keep  the index/CF map there and not re-use indexes f…,CASSANDRA-44," such that we can keep  the index/CF map there and not re-use indexes for deleted CFs then we can rely on the  commitlog ordering always being valid (and just check to make sure we don’t replay into a  decomissioned CF).
",,Architectural solution benefits and drawbacks,4:2474 - 4:2695,1,arjan
1:88,eweaver,CASSANDRA-44,eweaver,,Comment,4:2700 - 4:2706,1,arjan
1:20,Can Zookeeper be bundled in Cassandra itself? Would prefer not to have…,CASSANDRA-44,"Can Zookeeper be bundled in Cassandra itself? Would prefer not to have to  manage a separate component.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",4:2709 - 4:2813,2,arjan
1:89,jbellis,CASSANDRA-44,jbellis,,Comment,5:5 - 5:11,1,arjan
1:21,after CASSANDRA-79 the confg fle is the only source of truth for CF de…,CASSANDRA-44,"after CASSANDRA-79 the confg fle is the only source of truth for CF defnitions  which makes editing them easier. Updated the issue description to refect this.
",,Architectural design configuration,5:14 - 5:173,1,arjan
1:22,which makes editing them easier.,CASSANDRA-44,which makes editing them easier.,,Architectural solution benefits and drawbacks,5:94 - 5:125,1,arjan
1:23,Obviously we want to make this less crappy but maybe it’s not worth ma…,CASSANDRA-44,"Obviously we want to make this less crappy but maybe it’s not worth making ZK a de-  pendency anymore.
",,"Assumptions
Trade-offs",5:174 - 5:277,2,arjan
1:90,jbellis,CASSANDRA-44,jbellis,,Comment,5:282 - 5:288,1,arjan
1:24,I no longer thing we need to involve ZK for this.,CASSANDRA-44, I no longer thing we need to involve ZK for this.,,"Assumptions
Other system architectural solutions",5:290 - 5:339,2,arjan
1:25,Let’s keep it simple.,CASSANDRA-44,Let’s keep it simple.,,Architectural solution benefits and drawbacks,5:341 - 5:361,1,arjan
1:26,Jonathan could you explain in the ticket your thoughts on this (no nee…,CASSANDRA-44,"Jonathan could you explain in the ticket your thoughts on this (no need for  Zookeeper)? You told me in IRC, but I forgot and having it on record is best.
",,,5:376 - 5:531,1,arjan
1:91,jbellis,CASSANDRA-44,jbellis,,Comment,5:536 - 5:542,1,arjan
1:27,split out the CF defnitions into a separate confg fle. poll that fle f…,CASSANDRA-44,"split out the CF defnitions into a separate confg fle. poll that fle for changes  periodically and reload.
",,User requirement,5:545 - 5:652,1,arjan
1:28,this does push the problem of keeping the confg fles in sync across no…,CASSANDRA-44,"this does push the problem of keeping the confg fles in sync across nodes onto ops, but  ops would probably prefer that to requiring a completely new service piece. :)",,Trade-offs,5:653 - 5:819,1,arjan
1:29,Note that either way the we need to automate the transition from an ol…,CASSANDRA-44,"Note that either way the we need to automate the transition from an old set of defnitions  to the new, at the commitlog level. ZK doesn’t make that go away.
",,Architectural solution benefits and drawbacks,5:822 - 5:979,1,arjan
1:92,euphoria,CASSANDRA-44,euphoria,,Comment,5:984 - 5:991,1,arjan
1:30,I don’t get how one would do renames in this seperate-confg-fle soluti…,CASSANDRA-44," I don’t get how one would do renames in this seperate-confg-fle solution without  either specify something like a migration in the fle, or having seperate unique id’s in addition  to names that are shared on the cluster.
",,Architectural solution benefits and drawbacks,5:993 - 5:1215,1,arjan
1:93,urandom,CASSANDRA-44,urandom,,Comment,5:1220 - 5:1226,1,arjan
1:31,"That problem already exists. If you are making additions, removals, or…",CASSANDRA-44,"That problem already exists. If you are making additions, removals, or renames, then you  are going to have to sync those changes with the entire cluster. Whether it’s a single fle or  many doesn’t make much of a diference IMO.
",,Architectural solution benefits and drawbacks,5:1403 - 5:1631,1,arjan
1:32,"Also, if this is implemented with an additional confg, then we should…",CASSANDRA-44,"Also, if this is implemented with an additional confg, then we should probably expose  it through get_string_property() in the same way we do the current confguration (which  incidentally could be useful to ops in syncing up the cluster).
",,Architectural design configuration,5:1632 - 5:1871,1,arjan
1:94,jbellis,CASSANDRA-44,jbellis,,Comment,5:1876 - 5:1882,1,arjan
1:33,"Yes, describing renames is a minor problem (with ZK too).",CASSANDRA-44,"Yes, describing renames is a minor problem (with ZK too).
",,Architectural solution benefits and drawbacks,5:1885 - 5:1943,1,arjan
1:34,We could add JMX commands for managing CFs but then you get back to th…,CASSANDRA-44,"We could add JMX commands for managing CFs but then you get back to the Bad Old  Days of having this xml around that is overridden by ""invisible"" information in the system  table.
",,Trade-offs,5:1944 - 5:2124,1,arjan
1:35,I would just add an attribute e.g. MigrateFrom to the CF defnition tha…,CASSANDRA-44,"I would just add an attribute e.g. MigrateFrom to the CF defnition that says ""here’s  what the old name was, rename the data fles when you move to the new defnition.""  <ColumnFamily name=""Standard82"" migratefrom=""Standard1"" ...>  (Note that I only suggest splitting this into a separate fle for clarity, not because it’s some-  how inherent to manage-by-re-parse.)",,Architectural component behavior and structure,5:2125 - 5:2488,1,arjan
1:95,jmischo,CASSANDRA-44,jmischo,,Comment,5:2495 - 5:2501,1,arjan
1:36,"Adding JMX commands to manage CFs doesn’t have to be evil, provided we…",CASSANDRA-44,"Adding JMX commands to manage CFs doesn’t have to be evil, provided we  distribute the information to all nodes and they serialize a new confg out to disk. If the  confg change has a serial and a checksum that is sent to every node, the xml confg can be  stamped with them, and any node with an old or corrupt confg could pull the latest confg  during bootstrapping on restart or after failed validation against checksum.",,Architectural design configuration,5:2504 - 5:2924,1,arjan
1:37,"doesn’t have to be evil,",CASSANDRA-44,"doesn’t have to be evil,",,Architectural solution benefits and drawbacks,5:2538 - 5:2561,1,arjan
1:38,"Just an idea, but it’s one that solves for the ""invisible"" confguratio…",CASSANDRA-44,"Just an idea, but it’s one that solves for the ""invisible"" confguration issue and adds manage-  ability without sacrifcing uptime. Since adding and removing CFs should be a rare event, I  don’t think we need to designate a single point of failure to be the ""authoritative"" node for  the confg, though the frst node to get the confg change could be the one responsible for  gaining consensus on the ""current"" confguration and then also be responsible for generating  the new serial and checksum.
",,"Architectural solution benefits and drawbacks
Architectural tactics
Assumptions",6:1 - 6:496,3,arjan
1:39,The real question in my mind is whether this is something that we requ…,CASSANDRA-44,"The real question in my mind is whether this is something that we require a management  tool to contact every node via JMX for,",,Architectural design configuration,6:497 - 6:623,1,arjan
1:40,or whether a success message from a single node  means it’s already su…,CASSANDRA-44," or whether a success message from a single node  means it’s already successfully distributed the confguration change to N nodes/quorum/all  nodes.
",,Architectural design configuration,6:624 - 6:772,1,arjan
1:96,jbellis,CASSANDRA-44,jbellis,,Comment,6:777 - 6:783,1,arjan
1:41,"If the goal is ""write out a new confg fle"" then contacting each machin…",CASSANDRA-44," If the goal is ""write out a new confg fle"" then contacting each machine via JMX  and programatically re-writing the confg fle",,Architectural design configuration,6:785 - 6:910,1,arjan
1:42,is a lot more complicated than,CASSANDRA-44, is a lot more complicated than,,Architectural solution benefits and drawbacks,6:911 - 6:941,1,arjan
1:43,just pushing  out a new fle via an existing puppet / dsh / etc infrast…,CASSANDRA-44,"just pushing  out a new fle via an existing puppet / dsh / etc infrastructure.
",,Architectural design configuration,6:943 - 6:1022,1,arjan
1:97,ryandaum,CASSANDRA-44,ryandaum,,Comment,6:1027 - 6:1034,1,arjan
1:44,What about using a special default ’meta’ Cassandra keyspace for the d…,CASSANDRA-44,"What about using a special default ’meta’ Cassandra keyspace for the descrip-  tion of the keyspaces/column families?
",,Architectural component behavior and structure,6:1037 - 6:1155,1,arjan
1:45,This would handle the issue of propagation and availability.,CASSANDRA-44,"This would handle the issue of propagation and availability.
",,Architectural solution benefits and drawbacks,6:1156 - 6:1217,1,arjan
1:98,jbellis,CASSANDRA-44,jbellis,,Comment,6:1222 - 6:1228,1,arjan
1:46,"Other things being equal, I would prefer to provide a thrift interface…",CASSANDRA-44,"Other things being equal, I would prefer to provide a thrift interface to add/rename/re-  move keyspace and CFs through a single coordinator node (vs having to update each node  via JMX, or push out a new confg fle). ",,"Architectural design configuration
Architectural solution benefits and drawbacks",6:1249 - 6:1465,2,arjan
1:47,Keeping things confg-fle based has two drawbacks:  - it requires flesy…,CASSANDRA-44,"Keeping things confg-fle based has two drawbacks:  - it requires flesystem access for whoever is doing the update, which is problematic in some  environments  - it makes life difcult for systems building on top of cassandra that want to automate this  (easy for a human to dsh scp from somewhere; possible, but painful, to integrate this into  an automated system that is more than a one-of)  - it requires either all nodes being up for the upgrade, which is simple but unrealistic, or ops  manually re-pushing the update to nodes that are down, which is a pita",,Architectural solution benefits and drawbacks,6:1466 - 6:2026,1,arjan
1:48,So if we can instead move to a system where KS/CF defnitions are store…,CASSANDRA-44,"So if we can instead move to a system where KS/CF defnitions are stored in a system  CF and updated programatically,",,Architectural design configuration,6:2029 - 6:2144,1,arjan
1:49,I think that would be best.,CASSANDRA-44,"I think that would be best.
",,"Architectural solution benefits and drawbacks
Assumptions",6:2146 - 6:2174,2,arjan
1:50,Possible evolution of the code might look like  (1) move KS/CF defniti…,CASSANDRA-44,"Possible evolution of the code might look like  (1) move KS/CF defnitions into the system table  (2) add schema change methods internally and tests (possibly expose via JMX for manual  testing, but not nodeprobe)  (3) add thrift interface to send schema changes out to other nodes  (4) add gossip of MetadataVersion (a user provided? automatically generated? identifer  string): gossip automatically handles updating nodes that were down on what happened  while they were out. Full schema will not ft in gossip but a version id will. A node whose  internal MV is lower than one it sees in gossip, should ask the node w/ the higher version  to send it the new version. (Remember we cannot rely on HH for this since the FD may not  have recognized that the node was down when the update was happening).
",,Architectural design configuration,6:2175 - 6:2976,1,arjan
1:51,We punt completely on two clients requesting conficting changes from d…,CASSANDRA-44,"We punt completely on two clients requesting conficting changes from diferent coordinator  nodes. ""Don’t do that."" (Just as copying out two conficting confg fles is Bad.)",,Run-time quality issues,6:2977 - 6:3146,1,arjan
1:52,One possible layout for the metadata CFs:  migrations: hardcoded key o…,CASSANDRA-44,"One possible layout for the metadata CFs:  migrations: hardcoded key of ""migrations"": each column w/ name of MetadataVersion con-  5
tains the op performed  schema: key of MV, supercolumns of KS, columns of serialized CF defnitions  so on startup, we read latest MV from migrations row, then the associated schema.
(Looked at this way it seems like we should just have MV be a TimeUUID and not make  client deal w/ that.)",,Architectural design configuration,6:3149 - 7:289,1,arjan
1:99,jbellis,CASSANDRA-44,jbellis,,Comment,7:296 - 7:302,1,arjan
1:53,Instead of manually propagating & reconciling schema changes in (3) an…,CASSANDRA-44,"Instead of manually propagating & reconciling schema changes in (3) and (4), we  could add per-keyspace replication factor as suggested in CASSANDRA-620.",,Architectural design configuration,7:305 - 7:457,1,arjan
1:54,We’d still need  to gossip version id so schema changes don’t rely on…,CASSANDRA-44,"We’d still need  to gossip version id so schema changes don’t rely on a weekly (for instance) repair operation  to be consistent, but we could still use the repair code that is already done rather than  rolling it manually.",,Trade-offs,7:459 - 7:681,1,arjan
1:100,gdusbabek,CASSANDRA-44,gdusbabek,,Comment,7:688 - 7:696,1,arjan
1:55,I like the idea of 1) making this automatic 2) not exposing via thrift…,CASSANDRA-44,I like the idea of 1) making this automatic 2) not exposing via thrift.,,Architectural solution benefits and drawbacks,7:699 - 7:769,1,arjan
1:101,jbellis,CASSANDRA-44,jbellis,,Comment,7:834 - 7:840,1,arjan
1:56,We do want to have a thrift interface to the functionality so that ord…,CASSANDRA-44,"We do want to have a thrift interface to the functionality so that ordinary clients  can create new columnfamilies, though",,User requirement,7:843 - 7:964,1,arjan
1:57,But having a special-purpose backend to handle  that is what 620 might…,CASSANDRA-44,"But having a special-purpose backend to handle  that is what 620 might let us avoid.
",,Architectural solution benefits and drawbacks,7:967 - 7:1052,1,arjan
1:102,gdusbabek,CASSANDRA-44,gdusbabek,,Comment,7:1057 - 7:1065,1,arjan
1:58,"Having this with 620 would be a lot cleaner, but implementing 620 woul…",CASSANDRA-44,"Having this with 620 would be a lot cleaner, but implementing 620 would be  a lot more work than just creating a system to propagate system changes. Is putting the  work in for 620 worth it or not?
",,Trade-offs,7:1068 - 7:1266,1,arjan
1:103,jbellis,CASSANDRA-44,jbellis,,Comment,7:1271 - 7:1277,1,arjan
1:59,"People (including Rackspace) want 620 independently, so if it’s feasib…",CASSANDRA-44," People (including Rackspace) want 620 independently, so if it’s feasible then yes.
(I’m 60% sure it’s feasible. :)",,User requirement,7:1279 - 7:1394,1,arjan
1:104,gdusbabek,CASSANDRA-44,gdusbabek,,Comment,7:1401 - 7:1409,1,arjan
1:60,Having CASSANDRA-620 will make this easier.,CASSANDRA-44,"Having CASSANDRA-620 will make this easier.
",,Architectural solution benefits and drawbacks,7:1412 - 7:1456,1,arjan
1:105,jbellis,CASSANDRA-44,jbellis,,Comment,7:1461 - 7:1467,1,arjan
1:61,"How do we deal with the rename partition problem? that is, say we rena…",CASSANDRA-44,"How do we deal with the rename partition problem?
that is, say we rename a CF A -> B, then create a new A (A’). Some node N is down  for the rename.
Now N comes back up while clients are inserting into A’. N will happily insert them to  A, then rename A -> B when it gets news of the update.
AFAICS this is an issue under either push or pull schema propagation.
",,Motivation of design issue,7:1549 - 7:1914,1,arjan
1:62,1. only allow schema changes when 100% of nodes are up.,CASSANDRA-44,1. only allow schema changes when 100% of nodes are up.,,Architectural design configuration,7:1940 - 7:1994,1,arjan
1:63,This is both limiting (when  you get to 100s of nodes it could be pret…,CASSANDRA-44,"This is both limiting (when  you get to 100s of nodes it could be pretty inconvenient) and buggy (a node could be up  when you start the update, but go down before it’s complete; FD is not instant).
",,Architectural solution benefits and drawbacks,7:1996 - 7:2195,1,arjan
1:64,"disallow renames, only allow add and drop",CASSANDRA-44,"disallow renames, only allow add and drop",,Architectural design configuration,7:2199 - 7:2239,1,arjan
1:65,"allow renames, but only allow reusing an old CF name once the entire c…",CASSANDRA-44,"allow renames, but only allow reusing an old CF name once the entire cluster has com-  pleted the frst rename (so kind of 1., but only apply the 100% rule in this one corner case)",,Architectural design configuration,7:2245 - 7:2423,1,arjan
1:66,I’m trying to think of a way that having a ZK ensemble would give  us…,CASSANDRA-44," I’m trying to think of a way that having a ZK ensemble would give  us a magic wand here, as originally envisioned, but I don’t see one (short of having nodes  ask ZK for schema defnitions on every op",,Architectural design configuration,7:2450 - 7:2649,1,arjan
1:67,which is unacceptable for performance),CASSANDRA-44,which is unacceptable for performance),,Architectural solution benefits and drawbacks,7:2652 - 7:2689,1,arjan
1:68,So I  6think my inclination would be to start w/ (2) and then add (3).,CASSANDRA-44,"So I  6
think my inclination would be to start w/ (2) and then add (3).
",,Architectural solution benefits and drawbacks,7:2692 - 8:65,1,arjan
1:106,gdusbabek,CASSANDRA-44,gdusbabek,,Comment,8:70 - 8:78,1,arjan
1:70,It won’t be hard to handle as long as the downed node doesn’t particip…,CASSANDRA-44,It won’t be hard to handle as long as the downed node doesn’t participate  in writes until it’s schema is stable.,,Architectural solution benefits and drawbacks,8:81 - 8:193,1,arjan
1:69,"rename(A,B) is migration0, add(A) is migration1. migration1 won’t be a…",CASSANDRA-44,"rename(A,B) is migration0, add(A) is migration1.
migration1 won’t be applied to N because it realizes it isn’t migrating from migration0  (migration1 specifes that it is a migration from migration0). N quickly realizes it is using  an older version of the schema, it requests all the versions it is missing and then applies  them in order (migration0, migration1).
",,Architectural design configuration,8:195 - 8:561,1,arjan
1:107,gdusbabek,CASSANDRA-44,gdusbabek,,Comment,8:566 - 8:574,1,arjan
1:71,Nevermind. I see the problem with that approach. I’ll have to think on…,CASSANDRA-44,"Nevermind. I see the problem with that approach. I’ll have to think on this.
",,Architectural solution benefits and drawbacks,8:577 - 8:654,1,arjan
1:108,gdusbabek,CASSANDRA-44,gdusbabek,,Comment,8:659 - 8:667,1,arjan
1:72,CF ids do not change during a rename. So if we encode the cfd in the r…,CASSANDRA-44,"CF ids do not change during a rename. So if we encode the cfd in the row  mutation it can be used to make sure the changes are applied properly. (At this point keeping  the cfname as part of the rowmuation would just become baggage, so if it make sense and  can be done, we should take it out.)",,Architectural design configuration,8:670 - 8:963,1,arjan
1:73,At this point keeping  the cfname as part of the rowmuation would just…,CASSANDRA-44,"At this point keeping  the cfname as part of the rowmuation would just become baggage, so if it make sense and  can be done, we should take it out",,Architectural solution benefits and drawbacks,8:816 - 8:961,1,arjan
1:109,jbellis,CASSANDRA-44,jbellis,,Comment,8:970 - 8:976,1,arjan
1:75,"That would work, as long as IDs are global. It should actually make th…",CASSANDRA-44,"That would work, as long as IDs are global. It should actually make things faster,  too.
",,Architectural tactics,8:979 - 8:1068,1,arjan
1:110,gdusbabek,CASSANDRA-44,gdusbabek,,Comment,8:1073 - 8:1081,1,arjan
1:76,w00t!,CASSANDRA-44,"w00t!
",,Architectural solution benefits and drawbacks,8:1084 - 8:1090,1,arjan
1:111,kingryan,CASSANDRA-44,kingryan,,Comment,8:1095 - 8:1102,1,arjan
1:77,Gary - This is seriously awesome. I owe you a beer when we see each ot…,CASSANDRA-44,"Gary - This is seriously awesome. I owe you a beer when we see each other.
",,Architectural solution benefits and drawbacks,8:1105 - 8:1180,1,arjan
1:112,pablocubico,CASSANDRA-44,pablocubico,,Comment,8:1185 - 8:1195,1,arjan
1:78,Great news!!! Congratz.,CASSANDRA-44,"Great news!!! Congratz.
",,Architectural solution benefits and drawbacks,8:1198 - 8:1222,1,arjan
1:79,Can you please update the Thrift VERSION (minor rev I suppose)?,CASSANDRA-44,"Can you please update the Thrift VERSION (minor rev I suppose)?
",,,8:1232 - 8:1296,1,arjan
1:80,Major version is getting bumped to 4 in 0.7 anyway as a result of swit…,CASSANDRA-44,Major version is getting bumped to 4 in 0.7 anyway as a result of switching  to byte[] keys.,,,8:1312 - 8:1403,1,arjan
2:1,"Currently cassandra supports ""read repair,"" i.e., lazy repair when a r…",CASSANDRA-193,"Currently cassandra supports ""read repair,"" i.e., lazy repair when a read is done.",,Existing system architecture description,3:86 - 3:167,1,arjan
2:2,This is better  than nothing but is not sufcient for some cases (e.g.…,CASSANDRA-193,"This is better  than nothing but is not sufcient for some cases (e.g. catastrophic node failure where you need to  rebuild all of a node’s data on a new machine).
",,Run-time quality issues,3:169 - 3:332,1,arjan
2:3,Dynamo uses merkle trees here.,CASSANDRA-193,Dynamo uses merkle trees here.,,Other system architectural solutions,3:333 - 3:362,1,arjan
2:4,This is harder for Cassandra given the CF data model but I  suppose we…,CASSANDRA-193,"This is harder for Cassandra given the CF data model but I  suppose we could just hash the serialized CF value.
",,Architectural solution benefits and drawbacks,3:364 - 3:475,1,arjan
2:217,jbellis,CASSANDRA-193,jbellis,,Comment,4:416 - 4:422,1,arjan
2:5,To start with the good news: one thing which may seem on the face of i…,CASSANDRA-193," To start with the good news: one thing which may seem on the face of it to be a  problem, isn’t really. That is, how do you get nodes replicating a given token range to agree  where to freeze or snapshot the data set to be repaired, in the face of continuing updates?
The answer is, you don’t; it doesn’t matter. If we repair a few columnfamilies that don’t  really need it (because one of the nodes was just a bit slower to process an update than the  other), that’s no big deal. We accept that and move on.
",,Existing system architecture description,4:424 - 4:935,1,arjan
2:6,"The bad news is, I don’t see a clever solution for performing broad-ba…",CASSANDRA-193,"The bad news is, I don’t see a clever solution for performing broad-based repair against  the Memtable/SSTable model similar to Merkle trees for Dynamo/bdb. (Of course, that is  no guarantee that none such exists. :)",,Motivation of design issue,4:936 - 4:1151,1,arjan
2:7,"In passing, it’s worth noting that Bigtable sidesteps these  issues by…",CASSANDRA-193,"In passing, it’s worth noting that Bigtable sidesteps these  issues by writing both commit logs and sstables to GFS, which takes care of durability.
Here we have to do more work in exchange for a simpler model and better performance on  ordinary reads and writes.",,Architectural tactics,4:1185 - 4:1448,1,arjan
2:8,One difculty lies in how data in one SSTable may be pre-empted by anot…,CASSANDRA-193,One difculty lies in how data in one SSTable may be pre-empted by another.,,Architectural component behavior and structure,4:1452 - 4:1525,1,arjan
2:9,"Because  of this, any hash-based ""summary"" of a row may be obsoleted b…",CASSANDRA-193,"Because  of this, any hash-based ""summary"" of a row may be obsoleted by rows in another. For some  workloads, particularly ones in which most keys are updated infrequently, caching such a  summary in the sstable or index fle might still be useful, but it should be kept in mind that  in the worst case these will just be wasted efort.
",,Architectural solution benefits and drawbacks,4:1527 - 4:1862,1,arjan
2:10,I think it would be a mistake to address this by forcing a major compa…,CASSANDRA-193,I think it would be a mistake to address this by forcing a major compaction -- combin-  ing all sstables for the columnfamily into one -- as a prerequisite to repair.,,"Architectural component behavior and structure
Assumptions",4:1864 - 4:2029,2,arjan
2:11,Reading and  rewriting _all_ the data for _each_ repair is a signifcan…,CASSANDRA-193,Reading and  rewriting _all_ the data for _each_ repair is a signifcant amount of extra I/O,,Architectural solution benefits and drawbacks,4:2031 - 4:2121,1,arjan
2:12,"Another is that token regions do not correspond 1:1 to sstables, becau…",CASSANDRA-193,"Another is that token regions do not correspond 1:1 to sstables, because each node is re-  sponsible for N token regions -- the regions for which is is the primary, secondar, tertiary,  etc. repository for -- all intermingled in the SSTable fles.",,Architectural component behavior and structure,5:1 - 5:246,1,arjan
2:13,So any precomputation would  need to be done separately N times.,CASSANDRA-193,"So any precomputation would  need to be done separately N times.
",,Architectural solution benefits and drawbacks,5:248 - 5:312,1,arjan
2:14,"Finally, we can’t assume that sstable or even just row key names will…",CASSANDRA-193,"Finally, we can’t assume that sstable or even just row key names will ft into the heap,",,Architectural component behavior and structure,5:314 - 5:400,1,arjan
2:15,which limits the kind of in-memory structures we can build.,CASSANDRA-193,"which limits the kind of in-memory structures we can build.
",,Architectural solution benefits and drawbacks,5:403 - 5:462,1,arjan
2:16,So from what I do not think it is worth the complexity to attempt to c…,CASSANDRA-193,"So from what I do not think it is worth the complexity to attempt to cache per-row hashes  or summaries of the sstable data in the sstable or index fles.
",,"Architectural solution benefits and drawbacks
Assumptions",5:464 - 5:618,2,arjan
2:17,So the approach I propose is simply to iterate through the key space o…,CASSANDRA-193,"So the approach I propose is simply to iterate through the key space on a per-CF basis,  compute a hash, and repair if there is a mismatch. The code to iterate keys is already there  (for the compaction code) and so is the code to compute hashes and repair if a mismatch is  found (for read repair). ",,Architectural component behavior and structure,5:619 - 5:918,1,arjan
2:18,I think it will be worth fushing the current memtable frst to avoid  h…,CASSANDRA-193,"I think it will be worth fushing the current memtable frst to avoid  having to take a read lock on it.
",,"Architectural component behavior and structure
Assumptions",5:919 - 5:1021,2,arjan
2:19,Enhancements could include building a merkle tree from each batch of h…,CASSANDRA-193,Enhancements could include building a merkle tree from each batch of hashes to minimize  round trips ,,Architectural component behavior and structure,5:1023 - 5:1123,1,arjan
2:20,although unfortunately I think that is not going to be a bottleneck fo…,CASSANDRA-193,although unfortunately I think that is not going to be a bottleneck for Cassan-  dra compared to the hash computation -- and fxing the compaction and hash computation  code to iterate through columns in a CF rather than deserializing each ColumnFamily in its  entirety.,,Trade-offs,5:1127 - 5:1395,1,arjan
2:218,jbellis,CASSANDRA-193,jbellis,,Comment,5:1455 - 5:1461,1,arjan
2:21,"to be specifc, for key iteration, start with ColumnFamilyStore.getKeyR…",CASSANDRA-193,"to be specifc, for key iteration, start with ColumnFamilyStore.getKeyRange.
for the hashing, look at StorageProxy.strongRead -- frst it sends a ""digest"" message to  the non-primary nodes; this computes a hash, and if there is a mismatch then it does a  repair step in the catch block.
",,Architectural design configuration,5:1464 - 5:1750,1,arjan
2:219,jbellis,CASSANDRA-193,jbellis,,Comment,5:1754 - 5:1760,1,arjan
2:22,IRC: i am considering storing the hashes for an SSTable in another SST…,CASSANDRA-193,IRC: i am considering storing the hashes for an SSTable in another SSTable,,Architectural component behavior and structure,5:1763 - 5:1836,1,arjan
2:23,to  prevent them from being recalculated,CASSANDRA-193,to  prevent them from being recalculated,,Architectural solution benefits and drawbacks,5:1839 - 5:1878,1,arjan
2:25,If it were useful to have the per-sstable hashes precalculated,CASSANDRA-193,If it were useful to have the per-sstable hashes precalculated,,Architectural solution benefits and drawbacks,5:1881 - 5:1942,1,arjan
2:24,we could keep them in the  SSTable itself (with the appropriate format…,CASSANDRA-193,we could keep them in the  SSTable itself (with the appropriate format change).,,Architectural component behavior and structure,5:1945 - 5:2023,1,arjan
2:26,"The problem is, that we need to hash  the entire row, which means merg…",CASSANDRA-193,"The problem is, that we need to hash  the entire row, which means merging columns from multiple sstables,",,Architectural component behavior and structure,5:2025 - 5:2129,1,arjan
2:27,which means no per-  sstable hash will be useful.,CASSANDRA-193,which means no per-  sstable hash will be useful.,,Architectural solution benefits and drawbacks,5:2131 - 5:2179,1,arjan
2:220,stuhood,CASSANDRA-193,stuhood,,Comment,5:2243 - 5:2249,1,arjan
2:28,i am considering storing the hashes for an SSTable in another SSTable,CASSANDRA-193, i am considering storing the hashes for an SSTable in another SSTable,,Architectural component behavior and structure,5:2258 - 5:2327,1,arjan
2:29,to prevent them from being recalculated,CASSANDRA-193,to prevent them from being recalculated,,Architectural solution benefits and drawbacks,5:2331 - 5:2369,1,arjan
2:30,this would waste a  ton of CPU time hashing something that we may neve…,CASSANDRA-193, this would waste a  ton of CPU time hashing something that we may never need.,,Architectural tactics,5:2401 - 5:2478,1,arjan
2:221,stuhood,CASSANDRA-193,stuhood,,Comment,5:2484 - 5:2490,1,arjan
2:31,The current plan is for an AntiEntropyService per table to maintain a…,CASSANDRA-193,The current plan is for an AntiEntropyService per table to maintain a Merkle  Tree per column family,,Architectural design configuration,5:2493 - 5:2592,1,arjan
2:32,"The tree will be implemented as a full, randomized binary tree in memo…",CASSANDRA-193,"The tree will be implemented as a full, randomized binary tree in memory (a ”Treap”:  http://en.wikipedia.org/wiki/Treap ), where every item in the tree represents a range bounded  by the dht.Tokens of its left and right neighbors.",,Architectural design configuration,5:2596 - 5:2826,1,arjan
2:33,"By placing a bound on the total number of  nodes in the tree, we can l…",CASSANDRA-193,"By placing a bound on the total number of  nodes in the tree, we can limit the memory usage.",,Architectural tactics,5:2828 - 5:2919,1,arjan
2:34,We can compact or split ranges in the tree  by removing or adding Toke…,CASSANDRA-193,"We can compact or split ranges in the tree  by removing or adding Tokens. The algorithm for deciding which ranges to compact/split  will be described below.
When a write comes in for a given table, we will place ’invalidation’ operations in a queue for  4
all afected column families. The ExecutorService for the table will read from the queue and  perform the ’invalidations’ as fast as it can. For a given Key/Token, if any column family  tree is marked as ’invalid’, the entire row needs to be read from disk and repaired (at some  point in the future).
An ’invalidation’ operation does a binary search in the Merkle Tree and marks the matching  range as ’invalid’, deleting its hash. We will also take advantage of this step to optimize the  tree: A ”Treap” stores a random priority (P) on each node, and by generating a random P’  and replacing P for a node if P’ < P as we invalidate it, more frequently invalidated ranges  will shift to the top of the tree.
The AEService maintaining the tree for a table will occasionally need to exchange portions  of the tree with other nodes. In order to do this, subtrees that both nodes are interested in  from all CF trees will have to be locked long enough to recalculate all ’invalid’ children, and  then the locks can fow down the tree as progressively smaller ranges are exhanged. Doing  this locking efciently is going to be interesting (aka: I haven’t thought about it).
",,Architectural design configuration,5:2921 - 6:1171,1,arjan
2:35,Implementing the exchange between nodes is blocked by CASSANDRA-242 be…,CASSANDRA-193,"Implementing the exchange between nodes is blocked by CASSANDRA-242 because in order  to align the subtrees on diferent nodes, we need to be able to deterministically split two  ranges.
",,Contextual constraints,6:1172 - 6:1358,1,arjan
2:36,"In order to fll in ’invalid’ ranges in the tree, the MerkleTree will p…",CASSANDRA-193,"In order to fll in ’invalid’ ranges in the tree, the MerkleTree will provide an operation  that builds a list of invalid ranges to be fetched from disk. During this step, we can also  compact/split ranges. Because of our Treap maintenance, frequently invalidated ranges will  be nearer to the top of the tree, and stable ranges will be closer to the bottom. By com-  pacting the deepest N leaves and expanding the shallowest N",,Architectural design configuration,6:1359 - 6:1784,1,arjan
2:37,we can minimize the size of  the ranges that are afected by invalidati…,CASSANDRA-193,"we can minimize the size of  the ranges that are afected by invalidations in the future.
",,Architectural solution benefits and drawbacks,6:1787 - 6:1875,1,arjan
2:38,Given the list of ’invalid’ ranges (and pointers directly to the tree…,CASSANDRA-193,"Given the list of ’invalid’ ranges (and pointers directly to the tree nodes), the AEService  will fetch the ranges from the current MemTable and SSTables for the CF, hash them, and  store the hashes into the relevant nodes. After this operation, we can recursively calculate  hashes for inner nodes.
",,Architectural design configuration,6:1877 - 6:2177,1,arjan
2:222,stuhood,CASSANDRA-193,stuhood,,Comment,6:2409 - 6:2415,1,arjan
2:39,since the tree maintenance is implemented as a separate service,CASSANDRA-193,since the tree maintenance is implemented as a separate service,,Architectural design configuration,6:2431 - 6:2493,1,arjan
2:40,"we  can implement maintaining the tree frst, and then think about how…",CASSANDRA-193,"we  can implement maintaining the tree frst, and then think about how to exchange portions  later.",,Architectural solution benefits and drawbacks,6:2496 - 6:2593,1,arjan
2:223,jbellis,CASSANDRA-193,jbellis,,Comment,6:2599 - 6:2605,1,arjan
2:41,That’s a logical division.,CASSANDRA-193,That’s a logical division.,,Architectural solution benefits and drawbacks,6:2621 - 6:2646,1,arjan
2:42,I’m still a little scared by the performance implications,CASSANDRA-193,I’m still a little scared by the performance implications,,"Architectural solution benefits and drawbacks
Assumptions",6:2649 - 6:2705,2,arjan
2:43,of basically doing mini read-only  compactions to keep the tree accura…,CASSANDRA-193,of basically doing mini read-only  compactions to keep the tree accurate,,Architectural design configuration,6:2707 - 6:2778,1,arjan
2:224,stuhood,CASSANDRA-193,stuhood,,Comment,6:2925 - 6:2931,1,arjan
2:44,"So after a little bit of discussion, we decided to drop the Treap idea…",CASSANDRA-193,"So after a little bit of discussion, we decided to drop the Treap idea, and go with  a B+Tree instead. The Treap would have been slightly faster for invalidations because of  the priority-optimization, but it would be much less memory efcient because of excess inner  5
nodes. Also, the invalidation count can just as easily be represented as a counter on each  leaf node as it could have been by the height of the leaf in the Treap.
",,Trade-offs,6:2934 - 7:165,1,arjan
2:225,jbellis,CASSANDRA-193,jbellis,,Comment,7:170 - 7:176,1,arjan
2:46,The more I think about this the less convinced I am that the partially…,CASSANDRA-193,"The more I think about this the less convinced I am that the partially-invalidated  live tree is going to be worth the overhead of maintaining it (and initializing it on startup).
",,Architectural solution benefits and drawbacks,7:179 - 7:359,1,arjan
2:45,the partially-invalidated  live tree,CASSANDRA-193,the partially-invalidated  live tree,,Architectural design configuration,7:236 - 7:271,1,arjan
2:47,If you instead just create a mini-merkle tree from the frst N keys and…,CASSANDRA-193,"If you instead just create a mini-merkle tree from the frst N keys and exchange that with  the replica nodes, then repeat for the next",,Architectural design configuration,7:360 - 7:493,1,arjan
2:48,you still get a big win on network trafc (which  is the main concern h…,CASSANDRA-193," you still get a big win on network trafc (which  is the main concern here) but you have no startup overhead, no complicated extra main-  tenance to perform on insert, better performance in the worst case and (probably) in the  average case, since you are avoiding random reads in favor of (a potentially greater number  of) streaming reads which assuming a constant workload profle (i.e. the same proportion of  keys being overwritten) is always going to be a win for the streaming case.
",,Trade-offs,7:497 - 7:986,1,arjan
2:49,Implementation detail: you’d want to add an internal message [merkle s…,CASSANDRA-193,"Implementation detail: you’d want to add an internal message [merkle startkey] where  startkey is initially """" and after each iteration you update it to the N’th key _after_ merging  any missing ones.
",,Architectural design configuration,7:987 - 7:1188,1,arjan
2:226,stuhood,CASSANDRA-193,stuhood,,Comment,7:1193 - 7:1199,1,arjan
2:50,There is no need to initialize the tree on startup: it can be done laz…,CASSANDRA-193,"There is no need to initialize the tree on startup: it can be done lazily when  the frst treeexchange requests come in.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",7:1385 - 7:1504,2,arjan
2:51,"Yes, network trafc is important, but the whole point of maintaining th…",CASSANDRA-193,"Yes, network trafc is important, but the whole point of maintaining the tree in memory  is that it prevents us from having to read entire SSTables from disk in order to do repairs  (similar to BloomFilters for random lookups). Any portions of the tree that survive (which  should be large portions, assuming we do invalidations correctly) mean that we can use the  SSTable index to seek() past chunks of the fle.",,Trade-offs,7:1725 - 7:2136,1,arjan
2:52,"* No startup overhead necessary,  * B+Tree invalidations will only inv…",CASSANDRA-193,"* No startup overhead necessary,  * B+Tree invalidations will only involve marking a leaf node invalid: aka, do a lookup and  increment a counter,  * There won’t be any random reads... I’m not sure where you read that: in order to validate  regions of the tree we will be iterating over the keys in the CF in sorted order, skipping  regions that are valid.
",,Architectural solution benefits and drawbacks,7:2407 - 7:2764,1,arjan
2:227,stuhood,CASSANDRA-193,stuhood,,Comment,7:3109 - 7:3115,1,arjan
2:53,"Well, you would have a single large invalid range (or some number of s…",CASSANDRA-193,"Well, you would have a single large invalid range (or some number of smaller ranges summing  to the full range), which could be fetched sequentially from disk.
",,Architectural design configuration,7:3191 - 7:3351,1,arjan
2:54,"Rather than being completely lazy, (depending on how much extra load i…",CASSANDRA-193,"Rather than being completely lazy, (depending on how much extra load it would cause)  we could hook the AEService into compactions that are happening for other reasons, so that  before the compaction begins, the compactor fetches the current list of invalid ranges and  flls them in based on the merged data.",,Architectural design configuration,7:3352 - 7:3659,1,arjan
2:55,"I’m not sure how much of a win this would be, since  6we probably don’…",CASSANDRA-193,"I’m not sure how much of a win this would be, since  6
we probably don’t want to slow down compactions, but if they aren’t CPU bound, then it  shouldn’t hurt.
",,Trade-offs,7:3661 - 8:105,1,arjan
2:228,jbellis,CASSANDRA-193,jbellis,,Comment,8:110 - 8:116,1,arjan
2:56,So you are basically looking at doing a bulk scan no matter what.,CASSANDRA-193," So you are basically looking at doing a bulk scan no matter what.
",,Architectural design configuration,8:118 - 8:185,1,arjan
2:57,"Then the question becomes, is it worth trying to keep (partial) result…",CASSANDRA-193,"Then the question becomes, is it worth trying to keep (partial) results of that scan in  memory to avoid re-doing the work next time around. If writes are randomly distributed  across the range then ISTM the answer is a clear No, but I’m not sure how close real-world  workloads would come to that.
",,Trade-offs,8:186 - 8:485,1,arjan
2:58,start with a non-caching version like I describe,CASSANDRA-193, start with a non-caching version like I describe,,Architectural design configuration,8:507 - 8:555,1,arjan
2:59,I think that a  lot of the functionality implemented would be reusable…,CASSANDRA-193,"I think that a  lot of the functionality implemented would be reusable, and it would give us a useful start-  ing point to give us a better feel for the additional complexity your ""full"" version would entail.",,"Architectural solution benefits and drawbacks
Assumptions",8:558 - 8:765,2,arjan
2:60,"Incidently, I don’t think we should worry about the kind of locking yo…",CASSANDRA-193,"Incidently, I don’t think we should worry about the kind of locking you mentioned. The  point of the merkle tree is to save us from exchanging 90% of keys; if we don’t lock and the  trees end up slightly de-synced and we exchange a few keys at the edges that we wouldn’t  have to with a ""perfect"" algorithm, that is a price I’m happy to pay for a much less compli-  cated solution.
",,"Assumptions
Trade-offs",8:768 - 8:1150,2,arjan
2:229,stuhood,CASSANDRA-193,stuhood,,Comment,8:1155 - 8:1161,1,arjan
2:61,"You’re right that the tree is basically a ’range hash  cache’, but I d…",CASSANDRA-193,"You’re right that the tree is basically a ’range hash  cache’, but I don’t think that writes will be randomly distributed. Especially since we allow  complex values, I think people are more likely to have ’hot’ keys. Adding in the OrderPre-  servingPartitioner makes it even more likely to have hot ranges.
",,"Architectural solution benefits and drawbacks
Assumptions",8:1466 - 8:1773,2,arjan
2:62,"we could initialize a new MerkleTree at repair time, use the range has…",CASSANDRA-193," we could initialize a new MerkleTree at repair time, use the range hashing API  I’ve described, and throw it away at the end of the repair. Next, we could implement main-  taining/invalidating the tree between repairs.",,Architectural design configuration,8:1857 - 8:2075,1,arjan
2:63,I’m not sure how much simpler this is (since  the invalidation of rang…,CASSANDRA-193,"I’m not sure how much simpler this is (since  the invalidation of ranges is probably the simplest part of the whole deal).
",,Trade-offs,8:2077 - 8:2200,1,arjan
2:64,"since a separate thread/agent/executor is maintaining the tree, the lo…",CASSANDRA-193,"since a separate thread/agent/executor is maintaining the tree, the locking  should be completely unnecessary. Whenever we’re performing a repair, we’re not accepting  invalidations, so we’re looking at a snapshot of the tree.
",,Architectural design configuration,8:2301 - 8:2527,1,arjan
2:230,stuhood,CASSANDRA-193,stuhood,,Comment,8:2982 - 8:2988,1,arjan
2:65,TreeRange.validate(Iterator) will need to take an iterator over Column…,CASSANDRA-193," TreeRange.validate(Iterator) will need to take an iterator over ColumnFamily (Token,hash)  pairs",,Architectural design configuration,8:3091 - 8:3187,1,arjan
2:66,"It currently takes an iterator over Tokens, and uses a dummy hash valu…",CASSANDRA-193,"It currently takes an iterator over Tokens, and uses a dummy hash value,",,Existing system architecture description,8:3190 - 8:3261,1,arjan
2:67,We’re still blocked by CASSANDRA-242,CASSANDRA-193,We’re still blocked by CASSANDRA-242,,Contextual constraints,8:3266 - 8:3301,1,arjan
2:68,"this patch contains a hacked implementation of  Range.midpoint(Token,…",CASSANDRA-193," this patch contains a hacked implementation of  Range.midpoint(Token, Token) that only works with BigIntegerToken.",,Existing system architecture description,8:3303 - 8:3417,1,arjan
2:231,stuhood,CASSANDRA-193,stuhood,,Comment,9:5 - 9:11,1,arjan
2:69,* Added o.a.c.service.AntiEntropyService - Maintains trees for each CF…,CASSANDRA-193,"* Added o.a.c.service.AntiEntropyService - Maintains trees for each CF, and accepts invali-  dations when values change.
",,Existing system architecture description,9:81 - 9:202,1,arjan
2:70,* Implement TreeRequestVerbHandler/TreeResponseVerbHandler - The AESer…,CASSANDRA-193,"* Implement TreeRequestVerbHandler/TreeResponseVerbHandler - The AEService on a frst  endpoint will periodically wake up and send a TreeRequest to a replica. The replica endpoint  will handle the TreeRequest by validating one or all of its MerkleTrees, and responding with  a TreeResponse. Handling the TreeResponse on the frst endpoint will involve validating the  local tree, and then comparing the two trees.
* Validation is the only part that is fuzzy here: we need to iterate over keys in each CF  (essentially, a major compaction, except that we can skip processing for anything that is still  valid in the tree).
* Begin implementing the actual repair step",,Architectural design configuration,9:216 - 9:880,1,arjan
2:71,The output of the TreeRequest/TreeResponse conversation  will be a lis…,CASSANDRA-193,"The output of the TreeRequest/TreeResponse conversation  will be a list of ranges in a given CF that disagree between the two endpoints.
",,Architectural design configuration,9:960 - 9:1096,1,arjan
2:232,stuhood,CASSANDRA-193,stuhood,,Comment,9:1189 - 9:1195,1,arjan
2:72,Since Memtables are always fushed after a bounded period (I think?) it…,CASSANDRA-193,Since Memtables are always fushed after a bounded period (I think?) it is possible to  completely ignore them.,,"Architectural component behavior and structure
Assumptions",9:1293 - 9:1402,2,arjan
2:73,"Due to 1, invalidating a range for every Memtable change is dumb/overk…",CASSANDRA-193,"Due to 1, invalidating a range for every Memtable change is dumb/overkill. It would be  much more efcient to only invalidate during minor compactions.
",,Architectural tactics,9:1408 - 9:1559,1,arjan
2:74,"Again, due to 1, we only care about the data afected during a major co…",CASSANDRA-193,"Again, due to 1, we only care about the data afected during a major compaction, so we  can validate the tree during every major compaction.
",,Architectural design configuration,9:1563 - 9:1703,1,arjan
2:75,If we hook tree validation into major compactions:  * Handling TreeReq…,CASSANDRA-193,"If we hook tree validation into major compactions:  * Handling TreeRequests/TreeResponses would be queued until the next major compaction,  * The compactor would acquire a lock on the tree for the CF, validate it, and then handle  outstanding TreeRequests/TreeResponses.
",,Architectural design configuration,9:1704 - 9:1975,1,arjan
2:233,stuhood,CASSANDRA-193,stuhood,,Comment,9:1980 - 9:1986,1,arjan
2:234,stuhood,CASSANDRA-193,stuhood,,Comment,9:2109 - 9:2115,1,arjan
2:76,"The patchset:  1. Prepares to add the MerkleTree datastructure,  2. Ad…",CASSANDRA-193,"The patchset:  1. Prepares to add the MerkleTree datastructure,  2. Adds the datastructure,  3. Prepares to add AntiEntropyService,  4. Adds the service.
",,Architectural design configuration,9:2162 - 9:2316,1,arjan
2:235,junrao,CASSANDRA-193,junrao,,Comment,9:2398 - 9:2403,1,arjan
2:77,1. Each node N periodically computes a Merkle tree for rows in each ne…,CASSANDRA-193,"1. Each node N periodically computes a Merkle tree for rows in each new SSTable generated  through compaction.
2. The Merkle tree is sent and registered to other nodes that share key ranges with N.
3. The locally computed Merkle tree will be compared with those registered remote Merkle  trees. If there is any diference, trigger a repair.
",,Existing system architecture description,9:2526 - 9:2868,1,arjan
2:78,"Since compaction is triggered independently at each node, the rows in…",CASSANDRA-193,"Since compaction is triggered independently at each node, the rows in two compacted SSTa-  bles generated in two neighboring nodes are unlikely to match. Won’t the above approach  trigger too many unnecessary repairs?
",,Risks,9:2869 - 9:3087,1,arjan
2:236,jbellis,CASSANDRA-193,jbellis,,Comment,10:5 - 10:11,1,arjan
2:79,"major compactions are never  done automatically, so if we assume they…",CASSANDRA-193,"major compactions are never  done automatically, so if we assume they are done by cron or dsh or some other similarly  ""reasonably synchronous"" method it should be fne. right?",,"Assumptions
Existing system architecture description",10:67 - 10:241,2,arjan
2:237,junrao,CASSANDRA-193,junrao,,Comment,10:299 - 10:304,1,arjan
2:80,The patch piggy-  backs the computation on a regular compaction. Even…,CASSANDRA-193,"The patch piggy-  backs the computation on a regular compaction. Even if it’s moved to major compaction,  it’s still not enough. This is because there is an upper limit on fle size. Therefore, not all  sstables are necessarily read during a major compaction, which means the Merkle tree may  not see all keys in a particular key range.
",,Run-time quality issues,10:470 - 10:806,1,arjan
2:81,One approach is to explicitly iterate through keys on all sstables in…,CASSANDRA-193,"One approach is to explicitly iterate through keys on all sstables in a particular range,  compute the Merkle tree, send the Merkle tree to replicas. Each replica then computes its  own Merkle tree and do the comparison. We can trigger this process through a nodeprobe  command.
",,Architectural design configuration,10:807 - 10:1086,1,arjan
2:82,"In MerkleTree.Node.insert, why do you increment the depth of the left…",CASSANDRA-193,"In MerkleTree.Node.insert, why do you increment the depth of the left child even when  the node doesn’t split?",,Existing system architecture description,10:1355 - 10:1464,1,arjan
2:83,"In the same function, do you have to keep calling invalidate during in…",CASSANDRA-193," In the same function, do you have to keep calling invalidate during insertion?",,Existing system architecture description,10:1598 - 10:1676,1,arjan
2:84,It seems  to me that it would be simpler if you frst split the tree to…,CASSANDRA-193,"It seems  to me that it would be simpler if you frst split the tree to what you want, then make a pass  of the tree to invalidate all nodes before computing the hashes.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",10:1678 - 10:1847,2,arjan
2:85,Why do you have to compute multiple hash values recursively?,CASSANDRA-193,"Why do you have to compute multiple hash values recursively?
",,Existing system architecture description,10:2101 - 10:2161,1,arjan
2:238,stuhood,CASSANDRA-193,stuhood,,Comment,10:2470 - 10:2476,1,arjan
2:86,Node.insert() is only used during split operations (perhaps it is misn…,CASSANDRA-193,"Node.insert() is only used during split operations (perhaps it is misnamed... but this is not  quite a traditional B-Tree). The child to the left is the node that contains the Token we  were splitting on, and whenever we split a range we increment its depth to indicate how far  9
it is from being a complete (0,0] range.",,Existing system architecture description,10:2744 - 11:40,1,arjan
2:87,Node.insert() uses List.subList() and List.clear() inline to take half…,CASSANDRA-193,"Node.insert() uses List.subList() and List.clear() inline to take half of its neighbor’s children.
",,Existing system architecture description,11:209 - 11:308,1,arjan
2:88,The original design assumed that the tree was going to live for a whil…,CASSANDRA-193,"The original design assumed that the tree was going to live for a while in memory, and be  maintained between repair sessions, so the split operation is intended to be used on a tree  that might be partially valid.",,Existing system architecture description,11:395 - 11:608,1,arjan
2:89,We might be able to have the initial building of the tree skip  this c…,CASSANDRA-193,"We might be able to have the initial building of the tree skip  this check somehow, but I don’t think the ’hash == null? hash = null;’ check is too intensive.
",,Trade-offs,11:610 - 11:769,1,arjan
2:90,"The ""private MerkleTree.TreeRangeIterator ranges"" variable is an itera…",CASSANDRA-193,"The ""private MerkleTree.TreeRangeIterator ranges"" variable is an iterator generated by the  MerkleTree: it iterates in order over all of the ranges in the tree that have null hashes.
",,Existing system architecture description,11:876 - 11:1058,1,arjan
2:91,The reasoning here is that a MerkleTree is supposed to be a sparse rep…,CASSANDRA-193,"The reasoning here is that a MerkleTree is supposed to be a sparse representation of a ’per-  fect/complete’ binary tree. Each leaf of the perfect tree represents a hashed range, and  each inner node represents a binary hash of its two children. The perfect tree is of depth  ""hashdepth"", so when validateHelper() reaches the maximum/hashdepth, it is in one of the  leaves of the perfect tree, and rows are hashed sequentially there. <EDIT comment=""Ignore  everything in in this tag"">If a single call to validate() starts in a TreeRange that is at depth  == maxdepth, then what is stored in the MkT.Node is the value of a perfect leaf, otherwise,  the MkT.Node is storing the value of a perfect inner node.</EDIT>",,Existing system architecture description,11:1165 - 11:1877,1,arjan
2:92,1. It recurses using midpoint as long as both trees have the resolutio…,CASSANDRA-193,"1. It recurses using midpoint as long as both trees have the resolution to continue, and are  not equal.
2a. If it fnds a range that has only one invalid child, it adds that child range, since that is  the smallest possible invalid range contained in the parent.
2b. Otherwise, if both children are invalid (and since it can’t recurse deeper), the parent  range is entirely invalid, and recursion keeps rolling up until 2a is met.
",,Existing system architecture description,11:2094 - 11:2527,1,arjan
2:239,stuhood,CASSANDRA-193,stuhood,,Comment,11:2916 - 11:2922,1,arjan
2:93,I see that you’re right about major compactions not always involving a…,CASSANDRA-193,I see that you’re right about major compactions not always involving all sstables,,Existing system architecture description,11:2997 - 11:3077,1,arjan
2:94,"At some point, we need to make a  decision allowing repairs to run mor…",CASSANDRA-193,"At some point, we need to make a  decision allowing repairs to run more frequently,",,Quality Attribute requirement,11:3144 - 11:3226,1,arjan
2:95,Absolutely optimal would be to have them begin generating the trees at…,CASSANDRA-193,"Absolutely optimal would be to have them begin generating the trees at the exact same  time, immediately after a fush. I don’t think that is really feasible though.",,"Architectural design configuration
Architectural solution benefits and drawbacks",12:179 - 12:342,2,arjan
2:96,"Adding this operation seems like a good idea: efectively, it is a ’noo…",CASSANDRA-193,"Adding this operation seems like a good idea: efectively, it is a ’noop’ major compaction  (which would still need to acquire compaction locks), which doesn’t actually output the  merged data.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",12:418 - 12:611,2,arjan
2:97,"if repair was running indepen-  dently of other compactions, perhaps i…",CASSANDRA-193,"if repair was running indepen-  dently of other compactions, perhaps it could choose to only ""noop-compact"" sstables that  existed when the tree was generated on the other node? Rather than stopping time, or  trying to perform the validation in sync, we would only repair the older data. With this  approach, we might end up, for example, repairing a key (based on older sstables) that is  deleted by newer sstables.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",12:669 - 12:1086,2,arjan
2:240,junrao,CASSANDRA-193,junrao,,Comment,12:1248 - 12:1253,1,arjan
2:102,"The ranges don’t change after the iterator is generated, right? But in…",CASSANDRA-193," The ranges don’t change after the iterator is generated, right? But inside the while  loop in Validator.add, there is comment about adding a new range. So, are you really  adding a new range there or the comment is wrong?
",,Existing system architecture description,12:1342 - 12:1565,1,arjan
2:100,Why is Merkle tree a binary tree?,CASSANDRA-193,Why is Merkle tree a binary tree?,,Existing system architecture description,12:1570 - 12:1602,1,arjan
2:99,I thought it’s an n-ary tree since you can specify  the order of each…,CASSANDRA-193,"I thought it’s an n-ary tree since you can specify  the order of each node.
",,"Architectural component behavior and structure
Assumptions",12:1604 - 12:1679,2,arjan
2:101,"Since a leaf node corresponds to a single range, why do you need a lis…",CASSANDRA-193,"Since a leaf node corresponds to a single range, why do you need a list of hashes",,Existing system architecture description,12:1681 - 12:1761,1,arjan
2:98,I thought  each leaf node maintains a single hash value for rows its r…,CASSANDRA-193, I thought  each leaf node maintains a single hash value for rows its range and each inner node main-  tains a single hash that is the logical AND of the hashes of all its children.,,"Architectural design configuration
Assumptions",12:1763 - 12:1943,2,arjan
2:241,stuhood,CASSANDRA-193,stuhood,,Comment,12:1971 - 12:1977,1,arjan
2:103,This MerkleTree data structure is an n-ary tree that represents a perf…,CASSANDRA-193,"This MerkleTree data structure is an n-ary tree that represents a perfect binary hash tree.
",,Existing system architecture description,12:2099 - 12:2191,1,arjan
2:104,It is the leaves of the perfect tree which contain sequentially hashed…,CASSANDRA-193,"It is the leaves of the perfect tree which contain sequentially hashed  values, and the inner nodes of the perfect tree contain the logical AND hash of their children.
",,Existing system architecture description,12:2594 - 12:2762,1,arjan
2:105,"This perfect binary tree has a max depth of 2, so the maximum  depth o…",CASSANDRA-193,"This perfect binary tree has a max depth of 2, so the maximum  depth of a MkT.Hash in the MkTree representing it is 2 as well. In this case though, the  MkTree has only been split twice, so it contains a single MkT.Leaf and three MkT.Hashes.
Each MkT.Hash represents a node from the perfect tree, but they are not all at the same  11
depth in the tree. MkT.Nodes will not always correspond to a node from the binary tree  (because the orders are not equal), but when they do, we can cache a value in that MkT.Node.
The important thing to notice, is that if the MkTree had been split at 8 and 12 instead  of 4 and 8, it would still represent the same perfect binary tree, which is why we can com-  pare MkTrees generated by diferent Cassandra endpoints.
The MkTree.Hash for (8, 0] represents an inner node in the perfect tree, so in order to  calculate it in the same manner no matter how a Cassandra endpoint chooses to split the  MkTree, during validateHelper() we always generate a perfect tree down to the maximum  hash depth, sequentially hash rows into the perfect leaves, and then calculate the logical  AND back up to the range needed by validate().
",,Existing system architecture description,12:2789 - 13:826,1,arjan
2:106,All depths in the code refer to the depth of the perfect binary tree t…,CASSANDRA-193,"All depths in the code refer to the depth of the perfect binary tree that a Node or Hash  represents. This is why MkT.Nodes can only occasionally contain hash values: it’s fairly  common for a N-ary tree to contain a node representing a range that isn’t represented by a  single node in a binary tree.
",,Existing system architecture description,13:912 - 13:1213,1,arjan
2:107,"The comment says ""generate a new range"": it is asking for TreeRangeIte…",CASSANDRA-193,"The comment says ""generate a new range"": it is asking for TreeRangeIterator.next(), which  hides the generation of the next range that needs to be hashed, and returns it.
",,Existing system architecture description,13:1376 - 13:1547,1,arjan
2:242,junrao,CASSANDRA-193,junrao,,Comment,13:1612 - 13:1617,1,arjan
2:108,Why do you want to use an n-ary tree to represent a binary tree?,CASSANDRA-193,Why do you want to use an n-ary tree to represent a binary tree?,,Existing system architecture description,13:1702 - 13:1765,1,arjan
2:109,Why can’t you just  implement Merkle tree as an in-complete binary tre…,CASSANDRA-193,Why can’t you just  implement Merkle tree as an in-complete binary tree itself?,,Architectural component behavior and structure,13:1767 - 13:1845,1,arjan
2:110,"This way, there is less confusing  about whether a node refers to one…",CASSANDRA-193,"This way, there is less confusing  about whether a node refers to one in the n-ary tree or the binary tree.
",,Architectural solution benefits and drawbacks,13:1847 - 13:1955,1,arjan
2:111,Suppose + is the bit-wise AND btw 2 hash values and you compute the ha…,CASSANDRA-193,"Suppose + is the bit-wise AND btw 2 hash values and you compute the hash of a range  as the sum of the hash of each row in the range. Then, it seems that you can compute the  hash of a range directly (since now + is commutative and transitive), without a bottom-up  traversal from the leaves of the complete binary tree.",,"Architectural component behavior and structure
Assumptions",13:1959 - 13:2278,2,arjan
2:112,Wouldn’t this be simpler?,CASSANDRA-193,Wouldn’t this be simpler?,,"Architectural solution benefits and drawbacks
Assumptions",13:2280 - 13:2304,2,arjan
2:243,stuhood,CASSANDRA-193,stuhood,,Comment,13:2311 - 13:2317,1,arjan
2:113,The main reason was due to memory concerns...,CASSANDRA-193,The main reason was due to memory concerns...,,Architectural tactics,13:2391 - 13:2435,1,arjan
2:114,"for 256 subranges, an order 256 B-Tree  only needs 1 inner node (total…",CASSANDRA-193,"for 256 subranges, an order 256 B-Tree  only needs 1 inner node (total 257), while a binary tree would need 127 inner nodes (to-  tal 383)",,Architectural component behavior and structure,13:2437 - 13:2574,1,arjan
2:115,"Also, in order to get reasonable performance out of a binary tree over…",CASSANDRA-193,"Also, in order to get reasonable performance out of a binary tree over its life-  time,",,Architectural tactics,13:2577 - 13:2663,1,arjan
2:116,you would probably want to implement a self balancing tree,CASSANDRA-193,you would probably want to implement a self balancing tree,,Architectural component behavior and structure,13:2665 - 13:2722,1,arjan
2:117,which isn’t much sim-  pler than a B-Tree,CASSANDRA-193,which isn’t much sim-  pler than a B-Tree,,Architectural solution benefits and drawbacks,13:2725 - 13:2765,1,arjan
2:118,"Finally, B-Trees are arguably faster than binary tree implementations:",CASSANDRA-193,"Finally, B-Trees are arguably faster than binary tree implementations:",,Architectural solution benefits and drawbacks,13:2768 - 13:2837,1,arjan
2:119,"we don’t use AND or any other commuta-  tive operations in the tree,",CASSANDRA-193,"we don’t use AND or any other commuta-  tive operations in the tree,",,Existing system architecture description,13:3178 - 13:3245,1,arjan
2:120,since it would be more likely to cause hash collisions (switched  subt…,CASSANDRA-193," since it would be more likely to cause hash collisions (switched  subtrees might compare equally).
",,Architectural solution benefits and drawbacks,13:3246 - 13:3346,1,arjan
2:121,"All hashing is accomplished by a single method: Hashable.hash(byte[],…",CASSANDRA-193,"All hashing is accomplished by a single method: Hashable.hash(byte[], byte[]), which is  currently implemented using MD5.
",,Existing system architecture description,13:3347 - 13:3469,1,arjan
2:244,junrao,CASSANDRA-193,junrao,,Comment,14:5 - 14:10,1,arjan
2:122,Another complexity arises because you assume that the ranges in 2 dife…,CASSANDRA-193,Another complexity arises because you assume that the ranges in 2 diferent Merkle  trees are diferent.,,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",14:13 - 14:114,2,arjan
2:123,Why can’t you frst build the key ranges from a sample of the keys in…,CASSANDRA-193,Why can’t you frst build the key ranges from a sample of the keys in  one node and then reuse those key ranges to build a Merkle on every replica?,,Architectural component behavior and structure,14:116 - 14:261,1,arjan
2:124,That would  simplify both the computation and the dif of the hash valu…,CASSANDRA-193," That would  simplify both the computation and the dif of the hash values.
",,Architectural solution benefits and drawbacks,14:262 - 14:337,1,arjan
2:245,stuhood,CASSANDRA-193,stuhood,,Comment,14:342 - 14:348,1,arjan
2:125,This is another decision that arose from the idea of maintaining the t…,CASSANDRA-193,"This is another decision that arose from the idea of maintaining the tree over a longer period  by invalidating ranges, and only compacting the ranges that had changed recently. The  replicas would end up with divergent splits in the trees. If we go back to assuming that we  never want to maintain a tree between compactions, then compact() and invalidate() could  be removed, and diferences() could be simplifed.
But considering the fact that we are hesitant to trigger a major compaction for every repair,  maintaining the tree between repairs becomes a more interesting option.",,Trade-offs,14:457 - 14:1038,1,arjan
2:246,junrao,CASSANDRA-193,junrao,,Comment,14:1045 - 14:1050,1,arjan
2:126,"Now that I understood how the code really works, I don’t have any big…",CASSANDRA-193," Now that I understood how the code really works, I don’t have any big issue with  the patch. ",,Architectural solution benefits and drawbacks,14:1052 - 14:1145,1,arjan
2:127,"To get us started, can we trigger a Merkle tree repair manually from n…",CASSANDRA-193,"To get us started, can we trigger a Merkle tree repair manually from nodeprobe. Some-  thing like the following:  trigger Merkle tree repair for a Keyspace/CF on a node from nodeprobe  the range to be fxed is (token from left node, token from this node]  each replica of this range computes Merkle tree independently, in parallel, through a full  scan of all SSTables.
when done, Merkle trees are compared and repairs triggered, if necessary.
",,Architectural design configuration,14:1171 - 14:1615,1,arjan
2:128,"In MerkleTree.diference(), shouldn’t you add a case that returns an em…",CASSANDRA-193,"In MerkleTree.diference(), shouldn’t you add a case that returns an empty dif when the  trees are consistent?
",,Architectural component behavior and structure,14:2024 - 14:2133,1,arjan
2:247,stuhood,CASSANDRA-193,stuhood,,Comment,14:2824 - 14:2830,1,arjan
2:129,"the list of ""observers"" that were waiting for valid  trees to be gener…",CASSANDRA-193," the list of ""observers"" that were waiting for valid  trees to be generated was too abstract.",,Technical debt,15:41 - 15:133,1,arjan
2:130,"Instead, we keep a Cachetable of valid trees, and  when an endpoint re…",CASSANDRA-193,"Instead, we keep a Cachetable of valid trees, and  when an endpoint receives a tree from another node (via TreeResponse) or generates a tree  locally, it tries to ’rendezvous’ with trees from appropriate neighbors. See uses of AntiEn-  tropyService.register().
",,Existing system architecture description,15:135 - 15:395,1,arjan
2:131,There is also a new patch 5 to add a manual manual repair operation to…,CASSANDRA-193,"There is also a new patch 5 to add a manual manual repair operation to nodeprobe, which  sends out TreeRequests to all natural endpoints for the target nodes token. The nodeprobe  target is the ’initiator’ for the TreeRequests, so once the trees are generated on their re-  spective nodes, they are broadcast out as TreeResponses, and they will rendezvous on the  target/initiator to be diferenced",,Existing system architecture description,15:397 - 15:793,1,arjan
2:248,stuhood,CASSANDRA-193,stuhood,,Comment,15:801 - 15:807,1,arjan
2:133,the system tests look  good. I feel good about this patchset being rea…,CASSANDRA-193,"the system tests look  good. I feel good about this patchset being ready for merge.
",,Architectural solution benefits and drawbacks,15:954 - 15:1037,1,arjan
2:132,The flter to remove the local node from the list of natural endpoints…,CASSANDRA-193,"The flter to remove the local node from the list of natural endpoints was inverted, but  the Gossiper only has one endpoint in tests, which was hiding the fact that we weren’t  caching a generated tree locally",,Run-time quality issues,15:1040 - 15:1248,1,arjan
2:249,stuhood,CASSANDRA-193,stuhood,,Comment,15:1257 - 15:1263,1,arjan
2:134,I noticed two fundamental problems with the Cachetable of trees in the…,CASSANDRA-193, I noticed two fundamental problems with the Cachetable of trees in the current  patchset.,,Run-time quality issues,15:1265 - 15:1354,1,arjan
2:250,stuhood,CASSANDRA-193,stuhood,,Comment,15:1405 - 15:1411,1,arjan
2:135,"I don’t see any more bugs, but I did some testing with a table contain…",CASSANDRA-193,"I don’t see any more bugs, but I did some testing with a table containing 10ˆ6 keys, and a  Readonly compaction took 2 minutes (!). Hopefully a little bit of profling will expose the  issue quickly, because I can understand that performance like that should prevent merging  this patch.",,Run-time quality issues,15:1505 - 15:1790,1,arjan
2:251,stuhood,CASSANDRA-193,stuhood,,Comment,15:1962 - 15:1968,1,arjan
2:136,"Additionally, I fxed a bug due to the minimum token being sorted frst…",CASSANDRA-193,"Additionally, I fxed a bug due to the minimum token being sorted frst in SSTables, while  being contained in the last range of the MerkleTree. ",,Run-time quality issues,15:2409 - 15:2551,1,arjan
2:137,There was also one fundamental issue: we were using MD5 for the sequen…,CASSANDRA-193,"There was also one fundamental issue: we were using MD5 for the sequential hash of the  perfect leaf nodes, but also for the binary hash of the perfect inner nodes. As Clif of the  Dynamite project warned me (ages ago) the inner nodes need to use an associative hash  function if their values are going to be cached.",,Run-time quality issues,15:2592 - 15:2907,1,arjan
2:138,"The performance without caching is suf-  cient, and I didn’t want to r…",CASSANDRA-193,"The performance without caching is suf-  cient, and I didn’t want to rush into picking an algorithm, so for now, caching is simply  disabled, with a TODO mentioning that we should pick an algorithm.
",,Trade-offs,15:2909 - 15:3108,1,arjan
2:252,stuhood,CASSANDRA-193,stuhood,,Comment,16:11 - 16:17,1,arjan
2:139,"After a little more consideration, the caching bug had nothing to do w…",CASSANDRA-193,"After a little more consideration, the caching bug had nothing to do with  our hash function. It was a disconnect between the binary tree, and the b-tree we are using  to store it.",,Run-time quality issues,16:26 - 16:205,1,arjan
2:140,"To be honest, I don’t want to merge something so complex that even the…",CASSANDRA-193,"To be honest, I don’t want to merge something so complex that even the person  who created it still has trouble reasoning about it.
",,Architectural solution benefits and drawbacks,16:207 - 16:339,1,arjan
2:253,junrao,CASSANDRA-193,junrao,,Comment,16:407 - 16:412,1,arjan
2:141,"While you are working on refactoring, do you think that you can do som…",CASSANDRA-193,"While you are working on refactoring, do you think that you can do some anecdotal  tests to see whether we lose any precision by simply using bitwise XOR to combine row  hashes?",,Architectural component behavior and structure,16:415 - 16:591,1,arjan
2:142,Using XOR further simplifes how hash values for internal nodes are com…,CASSANDRA-193,Using XOR further simplifes how hash values for internal nodes are computed.,,Architectural solution benefits and drawbacks,16:593 - 16:668,1,arjan
2:254,stuhood,CASSANDRA-193,stuhood,,Comment,16:675 - 16:681,1,arjan
2:143,Doing the math on this one was simpler than actually testing it: using…,CASSANDRA-193,"Doing the math on this one was simpler than actually testing it: using a commutative hash  function like XOR means that the number of possible inputs goes from being a Permutation  of the leaves to being a Combination of the leaves (since a set of leaves in any order are equal).
For MD5 you have:  (2ˆ127)! / (2ˆ127 - 2ˆ16)! == number of possible permutations of 2ˆ16 hashes of length  127  And for XOR:  (2ˆ127)! / (2ˆ16)! * (2ˆ127 - 2ˆ16)! == number of possible combinations of 2ˆ16 hashes of  length 127",,Architectural component behavior and structure,16:772 - 16:1279,1,arjan
2:144,I wouldn’t think it would be possible to notice such a small diference,CASSANDRA-193,I wouldn’t think it would be possible to notice such a small diference,,Trade-offs,16:1282 - 16:1351,1,arjan
2:147,I don’t think that using XOR is signifcantly more efcient. Because XOR…,CASSANDRA-193,"I don’t think that using XOR is signifcantly more efcient. Because XOR is associative,  it is possible to hash arbitrary sequential leaves together, which is impossible with MD5,  but we never do this: all of our comparison happens on the boundaries defned by IParti-  tioner.midpoint(), so the tree structure containing predefned/precomputed values can con-  tain any value required for comparison.",,Trade-offs,16:1477 - 16:1875,1,arjan
2:255,stuhood,CASSANDRA-193,stuhood,,Comment,16:1882 - 16:1888,1,arjan
2:148,"I refactored the MerkleTree structure into a bi-  nary tree, which dro…",CASSANDRA-193,"I refactored the MerkleTree structure into a bi-  nary tree, which dropped 750 lines from the patch,",,Existing system architecture description,16:2078 - 16:2177,1,arjan
2:149,and made things much much clearer in  general.,CASSANDRA-193, and made things much much clearer in  general.,,Architectural solution benefits and drawbacks,16:2178 - 16:2224,1,arjan
2:150,"Additionally, the MerkleTree now almost exclusively uses methods from…",CASSANDRA-193,"Additionally, the MerkleTree now almost exclusively uses methods from dht.Range  when searching for ranges,",,Architectural design configuration,16:2226 - 16:2332,1,arjan
2:151,which removed a whole bunch special casing for the minimum  token.,CASSANDRA-193,which removed a whole bunch special casing for the minimum  token.,,Architectural solution benefits and drawbacks,16:2334 - 16:2399,1,arjan
2:152,"in general, I feel very happy to  have admitted defeat on the b-tree i…",CASSANDRA-193," in general, I feel very happy to  have admitted defeat on the b-tree idea.
",,Architectural solution benefits and drawbacks,16:2451 - 16:2526,1,arjan
2:256,junrao,CASSANDRA-193,junrao,,Comment,16:2634 - 16:2639,1,arjan
2:153,AES.validator.prepare() requires bufering all keys in a node in memory…,CASSANDRA-193,"AES.validator.prepare() requires bufering all keys in a node in memory. Can you push  sampling into the key iterator?
",,Existing system architecture description,16:2662 - 16:2780,1,arjan
2:154,I still think using XOR to combine MD5 for each row is simpler.,CASSANDRA-193,I still think using XOR to combine MD5 for each row is simpler.,,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",16:2785 - 16:2847,2,arjan
2:155,"In MerkleTree.TreeRange.validateHelper(),  you can compute the hash di…",CASSANDRA-193,"In MerkleTree.TreeRange.validateHelper(),  you can compute the hash directly at each leaf node, instead of having to descend to  hashdepth.
",,Architectural component behavior and structure,16:2849 - 16:2989,1,arjan
2:257,jbellis,CASSANDRA-193,jbellis,,Comment,17:168 - 17:174,1,arjan
2:156,"We use IFoo as a convention for denoting interfaces, so naming a class…",CASSANDRA-193,"We use IFoo as a convention for denoting interfaces, so naming a class INode doesn’t  seem like a good idea to me.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",17:177 - 17:291,2,arjan
2:258,stuhood,CASSANDRA-193,stuhood,,Comment,17:297 - 17:303,1,arjan
2:157,"If I remember correctly, prepare() samples the SSTable indexes, which…",CASSANDRA-193,"If I remember correctly, prepare() samples the SSTable indexes, which are themselves sam-  ples of the data on disk, and which are already sitting in memory: at worst, it should only  create a new list, but not actually clone any keys.
",,Existing system architecture description,17:431 - 17:667,1,arjan
2:158,I really don’t think XORing row hashes together is a good idea. Any pe…,CASSANDRA-193,"I really don’t think XORing row hashes together is a good idea. Any permutation of the  same set of hashes can cause a collision, and when it is row hashes that are being XOR’d,  the chance of collision goes through the roof. Collisions in this context mean data won’t get  repaired, and will continue to not be repaired until someone writes to the afected range.
",,Architectural solution benefits and drawbacks,17:884 - 17:1248,1,arjan
2:259,junrao,CASSANDRA-193,junrao,,Comment,17:1947 - 17:1952,1,arjan
2:159,The new patch looks good to me,CASSANDRA-193,The new patch looks good to me,,Architectural solution benefits and drawbacks,17:1955 - 17:1984,1,arjan
2:160,"After CASSANDRA-193, the TreeRequest/Response conversation will have g…",CASSANDRA-193,"After CASSANDRA-193, the TreeRequest/Response conversation will have generated a full list of  Ranges that disagree between nodes.",,"Contextual constraints
Existing system architecture description",18:99 - 18:228,2,arjan
2:161,"We need an operation that can efciently batch repair the  ranges, simi…",CASSANDRA-193,"We need an operation that can efciently batch repair the  ranges, similar to what happens during read repair for a single key.
",,Architectural design configuration,18:230 - 18:357,1,arjan
2:260,stuhood,CASSANDRA-193,stuhood,,Comment,18:677 - 18:683,1,arjan
2:162,One straightforward way to implement the repair would be to perform a…,CASSANDRA-193,"One straightforward way to implement the repair would be to perform a range  read for each disagreeing range, and letting read repairs handle repairing individual keys.
This would require a command similar/identical to RangeCommand except that it would  use Tokens as the ’startWith’ and ’stopAt’ parameters.
",,Architectural component behavior and structure,18:686 - 18:996,1,arjan
2:261,stuhood,CASSANDRA-193,stuhood,,Comment,19:4 - 19:10,1,arjan
2:163,"Range queries don’t currently trigger read repairs,",CASSANDRA-193,"Range queries don’t currently trigger read repairs, ",,Existing system architecture description,19:13 - 19:64,1,arjan
2:164,but CASSANDRA-344 will  likely be changing that.,CASSANDRA-193,"but CASSANDRA-344 will  likely be changing that.
",,Existing system architecture description,19:65 - 19:113,1,arjan
2:262,stuhood,CASSANDRA-193,stuhood,,Comment,19:118 - 19:124,1,arjan
2:165,This patch changes RangeCommand to take a DecoratedKey for startWith a…,CASSANDRA-193, This patch changes RangeCommand to take a DecoratedKey for startWith and  stopAt. The idea is that a RangeCommand for a Token Range would provide DecoratedKeys  with null keys.,,Architectural component behavior and structure,19:126 - 19:302,1,arjan
2:166,"Along with 344, this allows for a naive implementation of range repair…",CASSANDRA-193,"Along with 344, this allows for a naive implementation of range repairs.",,Architectural solution benefits and drawbacks,19:304 - 19:375,1,arjan
2:263,stuhood,CASSANDRA-193,stuhood,,Comment,19:381 - 19:387,1,arjan
2:167,Here’s an implementation of the efcient bulk range repair (thanks to j…,CASSANDRA-193," Here’s an implementation of the efcient bulk range repair (thanks to jbellis’  cleanup of the Streaming API, the actual transfer only takes 10 lines!) but it depends on  #193.
",,"Architectural solution benefits and drawbacks
Existing system architecture description",19:389 - 19:566,2,arjan
2:264,stuhood,CASSANDRA-193,stuhood,,Comment,19:743 - 19:749,1,arjan
2:168,#344 doesn’t add read repair to range queries:,CASSANDRA-193,#344 doesn’t add read repair to range queries:,,Architectural component behavior and structure,19:752 - 19:797,1,arjan
2:169,but #568 hopefully will!,CASSANDRA-193,"but #568 hopefully will!
",,Architectural component behavior and structure,19:799 - 19:824,1,arjan
2:265,stuhood,CASSANDRA-193,stuhood,,Comment,19:828 - 19:834,1,arjan
2:170,"I’ve rebased these patches, and added selection of ’bulk’ or ’selectiv…",CASSANDRA-193,"I’ve rebased these patches, and added selection of ’bulk’ or ’selective’ (range com-  mand) style repair. They are completely disjoint, and should probably be merged separately:  ’520-bulk’ depends on the latest patchset from #193, but ’520-selective’ applies to trunk.
",,Existing system architecture description,19:837 - 19:1107,1,arjan
2:171,"I think 520-bulk is ready for merge, and since repair will still be a…",CASSANDRA-193,"I think 520-bulk is ready for merge, and since repair will still be a manual process in 0.5,  requiring an anti-compaction for repair seems reasonable.
",,"Architectural design configuration
Assumptions",19:1108 - 19:1260,2,arjan
2:266,stuhood,CASSANDRA-193,stuhood,,Comment,19:1791 - 19:1797,1,arjan
2:172,Triggering RangeCommand based repairs is a FIXME at AntiEntropyService…,CASSANDRA-193,"Triggering RangeCommand based repairs is a FIXME at AntiEntropyService:617, which  means that this patch won’t actually trigger repairs for diferences of less than 5% between  nodes.
",,Architectural component behavior and structure,19:1828 - 19:2011,1,arjan
2:173,Since we have a few performance/efciency tickets open (https://issues.…,CASSANDRA-193,"Since we have a few performance/efciency tickets open (https://issues.apache.org/jira/browse/CASSANDRA-  233, https://issues.apache.org/jira/browse/CASSANDRA-174), we should probably start using  some basic benchmark for regression.
",,Motivation of design issue,20:104 - 20:337,1,arjan
2:174,VPork’s an option.,CASSANDRA-193,VPork’s an option.,,Other system architectural solutions,20:338 - 20:355,1,arjan
2:267,johanoskarsson,CASSANDRA-193,johanoskarsson,,Comment,20:829 - 20:842,1,arjan
2:175,I quite like this idea.,CASSANDRA-193, I quite like this idea.,,Architectural solution benefits and drawbacks,20:844 - 20:867,1,arjan
2:176,I have in fact started working a bit in my spare time  on a tiny pytho…,CASSANDRA-193,"I have in fact started working a bit in my spare time  on a tiny python script that would bring up a couple of ec2 machines and deploy Cassandra.
19
Then it would start a client node that runs vpork against the cluster and then publish the  results.",,Architectural design configuration,20:869 - 21:100,1,arjan
2:268,stuhood,CASSANDRA-193,stuhood,,Comment,21:157 - 21:163,1,arjan
2:177,"Performance metrics are a great idea, but it will be pretty important…",CASSANDRA-193," Performance metrics are a great idea, but it will be pretty important to make the  coverage broad enough that we don’t focus optimizations in the wrong place. For instance,  performing VPork runs that do range queries, and other runs that fetch varying numbers of  column families.
",,Architectural solution benefits and drawbacks,21:165 - 21:448,1,arjan
2:178,"Also, you might want to consider the ability to fre up multiple client…",CASSANDRA-193,"Also, you might want to consider the ability to fre up multiple client machines as well,  because we know that in some cases Cassandra can saturate the network before breaking a  sweat.
",,Architectural design configuration,21:449 - 21:635,1,arjan
2:269,sandeep_tata,CASSANDRA-193,sandeep_tata,,Comment,21:699 - 21:710,1,arjan
2:179,Here’s a tool that loosely mimics the workload of one of the apps we h…,CASSANDRA-193," Here’s a tool that loosely mimics the workload of one of the apps we have  running.
1. The code is in Java should anyone choose to use a ""heavy client"" that knows where  to send a given request ... this typically cuts latency in half.
2. The workload consists of 2 phases --The frst is a load phase that does a whole bunch of  batch inserts.
The second phase is a mix of inserts (new data and replacement of old data), get_columns  and get_slices. There is also the option to do deletes that is turned of by default.
3. To keep things simple, only one column family is used, and no supercolumns are writ-  ten/read.
4. In the end, the total write bandwidth and a bunch of latency stats are reported. I pulled  in commons-math to get percentiles (median, 99th percentile latency numbers).
5. All the confguration parameters are specifed as in conf/workload.xml",,Other system architectural solutions,21:712 - 21:1577,1,arjan
2:180,I’ve found a simpler version of this this tool rather useful in the pa…,CASSANDRA-193,"I’ve found a simpler version of this this tool rather useful in the past in locating bugs  and now for testing performance.
",,Architectural solution benefits and drawbacks,21:1580 - 21:1704,1,arjan
2:181,Two tickets currently depend on being able to deterministically split…,CASSANDRA-193,"Two tickets currently depend on being able to deterministically split a Range object into two  ""even"" Ranges.",,Motivation of design issue,22:118 - 22:226,1,arjan
2:182,This can be accomplished with RandomPartitioner/BigIntegerToken by tak…,CASSANDRA-193,"This can be accomplished with RandomPartitioner/BigIntegerToken by taking the average of  the tokens, but the OrderPreservingPartitioner/StringToken implementation uses a Java Collator  to defne the sort order of Tokens, which means that they are not necessarily sorted in byte/char  order.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",22:229 - 22:520,2,arjan
2:183,Collator.getCollationKey(String).toByteArray() gets you a sortable byt…,CASSANDRA-193,"Collator.getCollationKey(String).toByteArray() gets you a sortable byte array, but there is no  publicly accessible API for converting a similar byte array back into a String.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",22:521 - 22:697,2,arjan
2:270,jbellis,CASSANDRA-193,jbellis,,Comment,23:51 - 23:57,1,arjan
2:184,"Back when we discussed this in IRC, I think we concluded that although…",CASSANDRA-193,"Back when we discussed this in IRC, I think we concluded that although there is no  way to split a Range, splitting a group of tokens and taking the median is almost as useful.",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",23:60 - 23:235,3,arjan
2:271,stuhood,CASSANDRA-193,stuhood,,Comment,23:241 - 23:247,1,arjan
2:185,"1. Add a BytewiseToken, which can still be compared to StringToken via…",CASSANDRA-193,"1. Add a BytewiseToken, which can still be compared to StringToken via a common in-  terface.",,Architectural component behavior and structure,23:291 - 23:383,1,arjan
2:186,We can fairly easily generate a byte array that falls halfway between…,CASSANDRA-193,"We can fairly easily generate a byte array that falls halfway between the Colla-  tionKey.toByteArray of two StringTokens, but we can’t make it back into a String without  understanding the JVM we are running in.
",,Architectural solution benefits and drawbacks,23:385 - 23:598,1,arjan
2:187,Remove the Collator from OPP entirely in favor of byte order and letti…,CASSANDRA-193,"Remove the Collator from OPP entirely in favor of byte order and letting someone who  values lexical sort implement it.
",,Architectural component behavior and structure,23:602 - 23:722,1,arjan
2:272,jbellis,CASSANDRA-193,jbellis,,Comment,23:744 - 23:750,1,arjan
2:188,I am fne with 2) as long as the range split method is part of Partitio…,CASSANDRA-193," I am fne with 2) as long as the range split method is part of Partitioner too so it’s  easily overridable in one place.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",23:752 - 23:873,2,arjan
2:273,stuhood,CASSANDRA-193,stuhood,,Comment,23:877 - 23:883,1,arjan
2:189,"After posting 1), I thought about it some more and realized it would b…",CASSANDRA-193," After posting 1), I thought about it some more and realized it would be a rela-  tively smooth change: I’m leaning toward that approach.
",,Architectural solution benefits and drawbacks,23:885 - 23:1023,1,arjan
2:190,"Rather than an interface, we could make StringToken an abstract class…",CASSANDRA-193,"Rather than an interface, we could make StringToken an abstract class with two concrete  classes: a ""CollatedStringToken"", holding only a byte[] representing the CollationKey of its  String and a RawStringToken, which holds a String and is equivalent to the current String-  Token. The StringTokens would be compared via an abstract getCollatedBytes() method.
Names subject to change, etc.
",,Architectural design configuration,23:1024 - 23:1415,1,arjan
2:274,stuhood,CASSANDRA-193,stuhood,,Comment,23:1419 - 23:1425,1,arjan
2:191,"This patch implements 1) via a ’Collatable’ abstract class, with Colla…",CASSANDRA-193,"This patch implements 1) via a ’Collatable’ abstract class, with Collatable.String  and Collatable.Bytes.",,Architectural component behavior and structure,23:1428 - 23:1532,1,arjan
2:192,The main wart is that a Collatable.Bytes object will throw a RuntimeEx…,CASSANDRA-193,"The main wart is that a Collatable.Bytes object will throw a RuntimeException if you  attempt to use it asString(), but it might still be a reasonable approach for plugging in a  Token that is never meant to be serialized or decorated.
",,Architectural solution benefits and drawbacks,23:1535 - 23:1771,1,arjan
2:193,A third option would be to 3) Add an explicit third state for Tokens:…,CASSANDRA-193,"A third option would be to 3) Add an explicit third state for Tokens: plain, decorated  and -binary-. Once a token is in a binary state, it cannot be converted back to plain or  decorated. The explicitness is key.
",,Architectural component behavior and structure,23:1772 - 23:1986,1,arjan
2:275,jbellis,CASSANDRA-193,jbellis,,Comment,23:1990 - 23:1996,1,arjan
2:194,It looks like the reasoning is  - we can’t just convert all Tokens to…,CASSANDRA-193,"It looks like the reasoning is  - we can’t just convert all Tokens to byte[] and average them to get a new midpoint Token,  because you are not guaranteed to be able to invert the averaged byte[] to a valid Token  - so let’s do all Token comparisons as byte[] and not try to do the inversion",,"Assumptions
Motivation of design issue",23:2061 - 23:2351,2,arjan
2:195,But this means the only comparator you can use is the byte-order one.…,CASSANDRA-193,"But this means the only comparator you can use is the byte-order one. You can’t do Range  comparisons with byte order, and then sort keys with the ""real"" comparator. Bootstrap and  cross-node range queries both rely on using the same comparator with Tokens as with keys.
",,Architectural solution benefits and drawbacks,23:2354 - 23:2625,1,arjan
2:196,That is why IMO the split code should just be left up to the Partition…,CASSANDRA-193,"That is why IMO the split code should just be left up to the Partitioner.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",23:2626 - 23:2700,2,arjan
2:276,stuhood,CASSANDRA-193,stuhood,,Comment,24:4 - 24:10,1,arjan
2:197,The byte[] returned by getCollatedBytes are equivalent to those return…,CASSANDRA-193,"The byte[] returned by getCollatedBytes are equivalent to those returned by Collator.getCollationKey(string).toByte  which makes comparing that byte[] to another byte[] generated by the same method the same  as calling Collator.compare(string1, string2).
",,Architectural component behavior and structure,24:86 - 24:341,1,arjan
2:198,"The byte[] comparison is the new ""real"" comparator, because it provide…",CASSANDRA-193,"The byte[] comparison is the new ""real"" comparator, because it provides the same function-  ality that the older one did.
",,Architectural component behavior and structure,24:441 - 24:563,1,arjan
2:199,"The split code hasn’t been implemented yet, but it will defnitely be a…",CASSANDRA-193,"The split code hasn’t been implemented yet, but it will defnitely be added to the parti-  tioner: a way to compare a byte[] with no (real) string representation to a String is one of  the prerequisites (unless this looks too ugly, and 3) looks better).
",,"Architectural design configuration
User requirement",24:641 - 24:894,2,arjan
2:277,jbellis,CASSANDRA-193,jbellis,,Comment,24:898 - 24:904,1,arjan
2:200,"I think we have too many layers of abstraction still, but the approach…",CASSANDRA-193,"I think we have too many layers of abstraction still, but the approach is reasonable.
",,Architectural solution benefits and drawbacks,24:1068 - 24:1153,1,arjan
2:201,"Also, the collationkey docs imply that there is no need to convert the…",CASSANDRA-193,"Also, the collationkey docs imply that there is no need to convert the bytes to ints be-  fore comparison.",,Architectural design configuration,24:1156 - 24:1261,1,arjan
2:278,stuhood,CASSANDRA-193,stuhood,,Comment,24:1268 - 24:1274,1,arjan
2:202,"Alright, here is a new version of the patch that removes the layer of…",CASSANDRA-193," Alright, here is a new version of the patch that removes the layer of indirection  that was in the previous patch.
CollatingOrderPreservingPartitioner now uses a BytesToken to explicitly indicate that the  token isn’t supposed to be human readable.
",,Architectural design configuration,24:1276 - 24:1527,1,arjan
2:203,"I think we need to get this merged before 0.4 goes out, since it makes…",CASSANDRA-193,"I think we need to get this merged before 0.4 goes out, since it makes a funda-  mental change to COPP.
",,"Assumptions
Contextual constraints",24:1538 - 24:1642,2,arjan
2:279,stuhood,CASSANDRA-193,stuhood,,Comment,24:1647 - 24:1653,1,arjan
2:204,The previous patch didn’t test the case where a BytesToken wasn’t enco…,CASSANDRA-193,"The previous patch didn’t test the case where a BytesToken wasn’t encodable as  UTF-8, which would have broken.",,Run-time quality issues,24:1656 - 24:1766,1,arjan
2:205,"In this version, COPP.TokenFactory encodes Tokens as  hex when they ne…",CASSANDRA-193,"In this version, COPP.TokenFactory encodes Tokens as  hex when they need to be displayed as Strings (which isn’t often: when someone manually  confgures their initialToken or updates the token for a node).
",,Existing system architecture description,24:1768 - 24:1974,1,arjan
2:280,jbellis,CASSANDRA-193,jbellis,,Comment,24:2080 - 24:2086,1,arjan
2:206,This fts my brain much better when I think of the collationkey as the…,CASSANDRA-193,"This fts my brain much better when I think of the collationkey as the key decora-  tion like the bigint from RP, btw.",,Architectural solution benefits and drawbacks,24:2089 - 24:2205,1,arjan
2:207,and actually treating it that way could probably improve performance o…,CASSANDRA-193,"and actually treating it that way could probably improve performance on memtable fush,  where we do a ton of compares to sort the keys",,Architectural tactics,24:2209 - 24:2342,1,arjan
2:208,"moving to (token, key) instead of String decoratedkey is sounding bett…",CASSANDRA-193,"moving to (token, key) instead of String decoratedkey is sounding better and better to  me",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",24:2347 - 24:2436,2,arjan
2:209,"for one it is clear from static typing that String != (Token, String)…",CASSANDRA-193,"for one it is clear from static typing that String != (Token, String) which you have to  be really careful with in the current codebase.",,Technical debt,24:2439 - 24:2574,1,arjan
2:281,jbellis,CASSANDRA-193,jbellis,,Comment,24:2581 - 24:2587,1,arjan
2:210,"as painful as breaking disk compatibility for the token, key serializa…",CASSANDRA-193," as painful as breaking disk compatibility for the token, key serialization would be,  I kinda think postponing 0.4 for this would be even more painful. 0.3 needs to die, and we  need something stable to kill it with.",,"Assumptions
Trade-offs",24:2589 - 24:2805,2,arjan
2:282,stuhood,CASSANDRA-193,stuhood,,Comment,25:5 - 25:11,1,arjan
2:211,I don’t think we need to break disk compatibility in order to get this…,CASSANDRA-193,"I don’t think we need to break disk compatibility in order to get this merged:  we would only need to break disk compatibility to replace decoratedKeys with the (token,  key) tuple. This patch (the midpoint method itself and the change to COPP) will need to  happen either way, and isn’t blocked by the disk format change.
",,"Architectural design configuration
Assumptions",25:14 - 25:337,2,arjan
2:212,"In order for the midpoint method to be useful for CASSANDRA-342, we ju…",CASSANDRA-193,"In order for the midpoint method to be useful for CASSANDRA-342, we just need to im-  plement a RangeCommand which takes Tokens, which can be accomplished (sloppily, with  a comparator to compare decoratedKeys and Tokens).
",,Architectural design configuration,25:338 - 25:561,1,arjan
2:213,The SSTable tuple/index change would make that RangeCommand more efcie…,CASSANDRA-193,"The SSTable tuple/index change would make that RangeCommand more efcient, and as  you mentioned, will defnitely speed up sorting, because sorting of the tuples can ignore the  String comparison of the Key itself unless the Tokens are equal.",,"Architectural design configuration
Architectural tactics",25:562 - 25:801,2,arjan
2:283,jbellis,CASSANDRA-193,jbellis,,Comment,26:65 - 26:71,1,arjan
2:214,let’s use an annotation instead of special interface to indicate order…,CASSANDRA-193, let’s use an annotation instead of special interface to indicate order-preserving-  ness,,Architectural design configuration,26:143 - 26:231,1,arjan
2:284,jbellis,CASSANDRA-193,jbellis,,Comment,26:326 - 26:332,1,arjan
2:215,Or even simpler just have a boolean isOrdered method in IPartitioner.,CASSANDRA-193,Or even simpler just have a boolean isOrdered method in IPartitioner.,,Architectural component behavior and structure,26:436 - 26:504,1,arjan
2:285,stuhood,CASSANDRA-193,stuhood,,Comment,26:511 - 26:517,1,arjan
2:216,"The latest versions should get all of the coding style fxes, and inclu…",CASSANDRA-193," The latest versions should get all of the coding style fxes, and include a boolean  preservesOrder fag for IPartitioners.
",,Architectural component behavior and structure,26:519 - 26:641,1,arjan
3:1,"Allow a ColumnFamily to be versioned via vector clocks, instead of lon…",CASSANDRA-580,"Allow a ColumnFamily to be versioned via vector clocks, instead of long timestamps. Purpose:  enable incr/decr; fexible confict resolution.
",,Motivation of design issue,3:90 - 3:229,1,arjan
3:71,mateuszb,CASSANDRA-580,mateuszb,,Comment,3:562 - 3:569,1,arjan
3:2,you probably want this: http://en.wikipedia.org/wiki/Version_vector,CASSANDRA-580,you probably want this: http://en.wikipedia.org/wiki/Version_vector,,Other system architectural solutions,3:572 - 3:638,1,arjan
3:3,instead of : http://en.wikipedia.org/wiki/Vector_clock,CASSANDRA-580,instead of : http://en.wikipedia.org/wiki/Vector_clock,,Other system architectural solutions,3:641 - 3:694,1,arjan
3:72,kelvin,CASSANDRA-580,kelvin,,Comment,3:743 - 3:748,1,arjan
3:4,I believe you are right that we want the version vector variant.,CASSANDRA-580," I believe you are right that we want the version vector variant.
",,"Architectural solution benefits and drawbacks
Other system architectural solutions",3:766 - 3:832,2,arjan
3:73,stuhood,CASSANDRA-580,stuhood,,Comment,4:4 - 4:10,1,arjan
3:5,One important diference between Cassandra and some other systems utili…,CASSANDRA-580,"One important diference between Cassandra and some other systems utilizing  vector clocks is that in Cassandra, writes do not read from disk any old versions of the value  that is being written to. This means that confict resolution currently happens in 3 diferent  places:  1. At read time - Two nodes have diferent versions,  2. At write time - The version being written is older than the version a node has in a  Memtable,  3. At compaction time - Versions of values persisted to diferent SSTables disagree.
",,Existing system architecture description,4:13 - 4:524,1,arjan
3:6,"For the purposes of this ticket, I think that all resolution should be…",CASSANDRA-580,"For the purposes of this ticket, I think that all resolution should be handled server  side, deterministically, and that one of the following options should be implemented as part  of a separate ticket.
But before too much progress is made, we will probably want to decide whether we want to  support:  a) Client side confict resolution (logic implemented on the client side),  b) Server side resolution (pluggable logic on the server),  c) A hybrid (pluggable resolution, which can optionally sends the versions to the client at  resolution time #1 or #2)  If we decide to implement client-side resolution (a), then we will need to remove resolu-  tion at steps #2 and #3 (or make it optional for option (c)), and keep more copies of the  data. For #2, a Memtable could store conficting versions in memory until they are resolved  by a read or fushed to disk. For #3, SSTables will need to be able to store multiple versions  of a row/cf until they are resolved by a read.
",,Architectural design configuration,4:529 - 4:1504,1,arjan
3:74,kelvin,CASSANDRA-580,kelvin,,Comment,4:1508 - 4:1513,1,arjan
3:7,"Right now, I’m leaning towards client-side confict resolution. Basical…",CASSANDRA-580,"Right now, I’m leaning towards client-side confict resolution.
Basically, all updates are written out and confict resolution is handled at read time. An  exception being a version in the Memtable that can be resolved syntactically. However, it  would require more copies of the data and a more complex API. It would make the storage  system more fexible for end users, though, since they wouldn’t have to write server-side  logic. However, they would have to parse a list of conficting versions and pass back a con-  text/summary version vector of the merged confict.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",4:1516 - 4:2085,2,arjan
3:8,"My reasoning is that Cassandra is write-optimized, so we should shift…",CASSANDRA-580,"My reasoning is that Cassandra is write-optimized, so we should shift the burden to reads  rather than writes.",,"Architectural design configuration
Architectural solution benefits and drawbacks",4:2086 - 4:2195,2,arjan
3:75,jbellis,CASSANDRA-580,jbellis,,Comment,4:2201 - 4:2207,1,arjan
3:9,"As Stu points out, if the client has to resolve writes, you can no lon…",CASSANDRA-580,"As Stu points out, if the client has to resolve writes, you can no longer compact  without involving the client. This is a big big lose.",,"Architectural design configuration
Architectural solution benefits and drawbacks",4:2210 - 4:2345,2,arjan
3:10,+1 pluggable server-side confict resolu-  tion from me.,CASSANDRA-580,"+1 pluggable server-side confict resolu-  tion from me.
",,Quality Attribute requirement,4:2347 - 4:2403,1,arjan
3:11,This doesn’t have to be complicated;,CASSANDRA-580,This doesn’t have to be complicated;,,Architectural solution benefits and drawbacks,4:2405 - 4:2440,1,arjan
3:12,just allow a class name to be specifed per-CF like we  do for CompareW…,CASSANDRA-580,just allow a class name to be specifed per-CF like we  do for CompareWith.,,Existing system architecture description,4:2442 - 4:2515,1,arjan
3:13,"Also, I think you can make a good case that this is a better stylistic…",CASSANDRA-580,"Also, I think you can make a good case that this is a better stylistic ft for Cassandra,  which tries to support ""dumb"" clients more than Dynamo did.
",,"Architectural solution benefits and drawbacks
Assumptions",4:2519 - 4:2668,2,arjan
3:76,stuhood,CASSANDRA-580,stuhood,,Comment,4:2874 - 4:2880,1,arjan
3:14,"Kindof: you can still compact SSTables, but you need to keep all confi…",CASSANDRA-580,"Kindof: you can still compact SSTables, but you need to keep all conficting versions, which  is why options (a) and (c) are still feasible.
",,Architectural solution benefits and drawbacks,5:1 - 5:141,1,arjan
3:77,jbellis,CASSANDRA-580,jbellis,,Comment,5:145 - 5:151,1,arjan
3:15,"Yes, that’s how you’d have to change it. I’d rather not; it would get…",CASSANDRA-580,"Yes, that’s how you’d have to change it. I’d rather not; it would get messy.
",,Architectural solution benefits and drawbacks,5:154 - 5:231,1,arjan
3:16,If we do server-side resolution we could still conceivably support bot…,CASSANDRA-580,"If we do server-side resolution we could still conceivably support both ""classic"" columnfam-  ilies and vector clocked ones in the same Column and SuperColumn objects, just difering  in their clock/timestamp feld. ",,Architectural design configuration,5:233 - 5:446,1,arjan
3:17,But if we have to potentially store multiple versions of a  column in…,CASSANDRA-580,"But if we have to potentially store multiple versions of a  column in a single row for the vector clock version, then I think that is diverging too far and  we’d have to split the implementation. Remember that a classic ColumnFamily object just  has a hash of its columns by name.",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",5:447 - 5:726,3,arjan
3:78,kelvin,CASSANDRA-580,kelvin,,Comment,5:733 - 5:738,1,arjan
3:18,The vector clock is returned by gets and required for insert/remove. I…,CASSANDRA-580,"The vector clock is returned by gets and required for insert/remove. I assume that server-  side confict resolution will be implemented, so I only pass back the defnitive version of  the row. ",,"Assumptions
Existing system architecture description",5:774 - 5:965,2,arjan
3:19,"If client-side confict resolution will be implemented in the future, a…",CASSANDRA-580,"If client-side confict resolution will be implemented in the future, another data  structure will be needed that encapsulates a list of conficts and, maybe, a summary vector  clock to be used for an insert/remove operation that resolves the confict.
",,Architectural design configuration,5:966 - 5:1216,1,arjan
3:79,jbellis,CASSANDRA-580,jbellis,,Comment,5:1291 - 5:1297,1,arjan
3:20,The reason I switched to favoring server-side-only is because it lets…,CASSANDRA-580,"The reason I switched to favoring server-side-only is because it lets us get by with  much smaller API changes, as in the attached.
",,Architectural solution benefits and drawbacks,5:1300 - 5:1432,1,arjan
3:21,"Also, why do we need a timestamp in LogicalClock when we have the coun…",CASSANDRA-580,"Also, why do we need a timestamp in LogicalClock when we have the counter? I thought  the whole point was to get away from the problems posed by timestamps.
",,"Architectural solution benefits and drawbacks
Assumptions
Existing system architecture description",5:1433 - 5:1590,3,arjan
3:80,kelvin,CASSANDRA-580,kelvin,,Comment,5:1595 - 5:1600,1,arjan
3:22,"Ah, I see what you were going after. That’s a more concise interface c…",CASSANDRA-580,"Ah, I see what you were going after. That’s a more concise interface change.
",,Architectural solution benefits and drawbacks,5:1603 - 5:1680,1,arjan
3:23,My understanding about including a timestamp along w/ the logical cloc…,CASSANDRA-580,"My understanding about including a timestamp along w/ the logical clock is to limit the  potential growth of the vector. Basically, whenever a new node updates a value, the vector  size grows by one. However, the problem is that if many diferent nodes happen to update a  given value (for various reasons--failure scenarios, etc.), the potential size of a vector could  grow to an unmanageable length and it would keep that length forever.",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:1681 - 5:2119,2,arjan
3:24,"So, the Dynamo  authors chose to tag each update with a timestamp, so…",CASSANDRA-580,"So, the Dynamo  authors chose to tag each update with a timestamp, so they could truncate the vector to  only the last 10 nodes to update the value. There is a possibility that an inconsistency could  arise, because of the truncation. However, the paper said in practice, it was a non-issue.
",,"Architectural solution benefits and drawbacks
Other system architectural solutions",5:2121 - 5:2413,2,arjan
3:25,"In summary, the timestamp is not there to help resolve consistency pro…",CASSANDRA-580,"In summary, the timestamp is not there to help resolve consistency problems, it’s there  to make the vector more manageable.
",,Architectural solution benefits and drawbacks,5:2414 - 5:2539,1,arjan
3:81,jbellis,CASSANDRA-580,jbellis,,Comment,5:2584 - 5:2590,1,arjan
3:26,but shouldn’t that timestamp be internal to the server? we defnitely d…,CASSANDRA-580,"but shouldn’t that timestamp be internal to the server? we defnitely don’t want  the client to specify what amounts to an implementation detail, and i don’t think there is  any reason to send it to the client on a read, either.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:2597 - 5:2825,2,arjan
3:82,kelvin,CASSANDRA-580,kelvin,,Comment,5:2830 - 5:2835,1,arjan
3:27,I think you’re right about the timestamps not necessarily being useful…,CASSANDRA-580,"I think you’re right about the timestamps not necessarily being useful to a client.
It shouldn’t be part of the interface, since it’s really an implementation detail to manage the  size of the vector. I’ll make it internal to the server.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:2838 - 5:3077,2,arjan
3:83,stuhood,CASSANDRA-580,stuhood,,Comment,5:3082 - 5:3088,1,arjan
3:28,Regarding the timestamp being necessary in a version vector: have you…,CASSANDRA-580,"Regarding the timestamp being necessary in a version vector: have you looked  at Interval Tree Clocks? The paper is slightly over my head, but the algorithm is supposed  to be a generalization of version vectors / vector clocks, and it has a natural solution for  changing members: http://en.wikipedia.org/wiki/Version_vector#cite_note-5",,"Architectural solution benefits and drawbacks
Other system architectural solutions",5:3091 - 5:3427,2,arjan
3:84,kelvin,CASSANDRA-580,kelvin,,Comment,6:5 - 6:10,1,arjan
3:29,I studied the Interval Tree Clocks paper and it looks promising.,CASSANDRA-580,I studied the Interval Tree Clocks paper and it looks promising. ,,Architectural solution benefits and drawbacks,6:39 - 6:103,1,arjan
3:30,"Having said the above, I think we should re-do the ""clock"" aspect of t…",CASSANDRA-580,"Having said the above, I think we should re-do the ""clock"" aspect of the interface and make  it an opaque context object (like Dynamo). We pass it out to clients on a read, and when  they update a given value they pass back the context that they’re updating. I’m not sure if  we want to extend the concept so far as to make existing timestamps just a special case of  an opaque context, though.",,"Assumptions
Other system architectural solutions",6:197 - 6:590,2,arjan
3:85,jbellis,CASSANDRA-580,jbellis,,Comment,6:597 - 6:603,1,arjan
3:31,making it a byte[] context makes sense.,CASSANDRA-580,making it a byte[] context makes sense.,,"Architectural design configuration
Architectural solution benefits and drawbacks",6:606 - 6:644,2,arjan
3:32,"replacing the existing timestamps with that does not, since they are c…",CASSANDRA-580,"replacing the existing timestamps with that does not, since they are client-provided by  design which is the opposite of the VC context.
",,Architectural design configuration,6:647 - 6:784,1,arjan
3:86,kelvin,CASSANDRA-580,kelvin,,Comment,6:789 - 6:794,1,arjan
3:33,modifed interface to use opaque context for versioning,CASSANDRA-580,modifed interface to use opaque context for versioning,,Existing system architecture description,6:797 - 6:850,1,arjan
3:87,kelvin,CASSANDRA-580,kelvin,,Comment,6:966 - 6:971,1,arjan
3:34,The crux of the matter is Cassandra’s hinted hand-of feature. The ITC…,CASSANDRA-580,"The crux of the matter is Cassandra’s hinted hand-of feature. The ITC algorithm com-  poses an id-tree and event-tree to represent the version of a given value. The id-tree is a  nice way to create unique ids on-the-fy for any node (by splitting the id-tree, as necessary)  and the event-tree represents causality.",,Architectural design configuration,6:1163 - 6:1476,1,arjan
3:35,"However, the problem is that for a node to update  the event-tree for…",CASSANDRA-580,"However, the problem is that for a node to update  the event-tree for a value, it has to be assigned a part of the id-tree beforehand.",,Motivation of design issue,6:1478 - 6:1611,1,arjan
3:36,"A short example, follows:  If a node tries to forward a value, but (be…",CASSANDRA-580,"A short example, follows:  If a node tries to forward a value, but (because of failure scenarios) it has to store the value,  locally. It wouldn’t be able to update the version of the value, unless it had been assigned  a part of the id-tree beforehand from the set of nodes responsible for the value.
",,Motivation of design issue,6:1614 - 6:1916,1,arjan
3:37,The authors have a couple of solutions:  1) Split the id-tree between…,CASSANDRA-580,"The authors have a couple of solutions:  1) Split the id-tree between all nodes in the cluster from the very start. This solves the  problem, but it does mute the attractive benefts of ITC over traditional version vectors.
i.e. dynamically partitioning the id space at run-time and only to the extent necessary to  conserve space.
2) On client reads, doing a ""fork"" instead of a ""peek"" and sharing the id-tree w/ the client.
However, this is a more complicated approach that may need to be worked out some more.
",,Trade-offs,6:1917 - 6:2432,1,arjan
3:38,"In any case, since we’re using an opaque context, these decisions won’…",CASSANDRA-580,"In any case, since we’re using an opaque context, these decisions won’t afect the inter-  face. However, it’s an interesting implementation concern.",,Architectural solution benefits and drawbacks,6:2433 - 6:2580,1,arjan
3:39,"Depending on the average size  of a Cassandra cluster, it may or may n…",CASSANDRA-580,"Depending on the average size  of a Cassandra cluster, it may or may not be worth pre-forking the id-tree to all nodes from  the very start.",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",6:2582 - 6:2721,3,arjan
3:88,jbellis,CASSANDRA-580,jbellis,,Comment,6:2728 - 6:2734,1,arjan
3:40,If it’s going to be complex -- and it sounds like it is :) -- I’d be i…,CASSANDRA-580,"If it’s going to be complex -- and it sounds like it is :) -- I’d be inclined to prefer  the ""timestamped vector clock, with truncation"" approach. (And since it’s opaque to the  client this can be changed later if we determine that the truncation actually is a problem in  practice.)",,Architectural solution benefits and drawbacks,6:2737 - 6:3019,1,arjan
3:89,kelvin,CASSANDRA-580,kelvin,,Comment,7:5 - 7:10,1,arjan
3:41,"Honestly, I’m starting to lean that way, as well.",CASSANDRA-580,"Honestly, I’m starting to lean that way, as well.",,Architectural solution benefits and drawbacks,7:13 - 7:61,1,arjan
3:42,"If anything, we can make it a  confguration setting, in the future.",CASSANDRA-580,"If anything, we can make it a  confguration setting, in the future.
",,Architectural design configuration,7:63 - 7:131,1,arjan
3:90,kelvin,CASSANDRA-580,kelvin,,Comment,7:1988 - 7:1993,1,arjan
3:43,"When I use the terms superset/subset/disjoint, I really mean: dom-  in…",CASSANDRA-580,"When I use the terms superset/subset/disjoint, I really mean: dom-  inates, dominated, neither dominated nor dominates. However, it’s easier for me to read the  code w/ standard set terms.
",,Architectural solution benefits and drawbacks,7:2010 - 7:2199,1,arjan
3:91,kelvin,CASSANDRA-580,kelvin,,Comment,7:2204 - 7:2209,1,arjan
3:44,"If Cassandra supports IPv6, then it might be advantageous to just use…",CASSANDRA-580,"If Cassandra supports IPv6, then it might be advantageous to just use the IPv4 portion of  it. If that’s possible. Otherwise, IPv6’s 16 bytes is kind of rough.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",7:2237 - 7:2397,2,arjan
3:92,kelvin,CASSANDRA-580,kelvin,,Comment,8:5 - 8:10,1,arjan
3:45,potential incompatibility w/ IColumn and IColumnContainer interfaces.…,CASSANDRA-580," potential incompatibility w/ IColumn and IColumnContainer interfaces.
The key issue is that Column and SuperColumn rely on timestamps to indicate when dele-  tion should occur. In particular, through these methods:  getMarkedForDeleteAt()  mostRecentLiveChangeAt()  A separate, less interesting, issue is that SuperColumn auto-assumes Column for its sub-  column serializer.
",,Motivation of design issue,8:12 - 8:389,1,arjan
3:46,"Right now, I’ve put together a new class, VersionColumn, that’s contex…",CASSANDRA-580,"Right now, I’ve put together a new class, VersionColumn, that’s context-based. I’ve added  context() methods to IColumn and added some instanceof checks",,Existing system architecture description,8:390 - 8:541,1,arjan
3:47,"atm, I’m trying to avoid having to add a SuperVersionColumn class",CASSANDRA-580,"atm, I’m trying to avoid having to add a SuperVersionColumn class",,Architectural solution benefits and drawbacks,8:618 - 8:682,1,arjan
3:48,An aggregated con-  text of all the sub-columns may be worth exploring…,CASSANDRA-580,An aggregated con-  text of all the sub-columns may be worth exploring.,,Architectural solution benefits and drawbacks,8:771 - 8:841,1,arjan
3:49,"Alternatively, since all the updates are  timestamped, we could use th…",CASSANDRA-580,"Alternatively, since all the updates are  timestamped, we could use that as a rough approximation for mostRecentLiveChangeAt(),  but that seems to break the spirit of versioned contexts",,"Architectural design configuration
Architectural solution benefits and drawbacks",8:843 - 8:1027,2,arjan
3:93,jaakko,CASSANDRA-580,jaakko,,Comment,8:1104 - 8:1109,1,arjan
3:50,Utility methods should be put to FBUtilities,CASSANDRA-580,Utility methods should be put to FBUtilities,,Technical debt,8:1171 - 8:1214,1,arjan
3:51,compareByteSubArrays seems to have following issues: (a) it does not h…,CASSANDRA-580, compareByteSubArrays seems to have following issues: (a) it does not handle the case  where bytes2 is null and bytes1 is non-null (b) it does not handle the case where parameter  ’length’ is bigger than byte array length,,Run-time quality issues,8:1220 - 8:1440,1,arjan
3:52,bytes are copied in manual for loops. Is there a reason for not using…,CASSANDRA-580,"bytes are copied in manual for loops. Is there a reason for not using arraycopy? It would  perhaps make the code slightly cleaner and faster (don’t know about the latter though, as  this involves copying elements within the same array)",,Architectural tactics,8:1447 - 8:1681,1,arjan
3:53,Would it make sense to use some level of data abstraction? Sorting and…,CASSANDRA-580,"Would it make sense to use some level of data abstraction? Sorting and comparisons  always involve copying & handling of individual bytes, which makes the code slightly cum-  bersome to read, and might be more inefcient than using object references as well (again,  not sure about this, have to do some research).
",,"Architectural tactics
Assumptions",8:1688 - 8:2002,2,arjan
3:94,kelvin,CASSANDRA-580,kelvin,,Comment,8:2007 - 8:2012,1,arjan
3:54,You’re right about cBSA,CASSANDRA-580,You’re right about cBSA,,Architectural solution benefits and drawbacks,8:2177 - 8:2199,1,arjan
3:55,Thanks for the heads up. I’ll look into replacing those loops w/ array…,CASSANDRA-580,"Thanks for the heads up. I’ll look into replacing those loops w/ arraycopy.
",,Architectural solution benefits and drawbacks,8:2346 - 8:2422,1,arjan
3:56,"My goal is to keep the context an opaque array, because I want to be s…",CASSANDRA-580," My goal is to keep the context an opaque array, because I want to be support other  version implementations. i.e. interval tree clocks, which have a diferent format. So, if I  wanted to use an object representation, VVC would have to internally infate the opaque  context. However, the manual byte manipulation isn’t as easy to read as an object-based  implementation and this was a concern of mine.
",,Trade-offs,8:2426 - 8:2827,1,arjan
3:57,"Right now, for the reconcile() method, I’m probably going to modify it…",CASSANDRA-580,"Right now, for the reconcile() method, I’m probably going to modify its interface. Instead of  using a List of Pair objects, I have a new IColumn impl, VectorColumn, that would probably  be more appropriate than Pair.
",,Technical debt,8:2828 - 8:3046,1,arjan
3:95,jbellis,CASSANDRA-580,jbellis,,Comment,9:5 - 9:11,1,arjan
3:58,It’s okay to have helper methods that are only used in one class local…,CASSANDRA-580,"It’s okay to have helper methods that are only used in one class local to that class,  but in that case they should be private.",,Architectural design configuration,9:15 - 9:141,1,arjan
3:96,kelvin,CASSANDRA-580,kelvin,,Comment,9:149 - 9:154,1,arjan
3:59,"np, I’ll clean up the API. i.e. make internal methods private and move…",CASSANDRA-580,"np, I’ll clean up the API. i.e. make internal methods private and move public  methods to FBUtilities.
",,Architectural design configuration,9:157 - 9:260,1,arjan
3:97,pedrog,CASSANDRA-580,pedrog,,Comment,9:265 - 9:270,1,arjan
3:61,I suppose for the beginning of the discussion that some sort of interf…,CASSANDRA-580,"I suppose for the beginning of the discussion that some sort of interface will be implemented  to allow pluggable logic to be added to the server, personalized scripts were an idea, I have  heard.
",,"Architectural design configuration
Assumptions",9:381 - 9:578,2,arjan
3:60,"As a suggestion, Java Scripting API and scripts stored on Cas-  sandra…",CASSANDRA-580,"As a suggestion, Java Scripting API and scripts stored on Cas-  sandra?
",,Architectural design configuration,9:601 - 9:673,1,arjan
3:98,kelvin,CASSANDRA-580,kelvin,,Comment,9:904 - 9:909,1,arjan
3:62,"For the initial server-side reconciliation, we’ll probably adopt an ap…",CASSANDRA-580,"For the initial server-side reconciliation, we’ll probably adopt an approach similar  to the way custom ColumnFamily comparators are specifed.
",,Architectural design configuration,9:912 - 9:1055,1,arjan
3:63,"For the initial implementation to get this out the door, we won’t supp…",CASSANDRA-580,"For the initial implementation to get this out the door, we won’t support a javascript API.
",,Architectural design configuration,9:1350 - 9:1442,1,arjan
3:64,It probably would be nice to support a high-level scripting  language…,CASSANDRA-580,"It probably would be nice to support a high-level scripting  language for certain components.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",9:1477 - 9:1570,2,arjan
3:99,kelvin,CASSANDRA-580,kelvin,,Comment,9:1576 - 9:1581,1,arjan
3:65,Moved utility methods in VersionVectorContext to FBUtilities. Modifed…,CASSANDRA-580,"Moved utility methods in VersionVectorContext to FBUtilities.
Modifed impl to use System.arraycopy().
Modifed internal methods to be protected/private (depending on whether necessary for test-  ing).
Removed now unused methods.
Note: FBUtilities.compareByteSubArrays() will throw an IllegalArgumentException if a  length is passed in that extends past either array.
",,Existing system architecture description,9:1584 - 9:1954,1,arjan
3:100,kelvin,CASSANDRA-580,kelvin,,Comment,11:499 - 11:504,1,arjan
3:66,"1) modify version vector node ids to use a unique, per-connection id (…",CASSANDRA-580,"1) modify version vector node ids to use a unique, per-connection id (thanks Clif Moon and  Andy Gross for pointing this out as an improvement)  - note: see Riak’s implementation, which derives unique client ids based on erlang process  id.
pros: less replica coordination wrt node ids.
necessary evil: must add timestamps to version vector tuples and prune the version vector  (based on time).
2) modify tuple format  - add timestamp (to allow version vector pruning)  - shorten count type to be int, instead of long (node ids will updated for a much shorter  period of time)",,Run-time quality issues,11:587 - 11:1165,1,arjan
3:101,slebresne,CASSANDRA-580,slebresne,,Comment,12:929 - 12:937,1,arjan
3:67,I believe the attached patch (580-version-vector-wip.patch) has a prob…,CASSANDRA-580," I believe the attached patch (580-version-vector-wip.patch) has a problem. At  CL.ZERO and CL.ONE, it doesn’t replicate writes (the ones using version  vectors) at all (SP.updateDestinationByClock() clears the destinationEndpoints  but still returns an empty collection). This is (overly) unsafe.
",,Run-time quality issues,12:939 - 12:1237,1,arjan
3:68,This certainly could be fxed by adding new WriteResponseHandler for th…,CASSANDRA-580,This certainly could be fxed by adding new WriteResponseHandler for those  cases.,,Architectural component behavior and structure,12:1238 - 12:1318,1,arjan
3:69,But I believe that there is a *much* better alternative. This alternat…,CASSANDRA-580," But I believe that there is a *much* better alternative.
This alternative consists in changing the write protocol (for version vector  only of course) to do the following (and note that the protocol of the current  patch is already diferent of the one for timestamps):  # a node receive a write request (with version vector clock) from a client.
If it’s a replica for the write, goto 3) otherwise goto 2)  # the node delegate the write to one replica (along with the asked CL) and  then only wait for a ack of this replica before answering the client (it  doesn’t replicate anything)  # the chosen replica apply the mutation locally frst (we must do it before  replication)  # then it send the mutation to other replicates, waiting for how many  responses are necessary to achieve asked consistency  To make this more concrete, I’m attaching a patch (0001-Add-handler-to-delegate-the-write-  protocol-to-a-repl.patch)  that implements this protocol (it all starts in SP.delegateMutateBlocking()).
Small disclaimers: this should work but is not really tested (so please be  nice :)). The function RowMutation.updateBeforeReplication() could safely be  ignored on a frst read but it would be needed if #1072 was to use this. It  could also probably be slightly optimized by allowing the  DelegatedRowMutationVerbHandler to handle multiple mutations at once. This is  also just the protocol mentioned above, #580 would have to be rebased on top  11
of this.
",,Architectural design configuration,12:1319 - 13:10,1,arjan
3:70,"Anyway, I think this alternative is superior to the one used by the cu…",CASSANDRA-580,"Anyway, I think this alternative is superior to the one used by the currently  attached #580 patch for the following reasons:  * the protocol used by the current patch (write to one replica, wait for the  ack and then replicate to others, which difers from what I propose in  that this is done from a potentially non replica node), doesn’t work for  #1072 (because of potential race condition with the read repairs). The  protocol I’m proposing does not sufer of this problem and (I’m quite  convinced, let’s hope I’m not wrong) would reconciliate #1072 with the EC  model of Cassandra. This is obviously the more important point.
* it is slightly faster (network-latency-wise), as we don’t wait for a full  round-trip to a node before starting the replication.
* it more cleanly separate the protocols of timestamped writes and versionned  ones (without much code duplication really). I suppose this is more a  matter of opinion whether this is better or not, but at the very least it  make it clearer that version vectors don’t slow down nor break the other  writes.
",,Architectural solution benefits and drawbacks,13:11 - 13:1082,1,arjan
4:1,Secondary indices for column families,CASSANDRA-749,Secondary indices for column families,,User requirement,3:51 - 3:87,1,arjan
4:176,jbellis,CASSANDRA-749,jbellis,,Comment,3:617 - 3:623,1,arjan
4:2,"it should be ""supported"" in the sense that if you want to load the ind…",CASSANDRA-749," it should be ""supported"" in the sense that if you want to load the index rows yourself  you should be able to do that.",,User requirement,3:625 - 3:743,1,arjan
4:3,but we shouldn’t try to create indexes from the serialized  row blobs…,CASSANDRA-749,"but we shouldn’t try to create indexes from the serialized  row blobs sent to bmt.
",,Architectural design configuration,3:745 - 3:828,1,arjan
4:177,gdusbabek,CASSANDRA-749,gdusbabek,,Comment,3:832 - 3:840,1,arjan
4:4,Adds secondary indices on columns as specifed in storage-conf:  <Index…,CASSANDRA-749,Adds secondary indices on columns as specifed in storage-conf:  <Index On=’some-col-name’/>  One assumption this patch makes is that the col names and values are all strings.,,Existing system architecture description,3:843 - 3:1016,1,arjan
4:5,"If we  2wanted to lift that restriction, we could specify a class that…",CASSANDRA-749,"If we  2
wanted to lift that restriction, we could specify a class that can ’stringify’ a column name  or value as part of the xml above.
",,Architectural design configuration,3:1018 - 4:130,1,arjan
4:178,stuhood,CASSANDRA-749,stuhood,,Comment,4:134 - 4:140,1,arjan
4:6,"Is it worth creating a secondary index that only contains local data,…",CASSANDRA-749,"Is it worth creating a secondary index that only contains local data, versus a  distributed secondary index (a normal ColumnFamily?)",,Risks,4:143 - 4:274,1,arjan
4:7,"Also, adding an example/dummy predicate that uses the index would be u…",CASSANDRA-749,"Also, adding an example/dummy predicate that uses the index would be useful.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",4:277 - 4:353,2,arjan
4:179,jbellis,CASSANDRA-749,jbellis,,Comment,4:358 - 4:364,1,arjan
4:8,What we’re trying to do here is move to the server a pattern that can…,CASSANDRA-749,"What we’re trying to do here is move to the server a pattern that can be more efciently  done there, and so every client doesn’t have to reimplement it manually.
",,Architectural tactics,4:543 - 4:705,1,arjan
4:180,stuhood,CASSANDRA-749,stuhood,,Comment,4:709 - 4:715,1,arjan
4:9,A distributed secondary index would allow you to query one machine to…,CASSANDRA-749,"A distributed secondary index would allow you to query one machine to fgure out what  other machines have columns matching a predicate, as opposed to a local secondary index  where you immediately query every machine to fgure out whether a predicate matches.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",4:760 - 4:1019,2,arjan
4:181,jbellis,CASSANDRA-749,jbellis,,Comment,4:1023 - 4:1029,1,arjan
4:10,"you mean, make each machine hold a copy of the full index?",CASSANDRA-749,"you mean, make each machine hold a copy of the full index?
",,"Architectural design configuration
Assumptions",4:1032 - 4:1091,2,arjan
4:11,"that’s worth thinking about, but it’s not useful yet since we don’t su…",CASSANDRA-749,"that’s worth thinking about, but it’s not useful yet since we don’t support index scans  anyway. (another ticket.)",,Architectural solution benefits and drawbacks,4:1092 - 4:1205,1,arjan
4:182,stuhood,CASSANDRA-749,stuhood,,Comment,4:1305 - 4:1311,1,arjan
4:12,I mean a distributed secondary index would be stored in a true ColumnF…,CASSANDRA-749,"I mean a distributed secondary index would be stored in a true ColumnFamily, so it would  be partitioned like any other CF.
",,Architectural design configuration,4:1376 - 4:1500,1,arjan
4:13,"In the local secondary index case, perhaps rather than using a separat…",CASSANDRA-749,"In the local secondary index case, perhaps rather than using a separate column family, the in-  dex should be another component of the ColumnFamilyStore, tied to each Memtable/SSTable,  rather than being a separate ColumnFamily. This gains us a lot of efciency, and some con-  sistency.
",,Architectural tactics,4:1598 - 4:1885,1,arjan
4:14,"We already have the primary index fle (Index.db) on disk, so secondary…",CASSANDRA-749,"We already have the primary index fle (Index.db) on disk, so secondary indexes would  be similar: (column, datafle_ofset) tuples. Consistency wise, all replication and repairs  happen at the ColumnFamily level, so replication might repair the data ColumnFamily but  not its index for instance.
",,Architectural design configuration,4:1886 - 4:2180,1,arjan
4:183,jbellis,CASSANDRA-749,jbellis,,Comment,4:2184 - 4:2190,1,arjan
4:15,"I think having each node index its CFs locally is a lose for us, becau…",CASSANDRA-749," I think having each node index its CFs locally is a lose for us, because as you say  we have to query the full cluster for any index lookup, since we are throwing away our usual  partitioning scheme.
This means we add a ton of complexity (adding a completely diferent query path) in ex-  change for not being able to scale these queries, since the work generated increases in lockstep  w/ machines added.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",4:2192 - 4:2599,2,arjan
4:184,stuhood,CASSANDRA-749,stuhood,,Comment,4:2604 - 4:2610,1,arjan
4:16,It would appear that the HBase folks have had this exact same discussi…,CASSANDRA-749," It would appear that the HBase folks have had this exact same discussion,  and have settled on two disparate packages for local and distributed secondary indexes:  http://issues.apache.org/jira/browse/HBASE-2037",,Other system architectural solutions,4:2612 - 4:2823,1,arjan
4:185,stuhood,CASSANDRA-749,stuhood,,Comment,5:5 - 5:11,1,arjan
4:17,"I’ve been thinking about this more, and I don’t think implementing sec…",CASSANDRA-749," I’ve been thinking about this more, and I don’t think implementing secondary  indexes is worth it: distributed or otherwise.",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:13 - 5:137,2,arjan
4:18,"Instead, I think the ’view’ approach that  CouchDB and Riak have taken…",CASSANDRA-749,"Instead, I think the ’view’ approach that  CouchDB and Riak have taken is defnitely superior.
For instance, it is easy to implement a secondary index as a view of a ColumnFamily:  the key for the view is the value of the indexed column, and the value for the view is the  key of the original row. But views are considerably more powerful, since you can store any  item in the key or value for the view.
Also, a view is more conducive to duplication of data, which we prefer in Cassandra: rather  than having secondary indexes pointing to the one true copy of the data, you can duplicate  that data in a view if you’d like, and have it be lazily/eagerly updated serverside.
Yes, views might mean a server side scripting language, or an easy to way to plug in and  confgure Java view classes. It might even mean map-reduce.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:139 - 5:964,2,arjan
4:186,jbellis,CASSANDRA-749,jbellis,,Comment,5:969 - 5:975,1,arjan
4:20,"gary, do you think this is worth committing to 0.6 given the String li…",CASSANDRA-749,"gary, do you think this is worth committing to 0.6 given the String limitation? for  0.7 we will almost certainly move to byte[] keys which would make the column -> key thing  much more sane.",,Trade-offs,5:978 - 5:1168,1,arjan
4:187,gdusbabek,CASSANDRA-749,gdusbabek,,Comment,5:1175 - 5:1183,1,arjan
4:21,It might as well wait until 0.7 then. There will still be a string res…,CASSANDRA-749," It might as well wait until 0.7 then.
There will still be a string restriction on the column name, unless there is a practical way to  express a binary column name in storage-conf.xml where the secondary indices are declared.
Maybe add an attribute to <Index> to indicate the On attribute contains base64 data or  something like that. Ugly crap though.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:1185 - 5:1541,2,arjan
4:188,stuhood,CASSANDRA-749,stuhood,,Comment,5:1593 - 5:1599,1,arjan
4:22,In a frst version a View CF could be defned with a normal column famil…,CASSANDRA-749,"In a frst version a View CF could be defned with a normal column family defnition,  plus a function that transforms a mutation against a ’base’ column family into zero or more  mutations against the ’view’ column family.
At mutation time, inserts can immediately be transformed into inserts to the view. But, an  insert that overwrites an older value implies deletion from the base, and therefore a potential  deletion from the view.",,Architectural design configuration,5:1644 - 5:2077,1,arjan
4:23,One disadvantage/advantage Cassandra has is that an entire row is not…,CASSANDRA-749,"One disadvantage/advantage Cassandra has is that an entire row is not available at mu-  tation time, so we need to defer all deletes to the view until read time. To handle deletes, all  columns in the view cf should be tagged with the column_key from the base cf that caused  their creation.
",,"Architectural design configuration
Contextual constraints",5:2080 - 5:2372,2,arjan
4:24,"At read time, the base cf column_keys that are tagging the columns in…",CASSANDRA-749,"At read time, the base cf column_keys that are tagging the columns in the view need  to be queried and the view function re-applied. If the output of the view function no longer  causes an insert to the column in question in the view, the column can be deleted from the  view.
",,Architectural design configuration,5:2373 - 5:2650,1,arjan
4:25,"Defnitely need to think of ways to efciently account for deletes, and…",CASSANDRA-749,"Defnitely need to think of ways to efciently account for deletes, and minimize the number  of reads to the base cf that need to occur at read time for the view cf.
",,Architectural tactics,5:2651 - 5:2815,1,arjan
4:189,dedalo,CASSANDRA-749,dedalo,,Comment,5:2820 - 5:2825,1,arjan
4:26,there is only a method to  search for a row set inside the specifed Co…,CASSANDRA-749,"there is only a method to  search for a row set inside the specifed ColomnFamily, for the specifed Column, given a  value for the column itself.",,Existing system architecture description,5:2881 - 5:3024,1,arjan
4:27,I think we really need a method to retrieve all the rows inside  4the…,CASSANDRA-749,"I think we really need a method to retrieve all the rows inside  4
the specifed ColumnFamily, for the specifed Column, sorted for column values (az or za).
Is there a way to do this? I don’t see it in the code. Am I wrong?
",,"Assumptions
User requirement",5:3026 - 6:158,2,arjan
4:190,gdusbabek,CASSANDRA-749,gdusbabek,,Comment,6:163 - 6:171,1,arjan
4:28,This patch merely does the indexing. It included a simple search metho…,CASSANDRA-749,"This patch merely does the indexing. It included a simple search method for demonstration  purposes.
",,Existing system architecture description,6:250 - 6:351,1,arjan
4:191,stuhood,CASSANDRA-749,stuhood,,Comment,6:471 - 6:477,1,arjan
4:29,"In order to not add reads to Cassandra’s write path, we could implemen…",CASSANDRA-749,"In order to not add reads to Cassandra’s write path, we could implement a modifcation  to mapreduce that splits the Map function into a map-key function and a map-value. I’m  attaching a conversation about a potential approach, but it doesn’t really get into imple-  mentation details or what the API for the map-key and map-value functions would look  like.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",6:527 - 6:886,2,arjan
4:192,jbellis,CASSANDRA-749,jbellis,,Comment,6:891 - 6:897,1,arjan
4:30,I think my initial reasoning was wrong here. I was anti-local-indexes…,CASSANDRA-749,"I think my initial reasoning was wrong here. I was anti-local-indexes because ""we have to  query the full cluster for any index lookup, since we are throwing away our usual partitioning  scheme.""  Which is true, but it ignores the fact that, in most cases, you will have to ""query the  full cluster"" to get the actual matching rows, b/c the indexed rows will be spread across all  machines. So, having local indexes is better in the common case, since it actually saves a  round trip from querying a the index to querying the rows.
Also, having each node index the rows it has locally means you don’t have to worry about  sharding a very large index since it happens automatically.
Finally, it lets us use the local commitlog to keep index + data in sync.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",6:1036 - 6:1794,3,arjan
4:193,jbellis,CASSANDRA-749,jbellis,,Comment,6:1799 - 6:1805,1,arjan
4:31,"I’m leaning more and more towards ""we should implement 2ary indexes +…",CASSANDRA-749," I’m leaning more and more towards ""we should implement 2ary indexes + querying  frst, then later add full view support"" since the former we can do w/o opening the whole  user defned functions box which is a pretty big deal.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",6:1807 - 6:2032,2,arjan
4:194,jbellis,CASSANDRA-749,jbellis,,Comment,6:2105 - 6:2111,1,arjan
4:32,"Step one is convert key from String to byte[], so that’s symmetric wit…",CASSANDRA-749,"Step one is convert key from String to byte[], so that’s symmetric with columns to  avoid the problem Gary noted in his original patch. (Should probably get its own ticket.)",,Architectural component behavior and structure,6:2114 - 6:2286,1,arjan
4:195,stuhood,CASSANDRA-749,stuhood,,Comment,6:2293 - 6:2299,1,arjan
4:33,"This was the point of the views being ""semi-materialized"". If your vie…",CASSANDRA-749,"This was the point of the views being ""semi-materialized"". If your view contains all of the  data you were interested in from the base row, and it matches a confgured recency, then  you don’t need to query the base. Please see my comment re: ""cribs"" in the latest attached  conversation.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",6:2440 - 6:2728,2,arjan
4:34,I disagree. I would expect that the view would contain a large number…,CASSANDRA-749,"I disagree. I would expect that the view would contain a large number of rows (typically  depending on 1 row each), so querying for one row in the view would usually query one or  two rows in the base: not necessarily thousands. Also, the partitioned index has much better  best case performance: for the local secondary indexes, you _always_ need to query every  unique range/endpoint in the cluster during the frst phase, and then merge sort the results  5
from all nodes before you can return a response for even a single row. Federating without  partitioning will not scale.
",,Architectural tactics,6:2861 - 7:121,1,arjan
4:35,Being able to implement these skinny rows (rather than the million col…,CASSANDRA-749,"Being able to implement these skinny rows (rather than the million column rows lazyboy  attempts) depends on being able to support non-unique row keys, but that is basically just a  compound key of the view-key and the base-key appended, as described on CASSANDRA-  767.
",,Architectural design configuration,7:122 - 7:393,1,arjan
4:36,This is why we have load balancing.,CASSANDRA-749,"This is why we have load balancing.
",,Architectural solution benefits and drawbacks,7:501 - 7:537,1,arjan
4:37,There is no need to allow for arbitrary functions initially,CASSANDRA-749,There is no need to allow for arbitrary functions initially,,Architectural solution benefits and drawbacks,7:644 - 7:702,1,arjan
4:38,"if we take the same approach we’ve  taken for comparators: to start, a…",CASSANDRA-749," if we take the same approach we’ve  taken for comparators: to start, a new view would be defned by extending an abstract class.
We could easily have a built in ""SecondaryIndex"" view class that uses a matching column  name/value as the row key in the view.
",,Architectural design configuration,7:703 - 7:961,1,arjan
4:39,"Without a way to use these secondary indexes in queries, they are comp…",CASSANDRA-749,"Without a way to use these secondary indexes in queries, they are completely pointless",,"Architectural design configuration
Architectural solution benefits and drawbacks",7:968 - 7:1053,2,arjan
4:40,Is the  intention that the indexes would be used to speed up predicate…,CASSANDRA-749,"Is the  intention that the indexes would be used to speed up predicates/flters in get_range_slices,",,Architectural design configuration,7:1056 - 7:1154,1,arjan
4:41,are you proposing that the secondary index/view looks and acts like a…,CASSANDRA-749,"are you proposing that the secondary index/view looks and acts like a normal column  family, with all of the row content, but with the secondary key as the row key",,Architectural design configuration,7:1160 - 7:1322,1,arjan
4:42,"The former  seems pointless,",CASSANDRA-749,"The former  seems pointless,",,Architectural solution benefits and drawbacks,7:1325 - 7:1352,1,arjan
4:43,and the latter seems like it should be implemented using the partition…,CASSANDRA-749," and the latter seems like it should be implemented using the partitioned  secondary index approach.
",,Architectural design configuration,7:1353 - 7:1454,1,arjan
4:196,jbellis,CASSANDRA-749,jbellis,,Comment,7:1459 - 7:1465,1,arjan
4:44,Load balancing doesn’t help if you are indexing something with less po…,CASSANDRA-749,"Load balancing doesn’t help if you are indexing something with less potential values than  you have nodes in the cluster. At the extreme, say booleans, it’s probably not worth indexing  vs just doing full scans. But if you have 100s of nodes then not being able to usefully index  something woth 20 or 50 or 100 values kinda sucks.
",,Architectural solution benefits and drawbacks,7:1507 - 7:1839,1,arjan
4:45,"That would probably work, although I don’t want to fall into the trap…",CASSANDRA-749,"That would probably work, although I don’t want to fall into the trap of overgeneralizing  because it’s sexy. Nobody wants to write static java code to defne a view, I can promise  you that. :)",,"Architectural solution benefits and drawbacks
Risks",7:1973 - 7:2165,2,arjan
4:46,"No, it’s to add a diferent kind of predicate: ""give me these columns […",CASSANDRA-749,"No, it’s to add a diferent kind of predicate: ""give me these columns [existing functionality]  from rows that match this index condition [new functionality].""",,Architectural design configuration,7:2269 - 7:2426,1,arjan
4:197,stuhood,CASSANDRA-749,stuhood,,Comment,7:2433 - 7:2439,1,arjan
4:47,"Again, this brings up the topic of skinny rows: I’m sticking with the…",CASSANDRA-749,"Again, this brings up the topic of skinny rows: I’m sticking with the idea that we would want  skinny rows with a compound key, so that each row key in the index/view might start with  ""true"" in the boolean case, but the actual view row key would be a compound: ""true|<base-  key>"". So, yes, even in the boolean case it is possible to partition the index: you would have  very hot spots around ""true|*"" and ""false|*"", but that wouldn’t stop our load balancing from  splitting based on the remainder of the key.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",7:2566 - 7:3077,2,arjan
4:48,"I know, but it is a temporary solution that allows us to fne tune the…",CASSANDRA-749,"I know, but it is a temporary solution that allows us to fne tune the interface without  providing scripting support or anything else crazy.
",,Architectural solution benefits and drawbacks,8:87 - 8:228,1,arjan
4:198,jbellis,CASSANDRA-749,jbellis,,Comment,8:233 - 8:239,1,arjan
4:49,"Skinny rows is more special casing than just partitioning indexes, and…",CASSANDRA-749," Skinny rows is more special casing than just partitioning indexes, and doesn’t solve  the ""how do we keep the index consistent w/ the actual data in the case of failures"" problem.
",,Architectural solution benefits and drawbacks,8:241 - 8:422,1,arjan
4:199,gdusbabek,CASSANDRA-749,gdusbabek,,Comment,8:427 - 8:435,1,arjan
4:50,We also still have the (minor) problem of describing the indexed colum…,CASSANDRA-749,"We also still have the (minor) problem of describing the indexed column in storage-conf.
<Index OnHex=""0xabcd""/> or something like that ought to work.
",,Technical debt,8:576 - 8:728,1,arjan
4:51,As to the locality discussion: I’m still in favor of keeping them node…,CASSANDRA-749,"As to the locality discussion: I’m still in favor of keeping them node-local, at least for  the way we intend to use them. (Please give me colB for rows where colA=foo and the row  key is unknown.)",,Architectural solution benefits and drawbacks,8:729 - 8:925,1,arjan
4:200,jbellis,CASSANDRA-749,jbellis,,Comment,8:932 - 8:938,1,arjan
4:52,It’s worth pointing out that our row bloom flter rejects requests for…,CASSANDRA-749," It’s worth pointing out that our row bloom flter rejects requests for non-existing  rows very, very performantly, so the overhead for doing requests to all nodes for local indexes  (or at least nodes / RF) when cardinality is high is lower than it looks at frst.
",,"Architectural solution benefits and drawbacks
Existing system architecture description",8:940 - 8:1204,2,arjan
4:53,So in practice I strongly suspect this will scale at least to hundreds…,CASSANDRA-749,"So in practice I strongly suspect this will scale at least to hundreds of nodes if not thousands,  so saying ""we can’t do this because it won’t scale"" is not a strong argument.
",,Architectural solution benefits and drawbacks,8:1205 - 8:1382,1,arjan
4:54,"And when you are doing requests against a ""index on a single node,"" th…",CASSANDRA-749,"And when you are doing requests against a ""index on a single node,"" the consistency problem  is worth than you think. There’s no way to make it consistent with a batch m/r, without  a Big Lock against the CF being indexed, since if you are examining an index entry w/ no  matching ""natural"" entry, you have no way of knowing if that’s because another process is  about to clean out the index entry, or add the natural entry. So you have to check each  index hit for validity *each* *time* which is a huge hit. (And allowing the user to say ""stale  data"" is okay is wrong, because it’s not ""eventually consistent,"" once out of sync it will stay  that way.)",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",8:1383 - 8:2037,2,arjan
4:201,jbellis,CASSANDRA-749,jbellis,,Comment,8:2044 - 8:2050,1,arjan
4:55,Another point: local indexes allow us to do indexed inequality compari…,CASSANDRA-749,"Another point: local indexes allow us to do indexed inequality comparisons (birth_date  > $year) trivially, since we can safely make the local index sstables OPP no matter what  the cluster partitioner setting is. Doing this for non-local indexes requires the cluster to be  OPP, which experience has demonstrated is not what most people want to use despite its  advantages.
",,"Architectural solution benefits and drawbacks
User requirement",8:2053 - 8:2428,2,arjan
4:202,stuhood,CASSANDRA-749,stuhood,,Comment,8:2433 - 8:2439,1,arjan
4:56,"I think you’re  making the ""speed == scalability"" mistake. It doesn’t…",CASSANDRA-749,"I think you’re  making the ""speed == scalability"" mistake. It doesn’t matter if we could do 30k index  queries per second on one node: your bound for index queries for the entire cluster would  still be 30k, no matter how many nodes you added.
",,Architectural solution benefits and drawbacks,8:2622 - 8:2866,1,arjan
4:57,You have to do the same thing for the secondary index: presumably you…,CASSANDRA-749,"You have to do the same thing for the secondary index: presumably you actually want to  fnd the content of the row that was indexed, and so you need to seek to the row in the  indexed CF. Both solutions need this seek: one just performs it across the network.
",,Architectural solution benefits and drawbacks,8:2954 - 8:3214,1,arjan
4:58,This is a problem: I’ll admit. One option is to do something like ’vie…,CASSANDRA-749,"This is a problem: I’ll admit. One option is to do something like ’view-read-repair’: when  retrieving the indexed row from the base, only clean up an invalid index entry after enough  time has passed since the entries’ creation time for any in fight-writes to have completed.
",,Architectural solution benefits and drawbacks,8:3345 - 8:3622,1,arjan
4:59,I think I’m convinced that fully materialized views will not be able t…,CASSANDRA-749,"I think I’m convinced that fully materialized views will not be able to be consistent (even  eventually), since the nodes storing the base/view are probably in diferent scopes of serial-  izability. BUT I’m sticking to the idea that the partitioned view that queries the base for  the row content is the superior one.
",,Architectural solution benefits and drawbacks,9:7 - 9:324,1,arjan
4:203,stuhood,CASSANDRA-749,stuhood,,Comment,9:330 - 9:336,1,arjan
4:60,"If people don’t want to use OPP, most likely that is because we have m…",CASSANDRA-749,"If people don’t want to use OPP, most likely that is because we have more work to do on  load balancing (fxing CASSANDRA-579 for instance). OPP is one of our key advantages,  and throwing it away because it still needs improvement is not wise.
",,Architectural solution benefits and drawbacks,9:506 - 9:750,1,arjan
4:204,jbellis,CASSANDRA-749,jbellis,,Comment,9:755 - 9:761,1,arjan
4:61,"Not if you denormalize into subcolumns, you don’t.",CASSANDRA-749,"Not if you denormalize into subcolumns, you don’t.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",9:899 - 9:950,2,arjan
4:205,jbellis,CASSANDRA-749,jbellis,,Comment,9:955 - 9:961,1,arjan
4:62,"No, I’m simply acknowledging that there’s no such thing as ""infnite sc…",CASSANDRA-749,"No, I’m simply acknowledging that there’s no such thing as ""infnite scalability,"" and if  this scales to the machine counts people actually deploy on then it’s silly to do something  more complex.
",,Architectural solution benefits and drawbacks,9:1024 - 9:1220,1,arjan
4:206,jbellis,CASSANDRA-749,jbellis,,Comment,9:1226 - 9:1232,1,arjan
4:63,Another point: having local indexes makes applying AND clauses touchin…,CASSANDRA-749,Another point: having local indexes makes applying AND clauses touching multiple  indexes easy. ,,Architectural solution benefits and drawbacks,9:1235 - 9:1330,1,arjan
4:64,This is difcult to do efciently when you have two indexes on two difer…,CASSANDRA-749,"This is difcult to do efciently when you have two indexes on two diferent  machines.
",,Architectural solution benefits and drawbacks,9:1331 - 9:1416,1,arjan
4:207,stuhood,CASSANDRA-749,stuhood,,Comment,9:1421 - 9:1427,1,arjan
4:65,I don’t think that is a road we should necessarily be going down: a co…,CASSANDRA-749,"I don’t think that is a road we should necessarily be going down: a compound index describ-  ing the AND is much more performant, and fts the view model much better.
",,Architectural tactics,9:1513 - 9:1679,1,arjan
4:208,jbellis,CASSANDRA-749,jbellis,,Comment,9:1684 - 9:1690,1,arjan
4:66,Compound indexes can be useful but they explode in size far too quickl…,CASSANDRA-749," Compound indexes can be useful but they explode in size far too quickly as you  add index terms to be the only solution ofered.
",,Architectural solution benefits and drawbacks,9:1692 - 9:1821,1,arjan
4:209,jbellis,CASSANDRA-749,jbellis,,Comment,9:1826 - 9:1832,1,arjan
4:67,"One disadvantage of local indexes is, they have to be rebuilt (on the…",CASSANDRA-749,"One disadvantage of local indexes is, they have to be rebuilt (on the receiving side)  when streaming, and tombstoned on cleanup (on the sending side).
This isn’t without its silver lining, though; having to only transfer the actual data from  the sending machines (where resources are scarcer than on the empty, receiving end) is def-  inite efciency win.
We’re also already planning to only stream data in 579, and rebuild index + BF on the  receving side -- with that in place, rebuilding local indexes will be a simple addition.
",,Architectural solution benefits and drawbacks,9:1835 - 9:2370,1,arjan
4:210,stuhood,CASSANDRA-749,stuhood,,Comment,9:2375 - 9:2381,1,arjan
4:68,Clif mentioned in #cassandra that he preferred the local secondary ind…,CASSANDRA-749,"Clif mentioned in #cassandra that he preferred the local secondary index ap-  proach. I think this was because adding more replicas is supposed to be a solution for scaling  out reads, but I don’t think it is that simple here.
",,Architectural solution benefits and drawbacks,9:2384 - 9:2611,1,arjan
4:69,"Rather than utilizing IO efciently by partitioning, all of those nodes…",CASSANDRA-749,"Rather than utilizing IO efciently by partitioning, all of those nodes will have approxi-  mately the same stuf cached in memory, because they won’t have been assigned anything  specifc to hold onto.",,Architectural design configuration,9:2612 - 9:2810,1,arjan
4:70,"Also, scaling up to more replicas (than you need for HA) across your…",CASSANDRA-749,"Also, scaling up to more replicas (than you need for HA) across your  entire cluster in order to improve your average latency seems like a waste of disks/machines.
8
Additionally, you have to keep all of those replicas consistent, which means every node  still has to answer reads eventually for read repair. Adding nodes doesn’t actually eliminate  any queries: it might improve your average latency, but it won’t afect your throughput.
",,Architectural solution benefits and drawbacks,9:2812 - 10:273,1,arjan
4:211,jbellis,CASSANDRA-749,jbellis,,Comment,10:278 - 10:284,1,arjan
4:71,Making read repair disable-able,CASSANDRA-749,Making read repair disable-able,,Architectural design configuration,10:287 - 10:317,1,arjan
4:72,would be a lot smaller of a design wart than what  nonlocal indexes re…,CASSANDRA-749,"would be a lot smaller of a design wart than what  nonlocal indexes require.
",,Architectural solution benefits and drawbacks,10:319 - 10:395,1,arjan
4:212,jbellis,CASSANDRA-749,jbellis,,Comment,10:401 - 10:407,1,arjan
4:73,"And the performance of updating nonlocal indexes really is ass, which…",CASSANDRA-749,"And the performance of updating nonlocal indexes really is ass, which is why we  shouldn’t infict it on everyone in the name of making things more convenient for the largest  sites.
(Remember, it’s either ass because you have to do read base/update index/update index  new/write base new, or because you have to set recency super low and cause a ton of check-  against-base on your lookups.)",,Architectural solution benefits and drawbacks,10:410 - 10:801,1,arjan
4:213,jbellis,CASSANDRA-749,jbellis,,Comment,10:808 - 10:814,1,arjan
4:74,"In support of the ""nonlocal indexes are too slow"" argument, I present…",CASSANDRA-749,"In support of the ""nonlocal indexes are too slow"" argument, I present as ex-  hibit A google app engine. From http://www.chariotsolutions.com/slides/pdfs/ete2009-  GoogleUndertheCoversApp.pdf it appears that they use nonlocal indexes, and it’s so slow  that they’ve ""improved"" it by automatically retrying timed-out queries.
",,Architectural solution benefits and drawbacks,10:817 - 10:1142,1,arjan
4:75,Local indexes may not scale well enough to be the only solution you ev…,CASSANDRA-749,"Local indexes may not scale well enough to be the only solution you ever need,",,"Architectural solution benefits and drawbacks
Assumptions",10:1143 - 10:1220,2,arjan
4:76,but nonlocal  indexes are too slow to be the only solution you ever ne…,CASSANDRA-749," but nonlocal  indexes are too slow to be the only solution you ever need.
It also bothers me that nonlocal indexes with ""recency"" violate our ""except in failure scenar-  ios, readers see writes in ms"" policy. (There is a race: if a reader sees an ""empty"" cell, and  flls it in before the write completes, it will be marked as empty until the recency expires.
So we’ve added a second layer of inconsistency on top of our existing one.)",,Architectural solution benefits and drawbacks,10:1221 - 10:1657,1,arjan
4:77,To me the decisive argument is that if someone has a workload that rea…,CASSANDRA-749,"To me the decisive argument is that if someone has a workload that really needs nonlo-  cal indexes, they can build those in their app with very little performance diference, just  the round trips from app server to cassandra coordinator node. (Using the StorageProxy  api would erase even this.) Clients like lazyboy already automate this.
If you have a workload that is a good ft for local indexes (which is, as I’ve pointed out,  at the very least ""every workload in a cluster with less than some unknown number N of  nodes"") then there’s no way to fake that from the client.
Finally, as I’ve noted, the query API should be index-implementation-agnostic, so imple-  menting local indexes now doesn’t preclude adding a PartitionedByColumnIndex later.
",,Architectural design configuration,10:1660 - 10:2415,1,arjan
4:214,stuhood,CASSANDRA-749,stuhood,,Comment,10:2420 - 10:2426,1,arjan
4:78,"First, they’re hosted on Bigtable, so of course they need timeouts. Se…",CASSANDRA-749,"First, they’re hosted on Bigtable, so of course they need timeouts. Second, they have a  section titled ""Constraints Precede Performance"", which shows why you should constrain  queries rather than allowing queries that will be slow.
",,Existing system architecture description,10:2566 - 10:2799,1,arjan
4:79,This applies to both local and distributed indexes. You will have to d…,CASSANDRA-749,"This applies to both local and distributed indexes. You will have to decide between eager  and lazy cleanups of the view, whether you are updating it locally or remotely. ",,Motivation of design issue,10:2898 - 10:3068,1,arjan
4:80,The perfor-  mance hit in the write path for the distributed index is…,CASSANDRA-749,"The perfor-  mance hit in the write path for the distributed index is having to do blocking writes to W  replicas in the view before starting writes to the base.
",,Architectural solution benefits and drawbacks,10:3069 - 10:3231,1,arjan
4:81,This was one of the points of that timeout parameter being set higher…,CASSANDRA-749,"This was one of the points of that timeout parameter being set higher than a write might  take to complete: if a write was still in progress (view clock doesn’t match base clock), we  wouldn’t populate the view.
",,Existing system architecture description,11:47 - 11:259,1,arjan
4:215,jbellis,CASSANDRA-749,jbellis,,Comment,11:264 - 11:270,1,arjan
4:82,The point is that indexed queries are *still slow* (hundreds of ms) on…,CASSANDRA-749,"The point is that indexed queries are *still slow* (hundreds of ms) on app engine. Edit:  and updates too, which was where I was going here.
",,Architectural solution benefits and drawbacks,11:511 - 11:652,1,arjan
4:83,But with local it’s all ... local.,CASSANDRA-749,"But with local it’s all ... local.
",,Architectural solution benefits and drawbacks,11:707 - 11:742,1,arjan
4:216,jbellis,CASSANDRA-749,jbellis,,Comment,11:1029 - 11:1035,1,arjan
4:85,If we had megastore-style entity groups and distributed transaction lo…,CASSANDRA-749,If we had megastore-style entity groups and distributed transaction log,,Architectural design configuration,11:1038 - 11:1108,1,arjan
4:84,then keep-  ing non-local indexes in sync becomes a non-problem. (Alth…,CASSANDRA-749,"then keep-  ing non-local indexes in sync becomes a non-problem. (Although performance still sucks,  apparently.)  Of course that’s one hell of a prerequisite",,Architectural solution benefits and drawbacks,11:1111 - 11:1268,1,arjan
4:86,So I still think local indexes are the sane short  term solution.,CASSANDRA-749,So I still think local indexes are the sane short  term solution.,,Architectural solution benefits and drawbacks,11:1271 - 11:1335,1,arjan
4:87,And we do need indexes sooner than later.,CASSANDRA-749,"And we do need indexes sooner than later.
",,Architectural solution benefits and drawbacks,11:1337 - 11:1379,1,arjan
4:217,stuhood,CASSANDRA-749,stuhood,,Comment,11:1384 - 11:1390,1,arjan
4:88,"Jonathan and I talked this afternoon, and settled a few things: this t…",CASSANDRA-749,"Jonathan and I talked this afternoon, and settled a few things: this ticket  should move forward with local indexes for now.
",,Architectural solution benefits and drawbacks,11:1393 - 11:1518,1,arjan
4:89,We also agree that we should only allow queries against exactly one  i…,CASSANDRA-749,"We also agree that we should only allow queries against exactly one  index to start with,",,Architectural component behavior and structure,11:1519 - 11:1607,1,arjan
4:90,which should be sufcient to solve a large number of  problems.,CASSANDRA-749,"which should be sufcient to solve a large number of  problems.
",,Architectural solution benefits and drawbacks,11:1609 - 11:1672,1,arjan
4:91,"One possibility is exposing indexes as named views, which support the…",CASSANDRA-749,"One possibility is exposing indexes as named views, which support the  same calls that standard CFs do. Thus, the the user names a view e.g.
a ""UsersByAccount"" view for the ""Users"" CF, which would look like a  super CF of (indexkey, (basekey, (basecols))) to the thrift API.
",,Architectural design configuration,11:1739 - 11:2015,1,arjan
4:92,"This would preclude support for indexing super CFs initially, since we…",CASSANDRA-749,"This would preclude support for indexing super CFs initially, since we  don’t support arbitrary nesting yet.
",,Architectural solution benefits and drawbacks,11:2016 - 11:2125,1,arjan
4:218,jbellis,CASSANDRA-749,jbellis,,Comment,11:2130 - 11:2136,1,arjan
4:93,The more I think about the pseudo-CF api the less I like it. We want t…,CASSANDRA-749,"The more I think about the pseudo-CF api the less I like it.
We want to push fltering down to the node with the data on it, where possible. This  means that, even if we only actually scan one index, we need to be able to say ""AND cond2  op val2"" and apply that before moving data of-node. This isn’t possible the ""pretend index  is a supercolumn row"" approach.
",,Architectural solution benefits and drawbacks,11:2139 - 11:2501,1,arjan
4:94,"An alternative would be to combine range scans, multigets, and index s…",CASSANDRA-749,"An alternative would be to combine range scans, multigets, and index scans into a single api,  multiget(rowpredicate, columnpredicate)*  10
rowpredicate would then be one of  - named keys [current multiget]  - key range [current get_range_slices]  - column comparisons [index scan]",,Architectural design configuration,11:2502 - 12:141,1,arjan
4:95,"This unifes the concept of ""get a bunch of rows at once"" nicely.",CASSANDRA-749,"This unifes the concept of ""get a bunch of rows at once"" nicely.
",,Architectural solution benefits and drawbacks,12:144 - 12:209,1,arjan
4:96,*open to a diferent method name if we can come up with one that doesn’…,CASSANDRA-749,"*open to a diferent method name if we can come up with one that doesn’t suck.
",,Architectural component behavior and structure,12:210 - 12:288,1,arjan
4:219,stuhood,CASSANDRA-749,stuhood,,Comment,12:293 - 12:299,1,arjan
4:97,"The key in the pseudo CF  would be the original indexed value, and eac…",CASSANDRA-749,"The key in the pseudo CF  would be the original indexed value, and each top level column in the index row would be a  row from the base (from one node)",,Architectural design configuration,12:439 - 12:589,1,arjan
4:98,so fltering within the base row could be applied locally  on each node…,CASSANDRA-749," so fltering within the base row could be applied locally  on each node.
",,Architectural solution benefits and drawbacks,12:591 - 12:664,1,arjan
4:99,"The rowpredicate containing an ""index scan""  parameter is very interes…",CASSANDRA-749,"The rowpredicate containing an ""index scan""  parameter is very interesting, and does clarify slow operations. But, I can easily image a  situation where someone wanted to use both a ""named keys"" and ""index scan"" rowpredicate  at once, which would still be very efcient, but which would require a list<rowpredicate>.
",,"Architectural solution benefits and drawbacks
Architectural tactics",12:707 - 12:1023,2,arjan
4:100,"I agree that placing the ""index scan"" predicate in the frst position i…",CASSANDRA-749,"I agree that placing the ""index scan"" predicate in the frst position in the method call is  essential, which is why I suggested the pseudo-CF api:",,Architectural solution benefits and drawbacks,12:1024 - 12:1169,1,arjan
4:102,An interesting parallel is to compare the proposed api to Python’s arr…,CASSANDRA-749,"An interesting parallel is to compare the proposed api to Python’s array slicing syntax,",,Other system architectural solutions,12:1178 - 12:1265,1,arjan
4:101,which is extremely elegant,CASSANDRA-749,which is extremely elegant,,Architectural solution benefits and drawbacks,12:1268 - 12:1293,1,arjan
4:103,I imagine that our ideal API,CASSANDRA-749,I imagine that our ideal API,,Architectural solution benefits and drawbacks,12:1296 - 12:1323,1,arjan
4:104,is one that allows either named  keys or a key range at every level of…,CASSANDRA-749,"is one that allows either named  keys or a key range at every level of nesting. The following paragraphs only refer to key/-  name slicing, and don’t go into ’value’ queries.
As long as you concretely defne a key or range of keys to search for at each level (such  as [key1:key5][name1:name2][subname5]), your operation can run in bounded time. But, to  provide for more fexibility, the get_range_slices method in the current API allows some-  thing like: [ ? ][name5] The question mark represents an unbounded level, which may mean  a full table scan without fnding ’subname5’ (very dangerous, not scalable). This is one of  the places where we need secondary indexes: we want columns containing _any_ value for  subname5 bunched together into an index.
",,Architectural design configuration,12:1325 - 12:2081,1,arjan
4:105,Comparing to the Python array API highlights the fact that prefx searc…,CASSANDRA-749,"Comparing to the Python array API highlights the fact that prefx searches are always  safe, and that by always having a parent predicate, you achieve bounded time operations.
This is why placing the ""index scan"" predicate in the frst position is so clear.
",,Architectural solution benefits and drawbacks,12:2082 - 12:2339,1,arjan
4:106,"why have 3 types of rowpredicates, and 2+  types of columnpredicates w…",CASSANDRA-749,"why have 3 types of rowpredicates, and 2+  types of columnpredicates when, by asking users to defne views that shufe their data into  a form that allows for prefx queries, we can do something like:",,Architectural solution benefits and drawbacks,12:2388 - 12:2584,1,arjan
4:107,multiget(list<predicate> predicates)  ... with a predicate (key range…,CASSANDRA-749,"multiget(list<predicate> predicates)  ... with a predicate (key range or key list) required for every level, and only the last level  allowing an unbounded predicate.
11
With this API, the ""named keys"" + ""index scan"" query I pointed out above would look  like (with an indexed ’age’ column):  multiget( [ predicate(key is 27), predicate(name in [ben, george]), predicate(subname is any)  ] )",,Architectural design configuration,12:2587 - 13:221,1,arjan
4:220,stuhood,CASSANDRA-749,stuhood,,Comment,13:228 - 13:234,1,arjan
4:108,"Thinking about this more, ANY range we allow is basically unbounded, b…",CASSANDRA-749,"Thinking about this more, ANY range we allow is basically unbounded, because  the distance between A and B may be billions of rows.
",,Existing system architecture description,13:237 - 13:369,1,arjan
4:109,"Instead of disallowing them, I think the approach that get_range_slice…",CASSANDRA-749,"Instead of disallowing them, I think the approach that get_range_slices takes for unbounded  ranges (http://wiki.apache.org/cassandra/FAQ#range_ghosts) is reasonable:",,"Architectural solution benefits and drawbacks
Assumptions",13:370 - 13:535,2,arjan
4:110,"it bounds the  time that can be spent on a specifc query, because a qu…",CASSANDRA-749,"it bounds the  time that can be spent on a specifc query, because a query will return null rows rather than  doing an unending scan.
",,Architectural design configuration,13:537 - 13:670,1,arjan
4:111,"It’s not ideal, because a user will probably be tempted to write a loo…",CASSANDRA-749,"It’s not ideal, because a user will probably be tempted to write a loop that pages through  the null rows, but it will be a clear anti-pattern, because we can tell users: ""if you’re thinking  about paging through the results from multiget, then you should probably be using a view  instead."".",,Architectural solution benefits and drawbacks,13:671 - 13:962,1,arjan
4:221,jbellis,CASSANDRA-749,jbellis,,Comment,13:969 - 13:975,1,arjan
4:112,"I suppose that’s an option,",CASSANDRA-749," I suppose that’s an option,",,"Architectural solution benefits and drawbacks
Assumptions",13:977 - 13:1004,2,arjan
4:113,"- that tombstoned keys give empty result sets is correct, if unexpecte…",CASSANDRA-749,"- that tombstoned keys give empty result sets is correct, if unexpected, and even so it’s  possibly the #1 FAQ we get. adding Yet Another Special Case, this time with null sets to  indicate that ""maybe it had the columns requested, maybe not, but it didn’t match your  where clause"" isn’t even remotely intuitive.
- In 10 years of using relational databases I can count on zero fngers the number of times  that an indexed query was killing the system because of extra where clauses that made it  scan extra data. Sure, it’s theoretically possible, but in practice it just doesn’t seem to  matter.
- ""my system lets me do queries that are slow"" is NOT a complaint most people have about  sql. you’re addressing a pain point that people just aren’t feeling.
",,Architectural solution benefits and drawbacks,13:1011 - 13:1769,1,arjan
4:114,"So I’d be more inclined to say, let’s do it the intuitive way.",CASSANDRA-749,"So I’d be more inclined to say, let’s do it the intuitive way.
",,Architectural solution benefits and drawbacks,13:1770 - 13:1833,1,arjan
4:222,stuhood,CASSANDRA-749,stuhood,,Comment,13:1838 - 13:1844,1,arjan
4:115,I’m not talking about looking at values here: just keys/names. So the…,CASSANDRA-749,"I’m not talking about looking at values here: just keys/names. So the only question that  query is answering is ""did this column key/name exist with these parents"".
The _only_ way to query values with the API I proposed is to create a view by the value.
EDIT: Hmm... now I’m not so sure. You could technically allow value queries using that  same API with an additional predicate level for the value.
",,Architectural design configuration,13:1938 - 13:2341,1,arjan
4:116,"I disagree, but perhaps we misunderstood eachother on that frst point.",CASSANDRA-749,"I disagree, but perhaps we misunderstood eachother on that frst point.
",,Architectural solution benefits and drawbacks,13:2437 - 13:2508,1,arjan
4:117,"Essentially, what a user  is supposed to understand is: ""the database…",CASSANDRA-749," Essentially, what a user  is supposed to understand is: ""the database had to scan 100 null rows for every 1 that it  returned""",,Existing system architecture description,13:2581 - 13:2707,1,arjan
4:223,jbellis,CASSANDRA-749,jbellis,,Comment,14:208 - 14:214,1,arjan
4:118,"Like Stu said, they have both local indexes (IH-  Base) and distribute…",CASSANDRA-749,"Like Stu said, they have both local indexes (IH-  Base) and distributed ones (THBase). Local indexes were implemented second,",,Other system architectural solutions,14:248 - 14:372,1,arjan
4:119,but seem  to be regarded as better for most situations since they are…,CASSANDRA-749,but seem  to be regarded as better for most situations since they are substantially faster.,,"Architectural solution benefits and drawbacks
Architectural tactics",14:374 - 14:464,2,arjan
4:120,"Neither  THBase nor IHBase does materialization, so that is an importa…",CASSANDRA-749,"Neither  THBase nor IHBase does materialization, so that is an important diference from what we  are proposing here.",,Other system architectural solutions,14:467 - 14:582,1,arjan
4:121,"IHBase indexes are built in memory on regionserver start, and are not…",CASSANDRA-749,"IHBase indexes are built in memory on regionserver start, and are not persisted.
THBase stands for transactional. 2PC is used to keep indexes in sync with the original  data",,Other system architectural solutions,14:586 - 14:759,1,arjan
4:122,"to avoid inconsistency problems, but ""you cannot rely on the transacti…",CASSANDRA-749,"to avoid inconsistency problems, but ""you cannot rely on the transactional properties  in the face of node failure."" ",,Architectural solution benefits and drawbacks,14:761 - 14:877,1,arjan
4:123,"IHBase and THBase are now both part of the same ""transactional"" contri…",CASSANDRA-749,"IHBase and THBase are now both part of the same ""transactional"" contrib package. I’m not  sure if you can use both types of indexes in the same CF or Table.
From my reading, THBase does not deal with the ""very large index rows"" problem. Possibly  rows can already be arbitrarily large under HBase + HDFS?",,Other system architectural solutions,14:1030 - 14:1334,1,arjan
4:124,Note that for us rows will  always be limited to the size of a single…,CASSANDRA-749,"Note that for us rows will  always be limited to the size of a single machine’s local disk, even when we fx the ""ft in  memory’ limitation.",,Architectural solution benefits and drawbacks,14:1337 - 14:1475,1,arjan
4:224,jbellis,CASSANDRA-749,jbellis,,Comment,14:1483 - 14:1489,1,arjan
4:125,"if you are reading small ""pages"" worth of indexed rows out at a  time,…",CASSANDRA-749,"if you are reading small ""pages"" worth of indexed rows out at a  time, which we’ve been discussing here as the use case that non-local indexes are good at,  then presumably you want the rows in your pages ordered by some property.
If this property is the original, base row key (or if the user doesn’t care and allows us  to pick),",,Architectural design configuration,14:1509 - 14:1840,1,arjan
4:126,"then local indexes are just as efcient as non-local under OPP, since y…",CASSANDRA-749,"then local indexes are just as efcient as non-local under OPP, since you can only  query a single replica. (Under RP, you can’t do non-local indexes at all, so local indexes still  wins.)",,"Architectural solution benefits and drawbacks
Architectural tactics",14:1842 - 14:2028,2,arjan
4:127,"If the property is NOT the original, base row key, then not matter wha…",CASSANDRA-749,"If the property is NOT the original, base row key, then not matter what kind of index  you have, you need to read all the results to sort in the desired order, in which case paral-  lelizing that read is better than not, which you get for free with local indexes; the ""index  hot spot"" reasoning also applies.
",,Architectural solution benefits and drawbacks,14:2031 - 14:2341,1,arjan
4:225,stuhood,CASSANDRA-749,stuhood,,Comment,14:2346 - 14:2352,1,arjan
4:128,I think we agree that both approaches have their merits.,CASSANDRA-749,I think we agree that both approaches have their merits.,,"Architectural solution benefits and drawbacks
Assumptions",14:2355 - 14:2410,2,arjan
4:129,Local indexes are better for:  * Low cardinality felds  * Filtering of…,CASSANDRA-749,Local indexes are better for:  * Low cardinality felds  * Filtering of values in base order,,Architectural solution benefits and drawbacks,14:2531 - 14:2621,1,arjan
4:130,Distributed indexes are better for:  * High cardinality felds  * Query…,CASSANDRA-749,Distributed indexes are better for:  * High cardinality felds  * Querying of values in index order,,Architectural solution benefits and drawbacks,14:2624 - 14:2721,1,arjan
4:131,Since we’ve decided to move forward with local indexes in this version…,CASSANDRA-749,"Since we’ve decided to move forward with local indexes in this version, I think it would  be reasonable to restrict this initial implementation to fltering of known keys (no sorting),  and to put a restriction in place to prevent them from being used for querying. Additionally,  we should ""leave room"" to add in the ability to sort/query on the indexed dimension in the  future (when we implement distributed indexes).
",,"Architectural design configuration
Assumptions",14:2724 - 14:3144,2,arjan
4:226,stuhood,CASSANDRA-749,stuhood,,Comment,15:5 - 15:11,1,arjan
4:132,Since local indexes aren’t as useful for returning results in index or…,CASSANDRA-749,"Since local indexes aren’t as useful for returning results in index order, and since  they are much better for low cardinality felds,",,Architectural solution benefits and drawbacks,15:14 - 15:146,1,arjan
4:133,perhaps they should be implemented as  bitmap indexes? http://en.wikip…,CASSANDRA-749,perhaps they should be implemented as  bitmap indexes? http://en.wikipedia.org/wiki/Bitmap_index,,"Assumptions
Other system architectural solutions",15:148 - 15:243,2,arjan
4:227,kingryan,CASSANDRA-749,kingryan,,Comment,15:250 - 15:257,1,arjan
4:134,"1. Do local indexes for low-cardinality data, including api changes to…",CASSANDRA-749,"1. Do local indexes for low-cardinality data, including api changes to expose this.
Among other concerns, Stu mentioned that there might be some indexes with such low  cardinality that an index could be counterproductive. We agreed that in these cases we  should still require that the user declare that they’d like an index, but avoid actually writing  the index until it would be useful.
2. For distributed indexes we should build coprocessors/triggers/callbacks (name TBD)  as a separate project (and separate JIRA).
",,Architectural design configuration,15:357 - 15:879,1,arjan
4:228,jbellis,CASSANDRA-749,jbellis,,Comment,15:1221 - 15:1227,1,arjan
4:135,attached what I think the thrift changes could look like,CASSANDRA-749,attached what I think the thrift changes could look like,,Architectural design configuration,15:1230 - 15:1285,1,arjan
4:229,schubertzhang,CASSANDRA-749,schubertzhang,,Comment,15:1292 - 15:1304,1,arjan
4:136,I think the cassandra project manager should do some feature control.…,CASSANDRA-749," I think the cassandra project manager should do some feature control.
The feature such as this one should be postponed. There are many important things should  be done frstly.
",,"Architectural solution benefits and drawbacks
Assumptions",15:1306 - 15:1484,2,arjan
4:230,stuhood,CASSANDRA-749,stuhood,,Comment,15:1701 - 15:1707,1,arjan
4:137,"If  we’re requiring named indexes, the name should probably be a membe…",CASSANDRA-749," If  we’re requiring named indexes, the name should probably be a member of the IndexClause  object.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",15:1782 - 15:1883,3,arjan
4:138,"Additionally, RowPredicate should probably hold a List<IndexClause> or…",CASSANDRA-749,"Additionally, RowPredicate should probably hold a List<IndexClause> or some other struc-  ture allowing people to AND or OR the clauses.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",15:1884 - 15:2021,3,arjan
4:231,jbellis,CASSANDRA-749,jbellis,,Comment,15:2026 - 15:2032,1,arjan
4:139,"You’re right, IndexClause needs column [name] feld.",CASSANDRA-749,"You’re right, IndexClause needs column [name] feld.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",15:2035 - 15:2087,2,arjan
4:140,Agreed that we will want List<IndexClause> but not sure if we want to…,CASSANDRA-749,"Agreed that we will want List<IndexClause> but not sure if we want to tackle that complex-  ity for this ticket’s scope. Making it a List for forwards-compatibility, but only supporting  a single element to start with, seems reasonable.
",,Architectural solution benefits and drawbacks,15:2088 - 15:2325,1,arjan
4:232,vijay2win@yahoo.com,CASSANDRA-749,vijay2win@yahoo.com,,Comment,15:2330 - 15:2348,1,arjan
4:141,I was watching this ticket... and i think we can do one more thing  to…,CASSANDRA-749, I was watching this ticket... and i think we can do one more thing  to make the local-index more efcient (If the user gives hits)... ,,"Architectural tactics
Assumptions",15:2350 - 15:2483,2,arjan
4:142,"For example: while writing  data the user can say (hint, key) --> whic…",CASSANDRA-749," For example: while writing  data the user can say (hint, key) --> which will be used by the partitioner to keep the data  closer within a range of nodes.... ",,Architectural design configuration,15:2483 - 15:2640,1,arjan
4:143,". While querying if the user gives us the hint like  (Org, valueToSear…",CASSANDRA-749,". While querying if the user gives us the hint like  (Org, valueToSearch) then we know where to search for. Just an interm solution to scale  queries?
",,Architectural solution benefits and drawbacks,15:2742 - 15:2893,1,arjan
4:233,vijay2win@yahoo.com,CASSANDRA-749,vijay2win@yahoo.com,,Comment,16:5 - 16:23,1,arjan
4:144,ProtoType which i did for work..... Version 1 of the changes:  Need to…,CASSANDRA-749,"ProtoType which i did for work..... Version 1 of the changes:  Need to fnd a clean way to have indexCF...
Currently only support Ordered Partitioner... Think internals needs to be changed to have  various partitions...
Supports multiple queries.... AND and OR operations.
",,Existing system architecture description,16:26 - 16:300,1,arjan
4:145,Stream SSTables without Anti-compaction,CASSANDRA-749,Stream SSTables without Anti-compaction,,Quality Attribute requirement,17:57 - 17:95,1,arjan
4:146,"The io.Streaming API currently requires a fle on disk to stream, which…",CASSANDRA-749,"The io.Streaming API currently requires a fle on disk to stream, which means that bootstrap and  repairs need to perform an anti-compaction that writes a bunch of data to disk, only to have it  be deleted after the streaming has fnished.
",,Run-time quality issues,17:115 - 17:353,1,arjan
4:147,EDIT: Deleted reference to using streaming as a client API: it wouldn’…,CASSANDRA-749,"EDIT: Deleted reference to using streaming as a client API: it wouldn’t provide enough bene-  ft over using the BMT interface, due to fragility.
",,Architectural solution benefits and drawbacks,17:354 - 17:499,1,arjan
4:234,jbellis,CASSANDRA-749,jbellis,,Comment,17:900 - 17:906,1,arjan
4:148,"expanding Streaming is fne, but it’s not as straightforward as you mig…",CASSANDRA-749,"expanding Streaming is fne, but it’s not as straightforward as you might think  because it is completely based around FileChannel.transferTo, which on Linux at least is a  thin wrapper around the sendfle system call",,Technical debt,17:909 - 17:1123,1,arjan
4:235,stuhood,CASSANDRA-749,stuhood,,Comment,18:4 - 18:10,1,arjan
4:149,"Bumping priority on this one, because gofnet experienced a repair taki…",CASSANDRA-749,"Bumping priority on this one, because gofnet experienced a repair taking > 24  hours for ~100GB of data.
",,Run-time quality issues,18:13 - 18:117,1,arjan
4:236,lenn0x,CASSANDRA-749,lenn0x,,Comment,18:164 - 18:169,1,arjan
4:150,We see about 16MB/s for compaction on a 4 disk RAID0 confguration.,CASSANDRA-749,We see about 16MB/s for compaction on a 4 disk RAID0 confguration.,,Run-time quality issues,18:172 - 18:237,1,arjan
4:151,"Moving  this directly to network, so we can be network bound",CASSANDRA-749,"Moving  this directly to network, so we can be network bound",,Architectural design configuration,18:239 - 18:298,1,arjan
4:152,would be much better.,CASSANDRA-749,would be much better.,,Architectural solution benefits and drawbacks,18:300 - 18:320,1,arjan
4:153,"But the thing  is, compaction is running slower than the max throughpu…",CASSANDRA-749,"But the thing  is, compaction is running slower than the max throughput on network, which is roughly  80MB/s on our systems.
",,Run-time quality issues,18:322 - 18:446,1,arjan
4:237,jbellis,CASSANDRA-749,jbellis,,Comment,18:451 - 18:457,1,arjan
4:154,What you want to be careful about here is not screwing up the FileChan…,CASSANDRA-749,"What you want to be careful about here is not screwing up the FileChannel.transferTo  optimization which is very valuable.
",,Motivation of design issue,18:460 - 18:583,1,arjan
4:155,"1. use SSTR.getPosition to fnd start and end ranges to transfer, then…",CASSANDRA-749,"1. use SSTR.getPosition to fnd start and end ranges to transfer, then use the existing  streaming API -- which already support streaming only _parts_ of fles via transferTo -- to  send that over as the data fle in question.
2. from the data fle, compute index + BF fles on the destination node, instead of wasting  IO streaming those from the source.
- streaming the index from source is possible, but since you need to scan the data fle anyway  to build BF (since there is no way to extract a subset of a BF) I think it’s going to be simpler  to just rebuild both. And anyway gofnet has wanted a ""rebuild index from data fle"" for a  while now :)",,Architectural design configuration,18:616 - 18:1263,1,arjan
4:156,instead of wasting  IO streaming those from the source.,CASSANDRA-749,"instead of wasting  IO streaming those from the source.
",,Architectural solution benefits and drawbacks,18:912 - 18:968,1,arjan
4:157,I think it’s going to be simpler  to just rebuild both.,CASSANDRA-749,I think it’s going to be simpler  to just rebuild both.,,"Architectural solution benefits and drawbacks
Assumptions",18:1128 - 18:1182,2,arjan
4:238,stuhood,CASSANDRA-749,stuhood,,Comment,18:1269 - 18:1275,1,arjan
4:158,I don’t think this works: you still need to perform the compaction frs…,CASSANDRA-749,"I don’t think this works: you still need to perform the compaction frst, which means you  still need to dump to disk.
EDIT: Unless you are suggesting streaming each SSTable individually?
",,Architectural solution benefits and drawbacks,18:1348 - 18:1536,1,arjan
4:159,This seems like the best approach.,CASSANDRA-749,"This seems like the best approach.
",,Architectural solution benefits and drawbacks,18:1610 - 18:1645,1,arjan
4:239,jbellis,CASSANDRA-749,jbellis,,Comment,18:1649 - 18:1655,1,arjan
4:160,"streaming each range individually (so, one source sstable since you ju…",CASSANDRA-749,"streaming each range individually (so, one source sstable since you just did a major compact,  and each range becomes an sstable on the target)",,Architectural design configuration,18:1724 - 18:1866,1,arjan
4:240,stuhood,CASSANDRA-749,stuhood,,Comment,18:1872 - 18:1878,1,arjan
4:161,"You didn’t necessarily just do a major compaction: currently, when som…",CASSANDRA-749,"You didn’t necessarily just do a major compaction: currently, when someone triggers a repair  manually, it performs a readonly major compaction, which doesn’t write to disk.
",,Existing system architecture description,18:1925 - 18:2099,1,arjan
4:241,jaakko,CASSANDRA-749,jaakko,,Comment,18:2103 - 18:2108,1,arjan
4:162,What if we just stream from individual SSTables directly?,CASSANDRA-749,What if we just stream from individual SSTables directly?,,Architectural design configuration,18:2111 - 18:2167,1,arjan
4:163,That would of course  send some stuf twice (or more) if done without c…,CASSANDRA-749,"That would of course  send some stuf twice (or more) if done without compaction, but that seems like small over-  head. If we streamed directly from SSTables, that would allow us to bootstrap from a node  that is short of disk space.
",,Architectural solution benefits and drawbacks,18:2169 - 18:2403,1,arjan
4:242,stuhood,CASSANDRA-749,stuhood,,Comment,18:2408 - 18:2414,1,arjan
4:164,This idea is growing on me... it causes minimal load on the machine th…,CASSANDRA-749,"This idea is growing on me... it causes minimal load on the machine that you are trying to  move data of of, in terms of CPU and disk (compaction is done on the destination side).
Network bandwidth should be relatively plentiful.
",,Architectural solution benefits and drawbacks,18:2478 - 18:2709,1,arjan
4:243,jbellis,CASSANDRA-749,jbellis,,Comment,18:2714 - 18:2720,1,arjan
4:165,"one side has to compact eventually, so it should be the sending side t…",CASSANDRA-749,"one side has to compact eventually, so it should be the sending side that compacts,  since that gets you reduced bandwidth; there’s no beneft by having receiver compact. it  17
would be quite easy to compact to a socket stream instead of a disk one. (you lose transferTo,  but receiver can still do transferFrom. and we could special case only-a-single-source-sstable  with transferTo if that is worth it...)",,"Architectural design configuration
Architectural solution benefits and drawbacks",18:2723 - 19:231,2,arjan
4:244,jbellis,CASSANDRA-749,jbellis,,Comment,19:238 - 19:244,1,arjan
4:166,Note that if we’re streaming w/o frst writing temporary fle locally,CASSANDRA-749,Note that if we’re streaming w/o frst writing temporary fle locally,,Architectural design configuration,19:247 - 19:313,1,arjan
4:167,"there is less  reason to keep all outbound streaming single-threaded,…",CASSANDRA-749,"there is less  reason to keep all outbound streaming single-threaded, but Streaming contexts currently  assume there can only be one outstanding stream per source node. So keep that in mind if  we are tempted to multithread streaming.
",,Architectural solution benefits and drawbacks,19:315 - 19:550,1,arjan
4:245,stuhood,CASSANDRA-749,stuhood,,Comment,19:555 - 19:561,1,arjan
4:168,I think we should delay making too many changes to streaming until we’…,CASSANDRA-749,"I think we should delay making too many changes to streaming until we’ve  fnalized the SSTable versioning/interface changes proposed on #674. All of the possible  approaches to optimizing this depend on the fle format. For instance, sending only portions  of the fle depends on a splittable format, and performing the compaction on the sending  side and then writing a new SSTable on the receiving side depends on the format of the  serialized CompactedRows that would be sent across.
",,Architectural solution benefits and drawbacks,19:564 - 19:1049,1,arjan
4:246,stuhood,CASSANDRA-749,stuhood,,Comment,19:1054 - 19:1060,1,arjan
4:169,"We can probably resume progress here now that 389 is in, although I ho…",CASSANDRA-749," We can probably resume progress here now that 389 is in, although I hope to get  777 in frst.
",,"Architectural solution benefits and drawbacks
Assumptions",19:1062 - 19:1157,2,arjan
4:247,stuhood,CASSANDRA-749,stuhood,,Comment,19:1162 - 19:1168,1,arjan
4:170,"Tons of people get bitten by this, and everyone else is lagged out by…",CASSANDRA-749,"Tons of people get bitten by this, and everyone else is lagged out by slow transfers.
",,Run-time quality issues,19:1171 - 19:1257,1,arjan
4:248,jbellis,CASSANDRA-749,jbellis,,Comment,19:1262 - 19:1268,1,arjan
4:171,"Given how much cpu the compact part of anticompact chew up, Stu is rig…",CASSANDRA-749,"Given how much cpu the compact part of anticompact chew up, Stu is right that  we shouldn’t do that on the source node. But we shouldn’t do it on the target node, either,  or more precisely, we shouldn’t do it as part of the stream operation and let the operator do  it manually if desired.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",19:1271 - 19:1562,2,arjan
4:172,We should use the row index to fgure out what parts of the source data…,CASSANDRA-749,"We should use the row index to fgure out what parts of the source data fles to stream  over, and send those chunks w/o deserializing anything. On the target side, we should read  the keys but not deserialize anything else, and build the index + bloom flter from that.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",19:1563 - 19:1831,2,arjan
4:249,stuhood,CASSANDRA-749,stuhood,,Comment,19:1836 - 19:1842,1,arjan
4:173,"Here is a patchset for trunk implementing the ""stream matching ranges…",CASSANDRA-749,"Here is a patchset for trunk implementing the ""stream matching ranges from  existing sstables, and then rebuild indexes"" strategy. It applies on top of 1117 (for no good  reason, in retrospect). It passes existing tests, but I haven’t tried it out on a cluster",,Existing system architecture description,19:1845 - 19:2104,1,arjan
4:250,jbellis,CASSANDRA-749,jbellis,,Comment,19:2282 - 19:2288,1,arjan
4:174,I think we do need a better key count estimate. What about reading the…,CASSANDRA-749,"I think we do need a better key count estimate. What about reading the frst 1% (by  size) of the rows, and estimating from that?
Alternatively streamin could actually count the rows as they arrive.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",19:2350 - 19:2549,3,arjan
4:251,jbellis,CASSANDRA-749,jbellis,,Comment,20:5 - 20:11,1,arjan
4:175,"patches 01-03 applied, but I keep getting timeouts trying to commit th…",CASSANDRA-749,"patches 01-03 applied, but I keep getting timeouts trying to commit the rest.
(probably the super faky wireless here.)",,Run-time quality issues,20:14 - 20:132,1,arjan
5:1,Create an additional system keyspace to store KS defnitions and migrat…,CASSANDRA-825,"Create an additional system keyspace to store KS defnitions and migration data.
",,User requirement,3:51 - 3:131,1,arjan
5:2,Create an additional system keyspace to store KS defnitions and migrat…,CASSANDRA-825,"Create an additional system keyspace to store KS defnitions and migration data.Tweak the in-  ternals so cassandra can optional load all defnitions from there, ignoring CF defnitions in the  xml.
",,User requirement,3:149 - 3:345,1,arjan
5:55,jbellis,CASSANDRA-825,jbellis,,Comment,3:778 - 3:784,1,arjan
5:3,Instead of rolling our own uuid generator can we just use http://jug.s…,CASSANDRA-825, Instead of rolling our own uuid generator can we just use http://jug.safehaus.org/,,Other system architectural solutions,3:786 - 3:868,1,arjan
5:4,It appears to be available in maven repos so Ivy should be cool.,CASSANDRA-825," It appears to be available in maven repos so Ivy should be cool.
",,Architectural solution benefits and drawbacks,3:872 - 3:938,1,arjan
5:56,jbellis,CASSANDRA-825,jbellis,,Comment,3:942 - 3:948,1,arjan
5:5,JUG also provides a native library for getting the mac address,CASSANDRA-825, JUG also provides a native library for getting the mac address,,Other system architectural solutions,3:950 - 3:1012,1,arjan
5:6,I’m -1 on putting  mac in the confg since it completely screws the abi…,CASSANDRA-825,"I’m -1 on putting  mac in the confg since it completely screws the ability to run a cluster from a common fle.
",,Architectural solution benefits and drawbacks,3:1015 - 3:1126,1,arjan
5:8,"If we can’t get the mac from native code on platform X, or if it’s pai…",CASSANDRA-825,"If we can’t get the mac from native code on platform X, or if it’s painful,",,Architectural solution benefits and drawbacks,3:1127 - 3:1201,1,arjan
5:7,then let’s make  something up and use it as the mac bytes,CASSANDRA-825,then let’s make  something up and use it as the mac bytes,,Architectural design configuration,3:1203 - 3:1259,1,arjan
5:9,For our purposes one pseudo-unique set of bytes  in the MAC positions…,CASSANDRA-825,For our purposes one pseudo-unique set of bytes  in the MAC positions is as good as another.,,Architectural solution benefits and drawbacks,3:1262 - 3:1353,1,arjan
5:10,Can you give a high-level overview of the the remaining patches are do…,CASSANDRA-825,"Can you give a high-level overview of the the remaining patches are doing?
",,,3:1368 - 3:1443,1,arjan
5:57,gdusbabek,CASSANDRA-825,gdusbabek,,Comment,4:4 - 4:12,1,arjan
5:11,I looked at jug briefy but stopped when I saw native libraries. If the…,CASSANDRA-825,"I looked at jug briefy but stopped when I saw native libraries. If there were a  way to use it and extend it so that native bits aren’t needed, then I’m +1. I prefer to avoid  introducing native libs if we can avoid it, especially for something this trivial. I like the ’put  something else unique in those bytes’ approach.
",,Architectural solution benefits and drawbacks,4:15 - 4:339,1,arjan
5:12,If there were a  way to use it and extend it so that native bits aren’…,CASSANDRA-825,"If there were a  way to use it and extend it so that native bits aren’t needed,",,Other system architectural solutions,4:79 - 4:157,1,arjan
5:13,2-4 modify introduces DefsTable (similar to SystemTable) as a way to m…,CASSANDRA-825,"2-4 modify introduces DefsTable (similar to SystemTable) as a way to modify storing and  loading the data defnitions to the new defnitions keyspace.
5 makes it so that cfd generation is safe across restarts and can happen at times other than  startup.
6 gives support for tracking historical CF names. In the case of cf renames, the id doesn’t  change, but the name does and we need a way to get back to the id when recovering.
The basic idea of the set is that we need to add support for reading data defnitions from  storage and not xml.
",,Architectural design configuration,4:340 - 4:883,1,arjan
5:58,jbellis,CASSANDRA-825,jbellis,,Comment,4:887 - 4:893,1,arjan
5:14,"You can pass the generator an ""EthernetAddress"" containing whatever by…",CASSANDRA-825,"You can pass the generator an ""EthernetAddress"" containing whatever bytes you  want: http://jug.safehaus.org/curr/javadoc/org/safehaus/uuid/UUIDGenerator.html",,Architectural design configuration,4:896 - 4:1053,1,arjan
5:59,jbellis,CASSANDRA-825,jbellis,,Comment,4:1059 - 4:1065,1,arjan
5:15,- public fnal double keyCacheSize; // default 0.01  + public fnal doub…,CASSANDRA-825,"- public fnal double keyCacheSize; // default 0.01  + public fnal double keyCacheFraction; // default 0.01  bad rebase?
",,,4:1068 - 4:1188,1,arjan
5:60,gdusbabek,CASSANDRA-825,gdusbabek,,Comment,4:1192 - 4:1200,1,arjan
5:16,yeah. I’ll clean that up.,CASSANDRA-825,"yeah. I’ll clean that up.
",,,4:1203 - 4:1229,1,arjan
5:61,jbellis,CASSANDRA-825,jbellis,,Comment,4:1233 - 4:1239,1,arjan
5:17,"Can you use less words in parameter / feld names, but spell them out?…",CASSANDRA-825,"Can you use less words in parameter / feld names, but spell them out?
repStratClass -> strategyClass  epSnitch -> snitch  etc.
(for local variable names KSMetaData ksm etc. is fne)  - Can you add a FBUtilities convenience for this?
UUIDGen.makeType1UUID(UUIDGen.fromHost(FBUtilities.getLocalAddress()))",,,4:1244 - 4:1548,1,arjan
5:18,This probably isn’t a good mac address replacment -- since it’s iterat…,CASSANDRA-825,"This probably isn’t a good mac address replacment -- since it’s iterating most-signifcant-  frst, the chance of collision w/in a cluster is basically guaranteed. Which probably isn’t the  end of the world here",,Run-time quality issues,4:1553 - 4:1761,1,arjan
5:19,but it’s not too much more work to run getAddress through md5 frst.,CASSANDRA-825,"but it’s not too much more work to run getAddress through md5 frst.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",4:1763 - 4:1831,2,arjan
5:20,"this is clunky and possibly error-prone (since if we are ""jumping"" the…",CASSANDRA-825,"this is clunky and possibly error-prone (since if we are ""jumping"" the counter higher when  we load a new id? then we might have been generating ""new"" ids that collided with yet-to-  be-read ones)",,Run-time quality issues,4:1916 - 4:2111,1,arjan
5:21,Can we just initialize the counter to the max value at initialization…,CASSANDRA-825,"Can we just initialize the counter to the max value at initialization time?
",,Architectural component behavior and structure,4:2200 - 4:2276,1,arjan
5:22,why do we need historical names? we don’t need it for log replay (only…,CASSANDRA-825,"why do we need historical names? we don’t need it for log replay (only  the current name gets turned into an sstable) and if we’re going to use it to read old sstables  based on timestamp, that’s a mess, we’d need to record not only the name sequence but how  long each name was mapped to the id. ",,Technical debt,5:16 - 5:312,1,arjan
5:24,Wouldn’t it be simpler to,CASSANDRA-825,Wouldn’t it be simpler to,,"Architectural solution benefits and drawbacks
Assumptions",5:313 - 5:337,2,arjan
5:23,name sstable fles by cf ID  instead of name?,CASSANDRA-825,name sstable fles by cf ID  instead of name?,,Architectural component behavior and structure,5:339 - 5:382,1,arjan
5:25,"for old installs a one-time conversion on startup can be done, rename…",CASSANDRA-825,"for old installs a one-time conversion on startup can be done, rename is  fast so it’s ok to do that rather than deal w/ complexity of mixed ids and names, imo].",,Architectural solution benefits and drawbacks,5:385 - 5:545,1,arjan
5:62,gdusbabek,CASSANDRA-825,gdusbabek,,Comment,5:592 - 5:600,1,arjan
5:26,"I might be missing something, but the cfname is one of the serialized…",CASSANDRA-825,"I might be missing something, but the cfname is one of the serialized properties of RowMu-  tation that ends up in the commit log",,Existing system architecture description,5:654 - 5:782,1,arjan
5:27,Since it would be a lot of work to,CASSANDRA-825,Since it would be a lot of work to,,Architectural solution benefits and drawbacks,5:785 - 5:818,1,arjan
5:28,"fush the commit  log prior to a rename,",CASSANDRA-825," fush the commit  log prior to a rename,",,Architectural design configuration,5:819 - 5:858,1,arjan
5:29,we need away to get from the old cfnames to the current id.,CASSANDRA-825,we need away to get from the old cfnames to the current id.,,Motivation of design issue,5:860 - 5:918,1,arjan
5:30,It doesn’t  have anything to do with old sstables.,CASSANDRA-825,"It doesn’t  have anything to do with old sstables.
",,Existing system architecture description,5:920 - 5:971,1,arjan
5:63,jbellis,CASSANDRA-825,jbellis,,Comment,5:976 - 5:982,1,arjan
5:31,"fushing is a lot of work,",CASSANDRA-825,"fushing is a lot of work,",,Architectural solution benefits and drawbacks,5:985 - 5:1009,1,arjan
5:32,but creating a new segment (w/ new header) is not.,CASSANDRA-825,"but creating a new segment (w/ new header) is not.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:1011 - 5:1062,2,arjan
5:64,gdusbabek,CASSANDRA-825,gdusbabek,,Comment,5:1067 - 5:1075,1,arjan
5:33,"Right, and that’s the approach I’ve taken in CASSANDRA-840.",CASSANDRA-825,"Right, and that’s the approach I’ve taken in CASSANDRA-840.",,Existing system architecture description,5:1078 - 5:1136,1,arjan
5:34,But what of  old segments still laying around that may need to be used…,CASSANDRA-825,"But what of  old segments still laying around that may need to be used to recover after a restart? They  still refer to CF names that no longer a rename.
",,Run-time quality issues,5:1138 - 5:1292,1,arjan
5:65,jbellis,CASSANDRA-825,jbellis,,Comment,5:1297 - 5:1303,1,arjan
5:35,each segment has a header w/ a name -> id map [currently you have id -…,CASSANDRA-825,"each segment has a header w/ a name -> id map [currently you have id -> name  but just make it a BiMap] so you use that to get the id for the RM cfname.
",,Existing system architecture description,5:1306 - 5:1459,1,arjan
5:36,"either way we need to change Table.apply to take a Map<name, id> repre…",CASSANDRA-825,"either way we need to change Table.apply to take a Map<name, id> representing what  the mapping was at the time of the RM so it can put it in the right CFS [not necessarily in  this patchset]. I’m saying it’s simpler to just use the one you already have in the CLH than  build one up laboriously from binary-searched timestams.
",,Architectural solution benefits and drawbacks,5:1460 - 5:1788,1,arjan
5:66,gdusbabek,CASSANDRA-825,gdusbabek,,Comment,5:1793 - 5:1801,1,arjan
5:37,CLH maps ids to dirty bits and fush points--no names.,CASSANDRA-825,CLH maps ids to dirty bits and fush points--no names.,,Architectural solution benefits and drawbacks,5:1804 - 5:1856,1,arjan
5:38,"If we modifed RM to  contain a name->id map,",CASSANDRA-825,"If we modifed RM to  contain a name->id map, ",,Architectural component behavior and structure,5:1858 - 5:1902,1,arjan
5:39,we’d be in good shape and could get rid of the historical names.,CASSANDRA-825,"we’d be in good shape and could get rid of the historical names.
",,Architectural solution benefits and drawbacks,5:1903 - 5:1968,1,arjan
5:40,What I’ve done (and don’t care for) in 840 is modify the CF during rec…,CASSANDRA-825,"What I’ve done (and don’t care for) in 840 is modify the CF during recovery if it is de-  tected that the name has changed (can’t fnd an id). This is error-prone because if a user  has a habit of recycling cfnames over time, the reverse mapping can become ambiguous.
",,Run-time quality issues,5:1969 - 5:2236,1,arjan
5:41,I’ll make a change so that the cfd can be had from the RM as opposed t…,CASSANDRA-825,"I’ll make a change so that the cfd can be had from the RM as opposed to table.
",,Architectural design configuration,5:2237 - 5:2316,1,arjan
5:67,jbellis,CASSANDRA-825,jbellis,,Comment,5:2321 - 5:2327,1,arjan
5:42,"You’re right, I was thinking CLH had an id -> name map already.",CASSANDRA-825,"You’re right, I was thinking CLH had an id -> name map already.
",,Architectural solution benefits and drawbacks,5:2330 - 5:2394,1,arjan
5:43,"We defnitely don’t want to put an entire name/id map in RM though,",CASSANDRA-825,"We defnitely don’t want to put an entire name/id map in RM though,",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:2395 - 5:2460,2,arjan
5:68,gdusbabek,CASSANDRA-825,gdusbabek,,Comment,5:2492 - 5:2500,1,arjan
5:44,"No, I meant RM, but now that I think of it, CLH is a better place. The…",CASSANDRA-825,"No, I meant RM, but now that I think of it, CLH is a better place. The only  down-side that it needs the entire mapping because its size needs to be fxed and its size no  longer becomes a function of the number of cfs. But I think that’s manageable.
",,"Architectural solution benefits and drawbacks
Assumptions",5:2503 - 5:2753,2,arjan
5:69,jbellis,CASSANDRA-825,jbellis,,Comment,5:2758 - 5:2764,1,arjan
5:45,size needs to be fxed [per CLH] -- right,CASSANDRA-825,size needs to be fxed [per CLH] -- right,,Architectural component behavior and structure,5:2767 - 5:2806,1,arjan
5:47,no longer function of # of cfs -- ?,CASSANDRA-825,no longer function of # of cfs -- ?,,Architectural design configuration,5:2809 - 5:2843,1,arjan
5:70,gdusbabek,CASSANDRA-825,gdusbabek,,Comment,5:2850 - 5:2858,1,arjan
5:46,At some  point I was relying on the fact that I could know the size of…,CASSANDRA-825,"At some  point I was relying on the fact that I could know the size of the CLH given the number of  CFs. But I got rid of that at some point.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:2930 - 5:3072,2,arjan
5:71,jbellis,CASSANDRA-825,jbellis,,Comment,5:3077 - 5:3083,1,arjan
5:48,"So for 825, the plan is drop patch 5, make the other tweaks I mentione…",CASSANDRA-825,"So for 825, the plan is drop patch 5, make the other tweaks I mentioned, and then  make the CLH changes as part of 840?
",,,5:3086 - 5:3206,1,arjan
5:72,gdusbabek,CASSANDRA-825,gdusbabek,,Comment,5:3211 - 5:3219,1,arjan
5:49,Correct.,CASSANDRA-825,"Correct.
",,,5:3222 - 5:3231,1,arjan
5:73,jbellis,CASSANDRA-825,jbellis,,Comment,6:5 - 6:11,1,arjan
5:50,wrapping an AtomicInteger w/ synchronized isn’t the end of the world b…,CASSANDRA-825,"wrapping an AtomicInteger w/ synchronized isn’t the end of the world but it’s kind of  ugly.
",,Architectural solution benefits and drawbacks,6:40 - 6:133,1,arjan
5:51,wrapping an AtomicInteger w/ synchronized,CASSANDRA-825,wrapping an AtomicInteger w/ synchronized,,Architectural component behavior and structure,6:40 - 6:80,1,arjan
5:52,Maybe using a wrapper class like in CommitLog to avoid explicit synchr…,CASSANDRA-825,"Maybe using a wrapper class like in CommitLog to avoid explicit synchronization but still  getting laziness would work here instead?
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",6:134 - 6:267,2,arjan
5:74,gdusbabek,CASSANDRA-825,gdusbabek,,Comment,6:272 - 6:280,1,arjan
5:53,Removed unnecessary locking. fxMaxId() doesn’t need to be called until…,CASSANDRA-825,"Removed unnecessary locking. fxMaxId() doesn’t need to be called until we  are loading from storage. When loading from XML, the counter starts at 0 and works its  way up (it’s reset every restart).
",,Existing system architecture description,6:283 - 6:481,1,arjan
5:54,+1,CASSANDRA-825,+1,,,6:495 - 6:496,1,arjan
6:1,Implement a replication strategy for the KS that holds KS/CF defnition…,CASSANDRA-826,"Implement a replication strategy for the KS that holds KS/CF defnitions.
",,User requirement,3:51 - 3:124,1,arjan
6:2,Implement a replication strategy for the KS that holds KS/CF defnition…,CASSANDRA-826,"Implement a replication strategy for the KS that holds KS/CF defnitions.
It ignores replication factor and replicates to all nodes.
",,User requirement,3:142 - 3:275,1,arjan
6:14,jbellis,CASSANDRA-826,jbellis,,Comment,3:494 - 3:500,1,arjan
6:3,"metadata.getEndpoints won’t include bootstrapping nodes though, will i…",CASSANDRA-826,"metadata.getEndpoints won’t include bootstrapping nodes though, will it?
",,"Architectural design configuration
Assumptions",3:503 - 3:576,2,arjan
6:4,"speaking of bootstrapping nodes, this approach of ""just use a Strategy…",CASSANDRA-826,"speaking of bootstrapping nodes, this approach of ""just use a Strategy that replicates ev-  erywhere"" means you have to send a mutation containing the whole, most-recent-schema at  once, right?",,"Architectural design configuration
Assumptions",3:577 - 3:769,2,arjan
6:5,"which I think is okay, just want to make sure.",CASSANDRA-826,"which I think is okay, just want to make sure.",,Architectural solution benefits and drawbacks,3:772 - 3:817,1,arjan
6:15,gdusbabek,CASSANDRA-826,gdusbabek,,Comment,3:824 - 3:832,1,arjan
6:6,"That’s one way of doing it, but the more I’ve thought about it and wor…",CASSANDRA-826,"That’s one way of doing it, but the more I’ve thought about it and worked on  it, I’m not sure that replicating everywhere is the best approach.",,"Architectural solution benefits and drawbacks
Assumptions",3:835 - 3:978,2,arjan
6:7,I prefer using a pure gossip  approach: NodeA has schema updated via t…,CASSANDRA-826,"I prefer using a pure gossip  approach: NodeA has schema updated via thrift, makes local changes and then gossips it  to all nodes. Those nodes realize they are on an older version and request all migrations  between their versions and the version that was gossiped. The migrations are then applied.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",3:980 - 3:1280,2,arjan
6:8,The main advantage is that it is a one-size-fts all approach: it works…,CASSANDRA-826,"The main advantage is that it is a one-size-fts all approach: it works for a live cluster,  it works for a bootstrapping node (re: your comment), it works for a node coming back into  the cluster.
2
It also avoids any synchronization issues involved with a mutation arriving after the ver-  sion is gossiped.",,Architectural solution benefits and drawbacks,3:1281 - 4:109,1,arjan
6:16,jbellis,CASSANDRA-826,jbellis,,Comment,4:115 - 4:121,1,arjan
6:9,if we’re going w/ a pull model (each node is responsible for requestin…,CASSANDRA-826,"if we’re going w/ a pull model (each node is responsible for requesting changes)  then why do we need this new Strategy? (which is only useful for a push model, unless I am  missing something)",,"Architectural solution benefits and drawbacks
Assumptions",4:124 - 4:315,2,arjan
6:17,gdusbabek,CASSANDRA-826,gdusbabek,,Comment,4:321 - 4:329,1,arjan
6:10,you’re not missing anything. I’ve been experimenting with both and am…,CASSANDRA-826,"you’re not missing anything. I’ve been experimenting with both and am  leaning towards pull, in which case, this strategy is not needed.
",,Architectural solution benefits and drawbacks,4:332 - 4:469,1,arjan
6:18,jbellis,CASSANDRA-826,jbellis,,Comment,4:473 - 4:479,1,arjan
6:11,"I like the simplicity of the ReplicationStrategy approach, but the cor…",CASSANDRA-826,"I like the simplicity of the ReplicationStrategy approach, but the corner cases (e.g.
bootstrapping) are a bitch. So I think I lean towards pull too.
",,Trade-offs,4:482 - 4:633,1,arjan
6:19,gdusbabek,CASSANDRA-826,gdusbabek,,Comment,4:637 - 4:645,1,arjan
6:12,We will not use a replication strategy to maintain the schema keyspace…,CASSANDRA-826,"We will not use a replication strategy to maintain the schema keyspace.
",,Architectural solution benefits and drawbacks,4:648 - 4:720,1,arjan
6:20,gdusbabek,CASSANDRA-826,gdusbabek,,Comment,4:724 - 4:732,1,arjan
6:13,I decided not to take this approach.,CASSANDRA-826,"I decided not to take this approach.
",,Architectural solution benefits and drawbacks,4:735 - 4:771,1,arjan
7:1,Add hooks that recognize when system KS is updated.,CASSANDRA-827,Add hooks that recognize when system KS is updated.,,User requirement,3:51 - 3:101,1,arjan
7:2,Add hooks that recognize when system KS is updated.,CASSANDRA-827,"Add hooks that recognize when system KS is updated.
",,User requirement,3:121 - 3:173,1,arjan
7:3,"Figure out the best way to refresh the collections in DD, perform the…",CASSANDRA-827,"Figure out the best way to refresh the collections in DD, perform the adds, deletes, etc",,Motivation of design issue,3:174 - 3:261,1,arjan
7:44,gdusbabek,CASSANDRA-827,gdusbabek,,Comment,3:937 - 3:945,1,arjan
7:4,"Before I go down this path, I want to make sure I have the thrift chan…",CASSANDRA-827,"Before I go down this path, I want to make sure I have the thrift changes  basically right.
",,Motivation of design issue,3:948 - 3:1039,1,arjan
7:45,jbellis,CASSANDRA-827,jbellis,,Comment,3:1044 - 3:1050,1,arjan
7:5,void add_column_family_defnition(1:required CfDef cf_def)  shouldn’t t…,CASSANDRA-827,"void add_column_family_defnition(1:required CfDef cf_def)  shouldn’t this take a KS arg too?
",,Technical debt,3:1053 - 3:1145,1,arjan
7:46,jbellis,CASSANDRA-827,jbellis,,Comment,4:4 - 4:10,1,arjan
7:6,"how do we reconcile this with the ""login to keyspace before doing stuf…",CASSANDRA-827,"how do we reconcile this with the ""login to keyspace before doing stuf"" authentication  change? ",,Motivation of design issue,4:57 - 4:152,1,arjan
7:7,"should we require logging in to the system keyspace, before doing allo…",CASSANDRA-827," should we require logging in to the system keyspace, before doing allowing schema  modifcations?
",,Architectural design configuration,4:152 - 4:250,1,arjan
7:8,"should we prefx these methods with system_ or something to denote ""not…",CASSANDRA-827,"should we prefx these methods with system_ or something to denote ""not normal data  modifcation stuf?""",,Architectural design configuration,4:251 - 4:352,1,arjan
7:47,gdusbabek,CASSANDRA-827,gdusbabek,,Comment,4:358 - 4:366,1,arjan
7:9,"Yes, I think this is a good idea.",CASSANDRA-827,"Yes, I think this is a good idea.
",,Architectural solution benefits and drawbacks,4:483 - 4:516,1,arjan
7:10,sure. I’ll all ’system_’ and drop ’_defnition’ from the method names.,CASSANDRA-827,"sure. I’ll all ’system_’ and drop ’_defnition’ from the method names.
",,Architectural solution benefits and drawbacks,4:576 - 4:646,1,arjan
7:48,gdusbabek,CASSANDRA-827,gdusbabek,,Comment,4:650 - 4:658,1,arjan
7:11,0002 refactors DefsTable heavily. Each operation is broken out to its…,CASSANDRA-827,"0002 refactors DefsTable heavily. Each operation is broken out to its own  class that can be serialized and moved to other nodes. It also introduces the concept of a  ’migration,’ which is a schema operation (add|drop|rename cf|ks).
",,Existing system architecture description,4:661 - 4:894,1,arjan
7:12,0004 changes gossip to that it includes the schema version. It brings…,CASSANDRA-827,0004 changes gossip to that it includes the schema version. It brings back the DefsTable  executor as a stage on which migrations are executed. A seed node is instructed to wait  (same as load balance waiting period) so that it can contact other seed nodes for updated  schemas before it begins serving requests.,,Existing system architecture description,4:895 - 4:1206,1,arjan
7:13,0006 changes startup to always load schema from the system tables. The…,CASSANDRA-827,"0006 changes startup to always load schema from the system tables. The load-from-xml  code was kept around to help with transition and exposed in JMX. We can remove this in  a release or two. The java unit tests still load schema from xml.
",,Existing system architecture description,4:1209 - 4:1449,1,arjan
7:14,The load-from-xml  code was kept around to help with transition and ex…,CASSANDRA-827,The load-from-xml  code was kept around to help with transition and exposed in JMX,,Architectural solution benefits and drawbacks,4:1276 - 4:1357,1,arjan
7:15,0007 implements the stubbed thrift methods. The nosetests use them to…,CASSANDRA-827,"0007 implements the stubbed thrift methods. The nosetests use them to establish a testing  schema.
",,Existing system architecture description,4:1450 - 4:1549,1,arjan
7:16,0008 alters the write path so that the cfd is used to determine which…,CASSANDRA-827,0008 alters the write path so that the cfd is used to determine which CFS is written to  during normal writes and CL recovery. CF names are still used (extensively--I didn’t have  the guts to push this through all the way) for other operations.,,Existing system architecture description,4:1550 - 4:1793,1,arjan
7:17,I’m not happy with Ta-  ble.cfNameMap but don’t see an alternative tha…,CASSANDRA-827,"I’m not happy with Ta-  ble.cfNameMap but don’t see an alternative that doesn’t require touching *a lot* of code.
",,Architectural solution benefits and drawbacks,4:1795 - 4:1909,1,arjan
7:49,jbellis,CASSANDRA-827,jbellis,,Comment,4:1913 - 4:1919,1,arjan
7:18,Looks pretty good to me!,CASSANDRA-827,"Looks pretty good to me!
",,Architectural solution benefits and drawbacks,4:1922 - 4:1946,1,arjan
7:19,02: Can we provide a .serializer().de/serialize interface to the Migra…,CASSANDRA-827,"02: Can we provide a .serializer().de/serialize interface to the Migrations, instead of get-  Bytes, for consistency w/ the other code?",,Architectural design configuration,4:1950 - 4:2084,1,arjan
7:20,"Alternatively, we could move that stuf into a  Thrift class; rolling t…",CASSANDRA-827,"Alternatively, we could move that stuf into a  Thrift class; rolling that stuf by hand is something I’d like to move away from.",,Architectural design configuration,4:2087 - 4:2213,1,arjan
7:21,04: the requesting of CF defnitions looks like it should be done in a…,CASSANDRA-827,"04: the requesting of CF defnitions looks like it should be done in a gossip listener,  not directly in Gossiper. we shouldn’t have to modify Gossiper internals at all; the CF  defs should go in a new applicationstate, and someone (KSMetaData?) should register an  onChange listener that does the requesting of updates.
",,Technical debt,4:2219 - 4:2539,1,arjan
7:22,"""seed nodes should try to get schema updates from other seed nodes bef…",CASSANDRA-827,"""seed nodes should try to get schema updates from other seed nodes before going into normal  mode"" seems like complexity that doesn’t really buy us much.
I’m not sure what ""don’t bootstrap if there are no tables defned"" gets us either.
",,Technical debt,4:2540 - 4:2777,1,arjan
7:23,we should make a best efort to push the migration out to all live node…,CASSANDRA-827,"we should make a best efort to push the migration out to all live nodes, and let dead  or partitioned ones catch up via the gossip method.",,Architectural design configuration,4:2778 - 4:2915,1,arjan
7:24,relying entirely on gossip makes propa-  3gation pretty slow even when…,CASSANDRA-827,"relying entirely on gossip makes propa-  3
gation pretty slow even when cluster is entirely healthy",,Architectural solution benefits and drawbacks,4:2917 - 5:56,1,arjan
7:25,"08: if RowMutation is still using strings instead of cfds, doesn’t tha…",CASSANDRA-827,"08: if RowMutation is still using strings instead of cfds, doesn’t that leave us vulnera-  ble to the bug discussed earlier where it gets applied to the wrong CF after a rename?
",,"Assumptions
Run-time quality issues",5:176 - 5:354,2,arjan
7:50,gdusbabek,CASSANDRA-827,gdusbabek,,Comment,5:358 - 5:366,1,arjan
7:26,02: I’ll pass on the thrift class stuf. I must be the only person who…,CASSANDRA-827,"02: I’ll pass on the thrift class stuf. I must be the only person who fnds  ICompactSerializer<T> overwrought.
",,Architectural solution benefits and drawbacks,5:369 - 5:480,1,arjan
7:27,My intent was to ensure that seeds have updated schemas before they st…,CASSANDRA-827,"My intent was to ensure that seeds have updated schemas before they start doing their jobs  in order for them to transmit that data to new nodes since the seeds are contacted frst.
If that comes out, the worst case is that it takes another gossip round or two before the  new nodes fne someone with the most current schema. In retrospect, I think you’re right--  probably over complex.
",,"Assumptions
Technical debt",5:628 - 5:1015,2,arjan
7:28,SS.fnishBootstrapping() was only ever called via removeBootstrapSource…,CASSANDRA-827,"SS.fnishBootstrapping() was only ever called via removeBootstrapSource(). And when there  are no tables, there are no bootstrap sources to remove (streaming never fnishes). Detecting  this condition and avoiding the wait ",,Architectural design configuration,5:1066 - 5:1286,1,arjan
7:29,seemed like the best course to take.,CASSANDRA-827,"seemed like the best course to take.
",,Architectural solution benefits and drawbacks,5:1287 - 5:1324,1,arjan
7:30,08: The critical parts were Table.apply and CL.recover. Both of those…,CASSANDRA-827,08: The critical parts were Table.apply and CL.recover. Both of those are handled. The use  of QueryPath makes RowMutation somewhat vulnerable no matter what.,,Run-time quality issues,5:1325 - 5:1482,1,arjan
7:31,There isn’t a lot  we can do there besides using cfds throughout.,CASSANDRA-827,"There isn’t a lot  we can do there besides using cfds throughout.
",,Architectural design configuration,5:1484 - 5:1550,1,arjan
7:51,jbellis,CASSANDRA-827,jbellis,,Comment,5:1554 - 5:1560,1,arjan
7:32,"makes sense, +1",CASSANDRA-827,"makes sense, +1",,Architectural solution benefits and drawbacks,5:1651 - 5:1665,1,arjan
7:33,"Yeah, I think that’s ultimate what we want to do. No?",CASSANDRA-827,"Yeah, I think that’s ultimate what we want to do. No?",,"Architectural solution benefits and drawbacks
Assumptions",5:1737 - 5:1789,2,arjan
7:34,I don’t see either the new ANNOUNCE verb or a gossip onchange in patch…,CASSANDRA-827,"I don’t see either the new ANNOUNCE verb or a gossip onchange in patch 04, I  guess those are going to be in other tickets?
",,,5:1838 - 5:1962,1,arjan
7:35,Looks like I merged it into 02. See Migration.announce().,CASSANDRA-827," Looks like I merged it into 02. See Migration.announce().
",,,5:1977 - 5:2036,1,arjan
7:52,jbellis,CASSANDRA-827,jbellis,,Comment,5:2041 - 5:2047,1,arjan
7:36,Is there a way we could get the defsVersion stuf to go in SystemTable.…,CASSANDRA-827,"Is there a way we could get the defsVersion stuf to go in SystemTable.StorageMetadata  (a singleton that StorageService keeps a reference to) instead of DatabaseDescriptor, which  is only for user-confgurable stuf?
",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:2050 - 5:2265,2,arjan
7:53,gdusbabek,CASSANDRA-827,gdusbabek,,Comment,5:2270 - 5:2278,1,arjan
7:37,Not easily.,CASSANDRA-827,Not easily.,,Architectural solution benefits and drawbacks,5:2281 - 5:2291,1,arjan
7:38,The current defsVersion needs to be known long before Storage-  Servic…,CASSANDRA-827,"The current defsVersion needs to be known long before Storage-  Service (and SystemMetadata) is initialized. I rearranged things so that DD keeps track of  the initial version (from a schema load or whatever) and passes it to SS. Its all in v3-0009.
From then on, SS is queried/updated when the uuid version is needed.
",,Existing system architecture description,5:2293 - 5:2613,1,arjan
7:39,I also fxed a rename bug where the replication strategy wasn’t getting…,CASSANDRA-827,"I also fxed a rename bug where the replication strategy wasn’t getting reloaded (in case  it changed as a result of a drop+add).
",,Existing system architecture description,5:2614 - 5:2743,1,arjan
7:54,jbellis,CASSANDRA-827,jbellis,,Comment,5:2748 - 5:2754,1,arjan
7:40,Hmm. Having it in two places seems worse than having it in DD.,CASSANDRA-827,"Hmm. Having it in two places seems worse than having it in DD.
",,Architectural solution benefits and drawbacks,5:2757 - 5:2820,1,arjan
7:41,The problem is it’s not obvious to someone browsing that calling DD.sT…,CASSANDRA-827,"The problem is it’s not obvious to someone browsing that calling DD.sTD alone will leave  the system in an inconsistent state. Let’s go with the DD-only code.
",,Architectural solution benefits and drawbacks,6:1 - 6:160,1,arjan
7:42,Removed 0009. replication strategy reload change is rebased into 0002.…,CASSANDRA-827," Removed 0009. replication strategy reload change is rebased into 0002. Ev-  erything is is the same.
",,,6:175 - 6:277,1,arjan
7:43,+1,CASSANDRA-827,+1,,,6:291 - 6:292,1,arjan
8:1,Add the ability to add/remove/rename column families on a single node.,CASSANDRA-840,"Add the ability to add/remove/rename column families on a single node.
",,User requirement,3:51 - 3:122,1,arjan
8:2,We need the ability to manipulate the KS/CF defnitions structures in D…,CASSANDRA-840,"We need the ability to manipulate the KS/CF defnitions structures in DatabaseDescriptor.
",,User requirement,3:140 - 3:229,1,arjan
8:41,gdusbabek,CASSANDRA-840,gdusbabek,,Comment,3:715 - 3:723,1,arjan
8:3,Gives the ability to add/remove/rename CFs on a single node,CASSANDRA-840,Gives the ability to add/remove/rename CFs on a single node,,User requirement,3:726 - 3:784,1,arjan
8:4,A table_open  lock was introduced to prevent tables from being opened…,CASSANDRA-840,A table_open  lock was introduced to prevent tables from being opened during operations (I realize this  doesn’t help terribly much if you already have a table reference),,Run-time quality issues,3:787 - 3:956,1,arjan
8:5,The last patch includes an  alternate approach that makes it so that o…,CASSANDRA-840,"The last patch includes an  alternate approach that makes it so that only the table being operated on is locked during  an operation.
CF ids now live in two places: CFMetaData and CommitLogHeader. the ids in CLH are  stored in serialized state and are only used during recovery.
",,Existing system architecture description,3:959 - 3:1239,1,arjan
8:42,jbellis,CASSANDRA-840,jbellis,,Comment,4:4 - 4:10,1,arjan
8:6,What problem is the table locking trying to solve? Just concurrent acc…,CASSANDRA-840,What problem is the table locking trying to solve? Just concurrent access to  columnFamilyStores_?,,"Assumptions
Run-time quality issues",4:13 - 4:110,2,arjan
8:7,If it is that then using a NBHM instead should be cleaner. I’ve  alway…,CASSANDRA-840,"If it is that then using a NBHM instead should be cleaner. I’ve  always intended to refactor CFS to have a Table reference rather than a Table String.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",4:112 - 4:263,2,arjan
8:43,gdusbabek,CASSANDRA-840,gdusbabek,,Comment,4:267 - 4:275,1,arjan
8:8,Two threads modifying a keyspace at the same time. The lock is held du…,CASSANDRA-840,"Two threads modifying a keyspace at the same time. The lock is held during the entire  mutation, not just to get access to the Table object. ",,Run-time quality issues,4:331 - 4:471,1,arjan
8:9,I’m not opposed to removing the  openLock from Table.open() for perfor…,CASSANDRA-840,"I’m not opposed to removing the  openLock from Table.open() for performance reasons, but I thought it made sense from a  concurrency standpoint (we were synchronizing on Table.class anyway).",,"Architectural tactics
Assumptions",4:472 - 4:661,2,arjan
8:10,We might wish to  chose performance here and assume people deserve wha…,CASSANDRA-840,We might wish to  chose performance here and assume people deserve what they get when they attempt row  mutations while a keyspace is in fux.),,"Assumptions
Trade-offs",4:663 - 4:804,2,arjan
8:44,jbellis,CASSANDRA-840,jbellis,,Comment,4:810 - 4:816,1,arjan
8:11,Okay. I don’t know that it’s worth using a re-entrant lock (since both…,CASSANDRA-840,Okay. I don’t know that it’s worth using a re-entrant lock (since both read locking  and write are Rare Events) but that’s not a big deal.,,"Architectural solution benefits and drawbacks
Assumptions",4:819 - 4:956,2,arjan
8:12,I do think that Multilock is defnitely  overkill.,CASSANDRA-840,"I do think that Multilock is defnitely  overkill.
",,"Architectural solution benefits and drawbacks
Assumptions",4:958 - 4:1008,2,arjan
8:13,It’s safe for other threads to be messing about with existing Table re…,CASSANDRA-840,It’s safe for other threads to be messing about with existing Table references during a mutate  right?,,"Assumptions
Existing system architecture description",4:1009 - 4:1110,2,arjan
8:14,Because using  double-checked locking in Table.open means that most of…,CASSANDRA-840,"Because using  double-checked locking in Table.open means that most of the time that’s what you’re going  to get.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",4:1186 - 4:1300,2,arjan
8:15,If it’s not let’s see if we can come up with a way to use Concurrent o…,CASSANDRA-840,If it’s not let’s see if we can come up with a way to use Concurrent operations instead  of trying to lock everyone.,,Architectural design configuration,4:1301 - 4:1416,1,arjan
8:16,I think it’s doable -,CASSANDRA-840,I think it’s doable -,,"Architectural solution benefits and drawbacks
Assumptions",4:1418 - 4:1438,2,arjan
8:17,"if we move the modifcations themselves to  an executor queue, then you…",CASSANDRA-840," if we move the modifcations themselves to  an executor queue, then you don’t have to worry about them stomping on each other and  you only have to make sure you don’t expose changes to the rest of the systems via the CFS  map until they are ready.
",,Architectural design configuration,4:1440 - 4:1689,1,arjan
8:45,gdusbabek,CASSANDRA-840,gdusbabek,,Comment,4:1693 - 4:1701,1,arjan
8:18,"No. It’s very unsafe. ThreadA calls Table.open(A), ThreadB drops a CF…",CASSANDRA-840,"No. It’s very unsafe. ThreadA calls Table.open(A), ThreadB drops a CF in A, ThreadA then  tries to mutate rows on that CF. At some point ThreadB will cause that table to release()  and its column families go away.",,Existing system architecture description,4:1809 - 4:2021,1,arjan
8:19,I’m not sure what the right behavior is in this case (loud  failure IM…,CASSANDRA-840,"I’m not sure what the right behavior is in this case (loud  failure IMO). That table essentially becomes invalid and will be replaced in Table.instances  with a new version.
",,"Assumptions
Existing system architecture description",4:2023 - 4:2196,2,arjan
8:20,Is that a bad approach? Possibly,CASSANDRA-840,Is that a bad approach? Possibly,,Architectural solution benefits and drawbacks,4:2198 - 4:2229,1,arjan
8:21,I was hoping to avoid having to discover all the states in  CFS that I…,CASSANDRA-840,"I was hoping to avoid having to discover all the states in  CFS that I would have to account for when a CF def is mutated. CFS wasn’t designed from  that standpoint and I think getting it there would be an onerous task.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",4:2232 - 4:2452,3,arjan
8:22,I think a fair compromise would be to mark Table instances invalid whe…,CASSANDRA-840,"I think a fair compromise would be to mark Table instances invalid when they are released  and have them throw an exception in apply() to indicate the reference has been invalidated  and can no longer be operated on (I’m thinking in the context of renames, which are the  most complicated, but this approach makes the most sense in the context of deletes).
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",4:2453 - 4:2810,3,arjan
8:46,gdusbabek,CASSANDRA-840,gdusbabek,,Comment,4:2814 - 4:2822,1,arjan
8:23,My idea was to lock a table during a defnition mutation in order to pr…,CASSANDRA-840,"My idea was to lock a table during a defnition mutation in order to prevent a row mutation  from happening in progress. I still think we need this. And I think a per-table lock gives us  more availability than a global table open lock.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",4:2922 - 4:3158,3,arjan
8:24,I took a look at the code and since all row mutations go through RowMu…,CASSANDRA-840,"I took a look at the code and since all row mutations go through RowMutation.apply(),",,Existing system architecture description,4:3159 - 4:3243,1,arjan
8:25,we’re in good shape for this,CASSANDRA-840,we’re in good shape for this,,Architectural solution benefits and drawbacks,4:3246 - 4:3273,1,arjan
8:26,I couldn’t fnd any code that hangs on to Table objects and  calls Tabl…,CASSANDRA-840,"I couldn’t fnd any code that hangs on to Table objects and  calls Table.apply() at various times (although nothing in the code prevents this).
",,Architectural solution benefits and drawbacks,4:3276 - 4:3419,1,arjan
8:27,This makes sense.,CASSANDRA-840,"This makes sense.
",,Architectural solution benefits and drawbacks,5:120 - 5:138,1,arjan
8:47,jbellis,CASSANDRA-840,jbellis,,Comment,5:142 - 5:148,1,arjan
8:28,"You’re using a read/write lock already pre-Multilock (iirc), so the on…",CASSANDRA-840,"You’re using a read/write lock already pre-Multilock (iirc), so the only time Multilock mat-  ters is allowing writes to continue in KS X while modifying KS Y. Modifcation is rare  enough, and over fast enough, that this isn’t worth adding complexity for, especially when  it’s complexity w/ a performance penalty.
",,Trade-offs,5:390 - 5:705,1,arjan
8:29,"Again, it’s worth pointing out that using double-checked locking in Ta…",CASSANDRA-840,"Again, it’s worth pointing out that using double-checked locking in Table.open completely  bypasses the lock for existing Table objects.",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:707 - 5:842,2,arjan
8:30,Having talked about locking strategies I will now go back to arguing t…,CASSANDRA-840,Having talked about locking strategies I will now go back to arguing that this is a solu-  tion to the wrong question. (If you are on that page already I apologize for continuing to  beat that horse. :),,Architectural solution benefits and drawbacks,5:846 - 5:1047,1,arjan
8:31,RM.apply is very very performance critical. I don’t want to add extra…,CASSANDRA-840,"RM.apply is very very performance critical. I don’t want to add extra locking there, es-  pecially not read/write lock which is more expensive.
",,Architectural solution benefits and drawbacks,5:1050 - 5:1194,1,arjan
8:32,As long as we are corruption-safe in the pedantic concurrency sense we…,CASSANDRA-840,"As long as we are corruption-safe in the pedantic concurrency sense we shouldn’t worry about  mutations during schema modifcation. (Hence, I suspect that we do need to single-thread  these to avoid potential bugs w/ renames.)",,Motivation of design issue,5:1195 - 5:1419,1,arjan
8:33,"The only op that is potentially problematic is  a CF or KS rename, whe…",CASSANDRA-840,"The only op that is potentially problematic is  a CF or KS rename, where ops that come in during the process can apply to the ""wrong""  one. But the same thing will happen to ops against the new name that get sent a ms or  two earlier no matter what you do locking-wise. In other words, the client needs to quiesce  that target himself anyway, so us locking during the actual fraction of a ms for the change  doesn’t really buy him anything.
",,Motivation of design issue,5:1421 - 5:1862,1,arjan
8:48,gdusbabek,CASSANDRA-840,gdusbabek,,Comment,5:1866 - 5:1874,1,arjan
8:34,It took all my restraint to resist the urge to grab Table.fusherLock d…,CASSANDRA-840,"It took all my restraint to resist the urge to grab Table.fusherLock during  the Table.[add|drop|rename]Cf() operations. Also, not included in this patchset, but in my  branch, is a null check against the CFS during Table.apply().
",,Existing system architecture description,5:1877 - 5:2108,1,arjan
8:49,jbellis,CASSANDRA-840,jbellis,,Comment,5:2112 - 5:2118,1,arjan
8:35,"does it tolerate the case of ""cf is added, but CLS w/ the new entry is…",CASSANDRA-840," does it tolerate the case of ""cf is added, but CLS w/ the new entry is not created  yet"" w/o blowing up? (should just log No Such CF Yet or some such imo)",,"Architectural solution benefits and drawbacks
Assumptions",5:2120 - 5:2274,2,arjan
8:50,gdusbabek,CASSANDRA-840,gdusbabek,,Comment,5:2281 - 5:2289,1,arjan
8:36,A new CF isn’t considered to be added until the CLS is ready to go. An…,CASSANDRA-840,"A new CF isn’t considered to be added until the CLS is ready to go. And the  table defnitions aren’t updated with the new cf until after that happens. So we are covered.
",,"Architectural solution benefits and drawbacks
Existing system architecture description",5:2292 - 5:2462,2,arjan
8:51,jbellis,CASSANDRA-840,jbellis,,Comment,5:2467 - 5:2473,1,arjan
8:37,I was looking at this fragment  + // reinitialize the table. + Table.o…,CASSANDRA-840,"I was looking at this fragment  + // reinitialize the table.
+ Table.open(ksm.name).addCf(cfm.cfName);  + DatabaseDescriptor.setTableDefnition(ksm, newVersion);  + + // force creation of a new commit log segment.
+ CommitLog.instance().forceNewSegment();  isn’t that saying the CLS happens afterwards, not before? (which only makes sense, since  how can it know about the new entry until it’s in the table / DD)",,"Assumptions
Run-time quality issues",5:2476 - 5:2888,2,arjan
8:52,gdusbabek,CASSANDRA-840,gdusbabek,,Comment,5:2895 - 5:2903,1,arjan
8:38,I saw CLS but thought CFS. I’ll see about putting a log message in the…,CASSANDRA-840,"I saw CLS but thought CFS. I’ll see about putting a log message in the CL.
",,Architectural solution benefits and drawbacks,5:2906 - 5:2981,1,arjan
8:53,gdusbabek,CASSANDRA-840,gdusbabek,,Comment,5:2986 - 5:2994,1,arjan
8:39,Addressed that problem in v3-0001.,CASSANDRA-840,"Addressed that problem in v3-0001.
",,Architectural solution benefits and drawbacks,5:2997 - 5:3032,1,arjan
8:54,jbellis,CASSANDRA-840,jbellis,,Comment,5:3037 - 5:3043,1,arjan
8:40,+1,CASSANDRA-840,+1,,Architectural solution benefits and drawbacks,5:3046 - 5:3047,1,arjan
9:1,Allow tracing query details,CASSANDRA-1123,Allow tracing query details,,Motivation of design issue,3:52 - 3:78,1,arjan
9:2,"In the spirit of CASSANDRA-511, it would be useful to tracing on queri…",CASSANDRA-1123,"In the spirit of CASSANDRA-511, it would be useful to tracing on queries to see where latency  is coming from: how long did row cache lookup take? key search in the index? merging the data  from the sstables? etc.
",,Motivation of design issue,3:98 - 3:312,1,arjan
9:3,The main diference vs setting debug logging is that debug logging is t…,CASSANDRA-1123,"The main diference vs setting debug logging is that debug logging is too big of a hammer; by  turning on the food of logging for everyone, you actually distort the information you’re looking  for.",,Architectural solution benefits and drawbacks,3:313 - 3:508,1,arjan
9:4,This would be something you could set per-query (or more likely per co…,CASSANDRA-1123,"This would be something you could set per-query (or more likely per connection).
",,"Architectural design configuration
Architectural solution benefits and drawbacks",3:510 - 3:591,2,arjan
9:5,We don’t need to be as sophisticated as the techniques discussed in th…,CASSANDRA-1123,We don’t need to be as sophisticated as the techniques discussed in the following papers but  they are interesting reading:  http://research.google.com/pubs/pub36356.html  http://www.usenix.org/events/osdi04/tech/full_papers/barham/barham_html/  http://www.usenix.org/event/nsdi07/tech/fonseca.html,,Other system architectural solutions,3:592 - 3:889,1,arjan
9:6,"I’d really like to see the results of this, as well as any other traci…",CASSANDRA-1123," I’d really like to see the results of this, as well as any other tracing/metrics,  stored in a CF",,,4:111 - 4:208,1,arjan
9:154,jbellis,CASSANDRA-1123,jbellis,,Comment,4:214 - 4:220,1,arjan
9:7,"possibly, but see CASSANDRA-1430 for why this may not be a good idea",CASSANDRA-1123,"possibly, but see CASSANDRA-1430 for why this may not be a good idea",,Architectural solution benefits and drawbacks,4:223 - 4:290,1,arjan
9:155,jbellis,CASSANDRA-1123,jbellis,,Comment,4:296 - 4:302,1,arjan
9:8,CASSANDRA-1305 explored storing times for diferent query steps in an i…,CASSANDRA-1123,CASSANDRA-1305 explored storing times for diferent query steps in an in-memory  structure for later retrieval (by jmx?),,Existing system architecture description,4:305 - 4:423,1,arjan
9:156,jbellis,CASSANDRA-1123,jbellis,,Comment,4:429 - 4:435,1,arjan
9:9,CASSANDRA-1355 added an RPCLogger to capture the timing at the Cassan-…,CASSANDRA-1123,"CASSANDRA-1355 added an RPCLogger to capture the timing at the Cassan-  draServer / StorageProxy layer, but did not follow requests across machines",,Existing system architecture description,4:438 - 4:584,1,arjan
9:157,jbellis,CASSANDRA-1123,jbellis,,Comment,4:590 - 4:596,1,arjan
9:10,still looks like the simplest solution is to,CASSANDRA-1123, still looks like the simplest solution is to,,Architectural solution benefits and drawbacks,4:598 - 4:642,1,arjan
9:11,add a thrift system_enable_query_details()  method that would cause wh…,CASSANDRA-1123,"add a thrift system_enable_query_details()  method that would cause what we log at debug, to be logged at INFO _for queries from  that connection_. We’d need to add this to the intra-cluster messages too, either as a part  of the Message Header or (more lightweight) as a bit in the header computed by Messag-  ingService.packIt. (Up until it hits MessagingService everything will be run on the same  thread, so we can use a threadlocal like we do for keyspace in CassandraServer.)",,Architectural design configuration,4:644 - 4:1124,1,arjan
9:12,"incidentally, i don’t think we log anything about how many sstables ar…",CASSANDRA-1123,"incidentally, i don’t think we log anything about how many sstables are checked on a per-  query basis (although we collect this globally in a histogram), so that would be good to  add.
",,"Architectural solution benefits and drawbacks
Assumptions",4:1127 - 4:1313,2,arjan
9:158,amorton,CASSANDRA-1123,amorton,,Comment,4:1317 - 4:1323,1,arjan
9:13,The attached patch includes the following changes:  1) added system_en…,CASSANDRA-1123,"The attached patch includes the following changes:  1) added system_enable_query_details(bool) to the thrift api  2) added ""enable query details"" and ""disable query details"" to the CLI  3) added queryDetails state to the ClientState to store the setting per connection  4) o.a.c.service.QueryContext as a container for the per query state. State is only cre-  ated if the logging details are turned on for the query, and are stored in thread local storage  and accessed through static methods.
5) CassandraServer was modifed to call QueryContext.startQuery() and stopQuery() to  setup and clear the thread local query context. This is done at the entry point for each  thrift method that modifes / reads data.
6) o.a.c.concurrent.DebuggableThreadPoolExecutor was modifed to copy the QueryContext  if present and set it in the worker thread. The changes to the submit() and execute() meth-  ods mimic the implementation of java.util.concurrent.ThreadPool . This allows the context  to fow from the connection thread to read / mutate thread pools as well as any other cross  thread call a query makes.
7) o.a.c.net.Message and MessageDeliveryTask were modifed to include the QueryContext  in cross node messages. The context is only sent if present AND if the query started on the  3
local node (this stops the context fowing back to the origin). Serialising the QueryContext  leverages the fact that the Message will already have the IP address in it.
8) NOTE: The query context will only survive one hop through the cluster.
9) the slf4j-log412 jar has been removed and the code copied into the main tree. When slf4j  initialises it looks for an implementation of org.slf4j.impl.StaticLoggerBinder , this will now  be the implementation in the source tree rather than the jar in lib.
10) I modifed the org.slf4j.impl.Log4jLoggerAdapter implementation, the Log4jLoggerFactory  will wrap all log4j loggers in this adapter. The adapter now checks the thread local QueryCon-  text and elevates all TRACE and DEBUG messages to info if query details have been enabled.
As well as prepend each messages with either the ""query_id@origin_ip"" or ""query_id@origin_ip  message id"".
11) Added a line to ColumnFamilyStore to log how many SSTables were read during the  query.
Here’s an example of the log output for a get() call starting at node2 and calling node1, the  prefx is ""query 1@/127.0.0.2 - "" and ""query 1@/127.0.0.2 message 126 -""  INFO [pool-1-thread-1] 2011-01-13 01:39:03,423 CassandraServer.java (line 329) query 1@/127.0.0.2  - get  INFO [pool-1-thread-1] 2011-01-13 01:39:03,458 StorageService.java (line 1391) query 1@/127.0.0.2  - Sorted endpoints are /127.0.0.1  INFO [pool-1-thread-1] 2011-01-13 01:39:03,460 StorageProxy.java (line 377) query 1@/127.0.0.2  - weakread reading SliceByNamesReadCommand(table=’Keyspace1’, key=666f6f35, colum-  nParent=’QueryPath(columnFamilyName=’Standard2’, superColumnName=’null’, column-  Name=’null’)’, columns=[bar,]) from 126@/127.0.0.1  DEBUG [RequestResponseStage:1] 2011-01-13 01:39:03,489 ResponseVerbHandler.java (line  59) Processing response on an async result from 126@/127.0.0.1  INFO [pool-1-thread-1] 2011-01-13 01:39:03,499 QueryContext.java (line 71) query 1@/127.0.0.2  - returning to client, async processing may continue  -----  INFO [ReadStage:3] 2011-01-13 01:39:03,481 ColumnFamilyStore.java (line 1317) query 1@/127.0.0.2  message 126 - SSTables read 1  INFO [ReadStage:3] 2011-01-13 01:39:03,484 ReadVerbHandler.java (line 90) query 1@/127.0.0.2  message 126 - Read key 666f6f35; sending response to 126@/127.0.0.2  NOTE: The query details did not appear in the message on the RequestResponseStage  thread because the context was not sent in the return message from node1.
This is my frst major ticket, so please let me know of any issues. I chose to replace the slf4j  adapter to remove the need to chase down all the log calls and check the QueryContext.
",,Existing system architecture description,4:1326 - 5:2650,1,arjan
9:159,jbellis,CASSANDRA-1123,jbellis,,Comment,5:2654 - 5:2660,1,arjan
9:14,So I don’t forget: CASSANDRA-3515 points out that it would be nice to…,CASSANDRA-1123,"So I don’t forget: CASSANDRA-3515 points out that it would be nice to track time  spent scanning past tombstones. Or more directly, total number of columns we had to scan,  to collect the requested live ones.
",,User requirement,5:2663 - 5:2871,1,arjan
9:15,Is there still interest in this ?,CASSANDRA-1123," Is there still interest in this ?
",,,5:2884 - 5:2919,1,arjan
9:160,jbellis,CASSANDRA-1123,jbellis,,Comment,5:2923 - 5:2929,1,arjan
9:16,"Answer ""what is taking so long with query X""",CASSANDRA-1123,"Answer ""what is taking so long with query X""",,Architectural design configuration,5:2987 - 5:3030,1,arjan
9:17,Automatically enable tracing for say 1% of all queries and look for pa…,CASSANDRA-1123,Automatically enable tracing for say 1% of all queries and look for patterns,,Architectural design configuration,5:3035 - 5:3110,1,arjan
9:18,"(2) is important because often (1) is not repeatable, if the slowness…",CASSANDRA-1123,"(2) is important because often (1) is not repeatable, if the slowness comes from hitting  disk for instance it will usually be cached the next time.
",,Architectural solution benefits and drawbacks,6:1 - 6:150,1,arjan
9:19,"I think we’re 90% of the way there with this, but log fles aren’t very…",CASSANDRA-1123,"I think we’re 90% of the way there with this, but log fles aren’t very programatically  accessible, i.e., it’s difcult to implement scenario (2).",,"Architectural solution benefits and drawbacks
Assumptions",6:151 - 6:295,2,arjan
9:20,I’d like to,CASSANDRA-1123,I’d like to,,Architectural solution benefits and drawbacks,6:297 - 6:307,1,arjan
9:21,- make enable_logging method return the query context id,CASSANDRA-1123,- make enable_logging method return the query context id,,Architectural component behavior and structure,6:310 - 6:365,1,arjan
9:22,- store trace results in a columnfamily keyed by the id so they can be…,CASSANDRA-1123,"- store trace results in a columnfamily keyed by the id so they can be retrieved and displayed  (e.g. by adding EXPLAIN command to cqlsh, which would be a separate ticket)",,Architectural design configuration,6:368 - 6:538,1,arjan
9:161,skamio,CASSANDRA-1123,skamio,,Comment,6:565 - 6:570,1,arjan
9:23,Thrift request timeout should be interesting as well. Because a user g…,CASSANDRA-1123,"Thrift request timeout should be interesting as well. Because a user gets time-out  exception, but server doesn’t have any log about that.
",,Motivation of design issue,6:573 - 6:712,1,arjan
9:24,"In our production cluster, we added logging where timedout exception i…",CASSANDRA-1123,"In our production cluster, we added logging where timedout exception is thrown. It logs  warning message with the query itself for later investigation.
",,Other system architectural solutions,6:713 - 6:865,1,arjan
9:162,jbellis,CASSANDRA-1123,jbellis,,Comment,6:870 - 6:876,1,arjan
9:25,The CassandraServer class logs timeouts at DEBUG level (see CASSANDRA-…,CASSANDRA-1123," The CassandraServer class logs timeouts at DEBUG level (see CASSANDRA-3661).
",,Existing system architecture description,6:878 - 6:956,1,arjan
9:26,"But I agree this would be a useful ""event"" to record.",CASSANDRA-1123,"But I agree this would be a useful ""event"" to record.
",,Architectural solution benefits and drawbacks,6:957 - 6:1011,1,arjan
9:163,jbellis,CASSANDRA-1123,jbellis,,Comment,6:1016 - 6:1022,1,arjan
9:27,"Another useful event would be username, if authenticated. Since authen…",CASSANDRA-1123," Another useful event would be username, if authenticated. Since authentication  happens once per connection we’d want a separate CF? for per-conn information.
",,Motivation of design issue,6:1024 - 6:1184,1,arjan
9:28,"Aaron, do you think you’ll be getting back to this? If not I’m happy t…",CASSANDRA-1123,"Aaron, do you think you’ll be getting back to this? If not I’m happy to fnd someone  to work on it",,,6:1198 - 6:1295,1,arjan
9:164,slebresne,CASSANDRA-1123,slebresne,,Comment,6:1303 - 6:1311,1,arjan
9:29,While we wouldn’t be able to do this for the thrift API (for compatibi…,CASSANDRA-1123,"While we wouldn’t be able to do this for the thrift API (for compatibility  reason),",,Contextual constraints,6:1314 - 6:1397,1,arjan
9:30,"one option would be that when tracing is enable, we return a new struc…",CASSANDRA-1123," one option would be that when tracing is enable, we return a new structure with  the tracing details as part of the response (as an optional feld of CqlResult).
",,Architectural component behavior and structure,6:1398 - 6:1560,1,arjan
9:165,jbellis,CASSANDRA-1123,jbellis,,Comment,6:1565 - 6:1571,1,arjan
9:31,That is a good idea,CASSANDRA-1123,That is a good idea,,Architectural solution benefits and drawbacks,6:1574 - 6:1592,1,arjan
9:32,although I’d still like the ability to store results as well,CASSANDRA-1123, although I’d still like the ability to store results as well,,Architectural design configuration,6:1594 - 6:1654,1,arjan
9:33,which  would let us do always-on sampling of the workload for instance,CASSANDRA-1123,which  would let us do always-on sampling of the workload for instance,,Architectural solution benefits and drawbacks,6:1657 - 6:1726,1,arjan
9:166,jbellis,CASSANDRA-1123,jbellis,,Comment,6:1734 - 6:1740,1,arjan
9:34,"So, super high level view of how I think this should work:  Store even…",CASSANDRA-1123,"So, super high level view of how I think this should work:  Store events like this:  1 CREATE TABLE trace_sessions (  2 session int,  3 coordinator inetaddr,  4 request text,  5 PRIMARY KEY (session, coordinator)  6 );  7 8  CREATE TABLE trace_events (  9 session int,  10 coordinator inetaddr,  11 id uuid,  12 source inetaddr,  13 event text,  14 happened_at timestamp,  15 duration int,  16 PRIMARY KEY (session, coordinator, id)  17 );  5
The session table will log the operation being processed, and the events will log its progress.
Coordinator and replicas will all just throw events into this table; they don’t have to keep  anything in memory. Then we get the permanent record, AND clients can query the log  directly without needing to add more special-case code to the coordinator.
One way to tell the client about session ids would be to change Aaron’s API a bit: {{int sys-  tem_trace_next_query()}}. Then clients can just ""SELECT * from trace_events WHERE  coordinator = ? and session = ?"" if desired.
",,"Architectural design configuration
Assumptions",6:1743 - 7:576,2,arjan
9:35,"Alternatively we could retain the ""enable tracing on all queries until…",CASSANDRA-1123,"Alternatively we could retain the ""enable tracing on all queries until I turn it of"" and add  {{int system_get_last_query_session()}} but I prefer the one-method version for simplicity  and because tracing probably shouldn’t be left on indefnitely.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",7:577 - 7:826,2,arjan
9:36,No idea how best to expose to a Thrift-less CQL. Should we create a sp…,CASSANDRA-1123,"No idea how best to expose to a Thrift-less CQL. Should we create a special-cased func-  tion there too?
",,Motivation of design issue,7:827 - 7:932,1,arjan
9:37,coordinator will generate the session id locally. Session ids will NOT…,CASSANDRA-1123,"coordinator will generate the session id locally. Session ids will NOT be globally unique;  (id, coordinator) pair identifes a series of events",,Architectural design configuration,7:943 - 7:1085,1,arjan
9:38,session comes before coordinator since we want id to be the partition…,CASSANDRA-1123, session comes before coordinator since we want id to be the partition key; this will create  narrower rows,,Architectural design configuration,7:1089 - 7:1195,1,arjan
9:39,"""source"" is the machine logging the event, not necessarily the same as…",CASSANDRA-1123,"""source"" is the machine logging the event, not necessarily the same as coordinator (better  name needed?)",,Architectural design configuration,7:1200 - 7:1304,1,arjan
9:40,"happened_at will come from currentTimeMillis, so will not be high reso…",CASSANDRA-1123,"happened_at will come from currentTimeMillis, so will not be high resolution enough to  give us the duration of many events",,"Architectural design configuration
Architectural solution benefits and drawbacks",7:1309 - 7:1431,2,arjan
9:41,"instead, we should use nanotime on coordinator (and  replicas) to comp…",CASSANDRA-1123," instead, we should use nanotime on coordinator (and  replicas) to compute duration",,Architectural design configuration,7:1433 - 7:1515,1,arjan
9:42,We should TTL event data (1 day?) both to conserve space and to avoid…,CASSANDRA-1123,We should TTL event data (1 day?) both to conserve space and to avoid problems when  event ids wrap,,"Architectural design configuration
Architectural tactics",7:1520 - 7:1618,2,arjan
9:43,Not sure if the threadlocal approach I originally advocated is a good…,CASSANDRA-1123,"Not sure if the threadlocal approach I originally advocated is a good one. Certainly there  are important aspects that are not covered by the ""main"" coordinator and replica threads:  commitlog on the replica, and response processing on the coordinator; we may add more  such thread pools in the future.
",,Architectural solution benefits and drawbacks,7:1735 - 7:2038,1,arjan
9:44,"Aaron’s hacking of the slf4j adapator is clever, but I think we should…",CASSANDRA-1123,"Aaron’s hacking of the slf4j adapator is clever, but I think we should leave it out; you’d  still have to piece together what happened across multiple machines. ",,Architectural solution benefits and drawbacks,7:2041 - 7:2201,1,arjan
9:45,Logging into a colum-  nfamily instead solves that problem and makes t…,CASSANDRA-1123,Logging into a colum-  nfamily instead solves that problem and makes the data more accessible than log fles.,,"Architectural design configuration
Architectural solution benefits and drawbacks",7:2202 - 7:2309,2,arjan
9:46,"Probably worth encapsulating ""log an event to the columnfamily if trac…",CASSANDRA-1123,"Probably worth encapsulating ""log an event to the columnfamily if tracing is enabled,  otherwise log at debug to log4j"" into a utility method, though.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",7:2314 - 7:2465,2,arjan
9:167,dr-alves,CASSANDRA-1123,dr-alves,,Comment,7:2586 - 7:2593,1,arjan
9:47,"was about to start tracing with StopWatch, but it’s only available fro…",CASSANDRA-1123,"was about to start tracing with StopWatch, but it’s only available from 10.0.
upgrade?
",,Architectural design configuration,7:2596 - 7:2683,1,arjan
9:168,jbellis,CASSANDRA-1123,jbellis,,Comment,7:2689 - 7:2695,1,arjan
9:48,Sure.,CASSANDRA-1123,"Sure.
",,Architectural solution benefits and drawbacks,7:2698 - 7:2703,1,arjan
9:169,dr-alves,CASSANDRA-1123,dr-alves,,Comment,7:2709 - 7:2716,1,arjan
9:49,"aaraon original version ""replaced"" the logger which meant there were a…",CASSANDRA-1123,"aaraon original version ""replaced"" the logger which meant there were already a lot of things  being traced. As is this patch is pretty ""bare"" in terms of trace events in the sense that  stuf that goes through CassandraServer gets a new trace session but not much else is traced  (even though sessions get propagated across threads and nodes).",,Run-time quality issues,7:2827 - 7:3168,1,arjan
9:50,Maybe we could add events  6automatically when a session is propagated…,CASSANDRA-1123,"Maybe we could add events  6
automatically when a session is propagated across stages and across nodes",,Architectural design configuration,7:3170 - 8:73,1,arjan
9:51,therefore getting  a per-stage and per-node view of how things are exe…,CASSANDRA-1123,therefore getting  a per-stage and per-node view of how things are executed ,,Architectural solution benefits and drawbacks,8:76 - 8:151,1,arjan
9:52,I think this could be done rather  unintrusively,CASSANDRA-1123,I think this could be done rather  unintrusively,,"Architectural design configuration
Assumptions",8:153 - 8:200,2,arjan
9:53,"I haven’t added the log to the logger option yet, as I’m not completel…",CASSANDRA-1123,"I haven’t added the log to the logger option yet, as I’m not completely sure how use-  ful it is if events are generated per stage/node.
",,Architectural solution benefits and drawbacks,8:207 - 8:344,1,arjan
9:170,jbellis,CASSANDRA-1123,jbellis,,Comment,8:349 - 8:355,1,arjan
9:54,rest of the code base places static imports after non-static.,CASSANDRA-1123,"rest of the code base places static imports after non-static.
",,Existing system architecture description,8:363 - 8:425,1,arjan
9:55,Inclined to think we should include the parameters along w/ the String…,CASSANDRA-1123,"Inclined to think we should include the parameters along w/ the String request type on  session start. (Object... + toString would be adequate.) Maybe even use the new List type  to store the arguments (CASSANDRA-3647).
",,"Architectural design configuration
Assumptions",8:426 - 8:646,2,arjan
9:56,get_slice uses startSession instead of startSessionIfRequested.,CASSANDRA-1123,"get_slice uses startSession instead of startSessionIfRequested.
",,Existing system architecture description,8:647 - 8:711,1,arjan
9:57,a session named execute_cql_query is not very useful.,CASSANDRA-1123,a session named execute_cql_query is not very useful.,,Architectural solution benefits and drawbacks,8:712 - 8:764,1,arjan
9:58,Should use queryString instead.,CASSANDRA-1123,"Should use queryString instead.
",,Architectural solution benefits and drawbacks,8:766 - 8:798,1,arjan
9:59,May want to just push the CQL tracing into (cql3) QueryProcessor,CASSANDRA-1123,May want to just push the CQL tracing into (cql3) QueryProcessor,,Architectural design configuration,8:799 - 8:862,1,arjan
9:60,This will mean less  code to duplicate in the native CQL protocol hand…,CASSANDRA-1123,"This will mean less  code to duplicate in the native CQL protocol handler.
",,Architectural solution benefits and drawbacks,8:865 - 8:940,1,arjan
9:61,Tracing should be asynchronous. StorageProxy.mutate waits for a respon…,CASSANDRA-1123,"Tracing should be asynchronous. StorageProxy.mutate waits for a response, this is not  what we want. Suggest a simple ExecutorService + queue. (If queue gets full, throw out the  tracing events and log a WARN.)",,Run-time quality issues,8:941 - 8:1150,1,arjan
9:62,Would like tracing to log.debug the event as well.,CASSANDRA-1123,Would like tracing to log.debug the event as well.,,Architectural design configuration,8:1153 - 8:1202,1,arjan
9:63,"This will cut down on duplicate de-  bug/trace code, but also give us…",CASSANDRA-1123,"This will cut down on duplicate de-  bug/trace code, but also give us a fallback if we can’t log it remotely. This will also cut  down on log spam for when we enable debug level globally -- only logging requests at debug  where tracing was explicitly enabled will be a huge improvement.
",,Architectural solution benefits and drawbacks,8:1204 - 8:1491,1,arjan
9:64,CFMetaData defnitions should be with the other hardcoded ones in CFMet…,CASSANDRA-1123,"CFMetaData defnitions should be with the other hardcoded ones in CFMetaData.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",8:1492 - 8:1569,2,arjan
9:65,Let’s move helpers that are only used by test code like EVENT_TYPE int…,CASSANDRA-1123,"Let’s move helpers that are only used by test code like EVENT_TYPE into the Test class.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",8:1570 - 8:1658,2,arjan
9:66,There’s a no-op initialization of trace context in StorageService.,CASSANDRA-1123,"There’s a no-op initialization of trace context in StorageService.
",,Existing system architecture description,8:1659 - 8:1726,1,arjan
9:67,"Still think threadlocals are not the way to go, and this will become m…",CASSANDRA-1123,"Still think threadlocals are not the way to go, and this will become more clear as you  try to add useful trace entries. I think you’ll end up w/ a trace session ""registry"" like we  have for MessagingService that we’ll look up by session id. ",,"Architectural solution benefits and drawbacks
Assumptions",8:1727 - 8:1968,2,arjan
9:68,I’m not sure what  the afterExecute business is supposed to be doing.…,CASSANDRA-1123,"I’m not sure what  the afterExecute business is supposed to be doing. That stuf runs on the executor’s thread,  not the submitter’s.",,"Architectural solution benefits and drawbacks
Assumptions",8:1983 - 8:2114,2,arjan
9:69,"Finally, a more generic keyspace name like dsystem (?) would be nice f…",CASSANDRA-1123,"Finally, a more generic keyspace name like dsystem (?) would be nice for all distributed  system tables. (We’re thinking of using one for CASSANDRA-3706, for instance.)",,"Architectural design configuration
Architectural solution benefits and drawbacks",8:2348 - 8:2515,2,arjan
9:171,dr-alves,CASSANDRA-1123,dr-alves,,Comment,8:2522 - 8:2529,1,arjan
9:70,In one of the papers this same issue raised privacy concerns that are…,CASSANDRA-1123,"In one of the papers this same issue raised privacy concerns that are probably even more  valid for CASSANDRA since it’s an open source project. IMO we should at the very least  make this optional if not drop it all together.
",,Architectural solution benefits and drawbacks,9:1 - 9:227,1,arjan
9:71,"+1, nice idea, was looking into doing something similar.",CASSANDRA-1123,"+1, nice idea, was looking into doing something similar.
",,Architectural solution benefits and drawbacks,9:787 - 9:844,1,arjan
9:72,will do!,CASSANDRA-1123,"will do!
",,Architectural solution benefits and drawbacks,9:1441 - 9:1450,1,arjan
9:73,Current version uses this to trace pre and post stage execution (which…,CASSANDRA-1123,Current version uses this to trace pre and post stage execution (which are the only trace  events at the moment).,,Existing system architecture description,9:1845 - 9:1957,1,arjan
9:172,jbellis,CASSANDRA-1123,jbellis,,Comment,9:2298 - 9:2304,1,arjan
9:74,there must be some other context there because that doesn’t make sense…,CASSANDRA-1123,"there must be some other context there because that doesn’t make sense here: these are  parameters to requests *operating on the database, that we’re proposing to store them in.*  in other words: given that Cassandra already has your data, storing it a second time is not  a privacy concern.
8
think of it as a subset of auditing, if you prefer.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",9:2373 - 10:53,2,arjan
9:173,dr-alves,CASSANDRA-1123,dr-alves,,Comment,10:58 - 10:65,1,arjan
9:75,"i get the point, the original paper mentioned that that was the case b…",CASSANDRA-1123,"i get the point, the original paper mentioned that that was the case because the  data was stored outside of the cluster.
Still there is the question of authentication, even though access control is not very thorough  AFAIK, the principle behind it is per keyspace access correct? this would mean that we’re  storing data belonging to a keyspace (that might have access control) in another keyspace  (that must be outside accessible).",,"Architectural design configuration
Architectural solution benefits and drawbacks",10:68 - 10:502,2,arjan
9:76,"I’m happy to do it either way, but maybe we could instead store the nu…",CASSANDRA-1123,"I’m happy to do it either way, but maybe we could instead store the number and length  of the arguments.",,Architectural design configuration,10:505 - 10:608,1,arjan
9:77,additionally this would decrease tracing network bandwidth usage.,CASSANDRA-1123,"additionally this would decrease tracing network bandwidth usage.
",,Architectural tactics,10:610 - 10:676,1,arjan
9:174,jbellis,CASSANDRA-1123,jbellis,,Comment,10:681 - 10:687,1,arjan
9:78,"True, but it’s still opt-in. Don’t trace if that’s a bad ft for your u…",CASSANDRA-1123,"True, but it’s still opt-in. Don’t trace if that’s a bad ft for your use case. For the 99.9% of  deployments where a single organization both operates and uses the cluster, it’s very useful  to know exactly what statement was slow, not just what rpc method it was. Say get_slice  is slow: was it 1K row being accessed, or a 100MB row? Were we reading 10 columns or  10000? Huge diference in how to address those scenarios.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",10:813 - 10:1236,2,arjan
9:79,Since every get_slice call will have the same arg count I don’t see th…,CASSANDRA-1123,"Since every get_slice call will have the same arg count I don’t see this being very useful.
",,Architectural solution benefits and drawbacks,10:1310 - 10:1401,1,arjan
9:175,dr-alves,CASSANDRA-1123,dr-alves,,Comment,10:1407 - 10:1414,1,arjan
9:80,I actually meant storing both the size and length of the arguments *an…,CASSANDRA-1123,"I actually meant storing both the size and length of the arguments *and* the results. would  that be sufcient?
",,Architectural design configuration,10:1515 - 10:1626,1,arjan
9:176,jbellis,CASSANDRA-1123,jbellis,,Comment,10:1631 - 10:1637,1,arjan
9:81,Not for the frst example I gave.,CASSANDRA-1123,"Not for the frst example I gave.
",,Architectural solution benefits and drawbacks,10:1640 - 10:1673,1,arjan
9:177,dr-alves,CASSANDRA-1123,dr-alves,,Comment,10:1678 - 10:1685,1,arjan
9:82,"Right, but for that example storing the args as they are wouldn’t help…",CASSANDRA-1123,"Right, but for that example storing the args as they are wouldn’t help either,  which was the issue to begin with",,Run-time quality issues,10:1688 - 10:1800,1,arjan
9:83,Yet of course your point is valid. In order to accomodate  the use cas…,CASSANDRA-1123,"Yet of course your point is valid. In order to accomodate  the use case you mention I think we could get away with storing the number and size of both  argument and results in the ""coordinator"" node *and* store the actual size of the whole row  (num and size of cols) in the nodes that are performing the reads. wdyt?
",,"Architectural design configuration
Assumptions",10:1803 - 10:2121,2,arjan
9:178,jbellis,CASSANDRA-1123,jbellis,,Comment,10:2126 - 10:2132,1,arjan
9:84,"That would be adequate in this instance, but if we log the arguments w…",CASSANDRA-1123,"That would be adequate in this instance, but if we log the arguments we arm ourselves  against the scenarios we *didn’t* think of ahead of time, as well as the ones we did.
",,Architectural solution benefits and drawbacks,10:2366 - 10:2539,1,arjan
9:85,I think it’s straightforward what we should do here. Implement paramet…,CASSANDRA-1123,"I think it’s straightforward what we should do here. Implement parameter logging and  if sometime down the road someone comes along and says ""I really want to trace my applica-  tion but I can’t aford to log parameters"" we (or he) can add some way to make it optional.
Until then YAGNI applies.
",,"Architectural design configuration
Assumptions",10:2540 - 10:2836,2,arjan
9:179,dr-alves,CASSANDRA-1123,dr-alves,,Comment,10:2841 - 10:2848,1,arjan
9:86,What should we do wrt to reads then? also store the complete results (…,CASSANDRA-1123,"What should we do wrt to reads then? also store the complete results (what is  returned to the client) and the whole row (required to cover the examples you mentioned),",,"Architectural design configuration
Assumptions",10:2851 - 10:3018,2,arjan
9:87,or do we summarize in that case?,CASSANDRA-1123,or do we summarize in that case?,,"Architectural design configuration
Assumptions",11:1 - 11:32,2,arjan
9:88,In this case not summarizing can be costly (lots of net  trafc).,CASSANDRA-1123,"In this case not summarizing can be costly (lots of net  trafc).
",,Architectural solution benefits and drawbacks,11:34 - 11:99,1,arjan
9:180,jbellis,CASSANDRA-1123,jbellis,,Comment,11:104 - 11:110,1,arjan
9:89,"we don’t need to store results, just the query parameters (bind variab…",CASSANDRA-1123,"we don’t need to store results, just the query parameters (bind variables, in the  CQL case)",,Architectural design configuration,11:113 - 11:204,1,arjan
9:181,dr-alves,CASSANDRA-1123,dr-alves,,Comment,11:211 - 11:218,1,arjan
9:90,- Trace is implemented asynchronously with a new Stage that has a thre…,CASSANDRA-1123,"- Trace is implemented asynchronously with a new Stage that has a threadpool with a  single thread that refuses to execute when the queue if full ( as suggested a warn is logged,  experiments say that under huge load 0.001 traceProbability still works without rejecting  events). (also this threadpool is the only one that does not propagate trace events).
- Allows to enable tracing/disable tracing from cli. Also enable tracing has two parame-  ters traceProbability (the prop that any single request from that client gets traced) and  maxTraceNumber to allow to set a maximum number of traces to do (-1 set this to Inte-  ger.MAX_INT which is also the default)  - Adds the possibility to enable tracing in stress (using -tr probability [optionally maxNum-  Traces]  - TraceEvents can be build using a fuent builder (TraceEventBuilder) that is also able  to deserialize events (both from thrift and from IColumns).
- All requests in CassandraServer start a tracing session when tracing is enabled and all  parameters are stored along with the request details. This is done using a ThriftType that  is able to serialize and deserialize thrift objects into Cassandra.
- User Request/Reply, Stage Start/Finish and Message Request/Reply are traced along  with specifc custom requests (such as apply_mutation, and get_column_family)  - Cli contains two other commands to explore traces:  show tracing summary [request_name] - this displays a summary for a request type:",,Existing system architecture description,11:287 - 11:1755,1,arjan
9:94,"Some parameters are hard-coded (such as the tracing queue, the ttl for…",CASSANDRA-1123,"Some parameters are hard-coded (such as the tracing queue, the ttl for trace events and the  number of trace events to fetch for the summaries). It might be better to confgure these some-  where but I’ve refrained from adding more confg variables without consensus.
",,Technical debt,13:3 - 13:269,1,arjan
9:95,There should be more traces.,CASSANDRA-1123,There should be more traces.,,Run-time quality issues,13:272 - 13:299,1,arjan
9:96,I implemented a distributed system keyspace to be used elsewhere but i…,CASSANDRA-1123,"I implemented a distributed system keyspace to be used elsewhere but in the end reverted  to using the trace keyspace, reasoning was that a distributed system table might want diferent  things than a tracing system (replication factor for instance). Since tracing has its own keyspace  also kept CFMetadata there (Im glad to move it if it makes sense even without the dist systable  or if the consensus is that trace should be there)",,Existing system architecture description,13:304 - 13:736,1,arjan
9:97,In order to display the summarizing cli command the commons math jar i…,CASSANDRA-1123, In order to display the summarizing cli command the commons math jar is required (for statistics),,Other system architectural solutions,13:740 - 13:837,1,arjan
9:98,I ended up changing the schema to:,CASSANDRA-1123,I ended up changing the schema to:,,Existing system architecture description,13:842 - 13:875,1,arjan
9:99,Note the missing Sessions table (all the info there was redundant) and…,CASSANDRA-1123,"Note the missing Sessions table (all the info there was redundant) and the added felds for payload.
",,Existing system architecture description,13:1386 - 13:1486,1,arjan
9:100,Finally I’m having issues using the index from thrift. Is there an inc…,CASSANDRA-1123,"Finally I’m having issues using the index from thrift. Is there an incompatibility (i.e., using  an IndexExpression with a CQL3 table?).
",,"Assumptions
Motivation of design issue",13:1487 - 13:1624,2,arjan
9:101,"Yes, see https://issues.apache.org/jira/browse/CASSANDRA-4377?focusedC…",CASSANDRA-1123,"Yes, see https://issues.apache.org/jira/browse/CASSANDRA-4377?focusedCommentId=13436817&page=com.atlassian.j  tabpanel#comment-13436817",,Motivation of design issue,13:1790 - 13:1924,1,arjan
9:102,What I saw as I tried to add trace points was that the TraceEvent/Buil…,CASSANDRA-1123,What I saw as I tried to add trace points was that the TraceEvent/Builder api was fairly cumber-  some.,,Technical debt,13:2226 - 13:2328,1,arjan
9:103,What I really wanted to do was instrument all the debug logging that w…,CASSANDRA-1123,"What I really wanted to do was instrument all the debug logging that we’ve accumulated,  12
most of which has the battle scars of being added to solve a particular tricky situation.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",13:2330 - 14:91,2,arjan
9:104,So I started banging on the API and realized that I was ending up with…,CASSANDRA-1123,"So I started banging on the API and realized that I was ending up with something that resembled  a logging appender. So why not hook into our existing logging api? Like Aaron’s original idea,  but without any copy and pasting; we can just implement a log4j LoggingAppender and life is good.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",14:92 - 14:383,2,arjan
9:105,This does mean we don’t have payload maps anywhere but in the session…,CASSANDRA-1123,"This does mean we don’t have payload maps anywhere but in the session initialization, which  gets special-cased, but I’m fne with that.
",,Architectural solution benefits and drawbacks,14:384 - 14:520,1,arjan
9:106,The main drawback is we have to be careful about where we log on the w…,CASSANDRA-1123,"The main drawback is we have to be careful about where we log on the write path to avoid  an infnite loop, but this was a problem with the old approach as well. At least infnite loops will  be fairly obvious and easy to fx.",,Architectural solution benefits and drawbacks,14:817 - 14:1039,1,arjan
9:107,I’m violently opposed to serializing thrift objects into the trace. Th…,CASSANDRA-1123,I’m violently opposed to serializing thrift objects into the trace. This just pushes the job of mak-  ing them human-readable out to each consumer.,,"Architectural design configuration
Architectural solution benefits and drawbacks",14:1065 - 14:1211,2,arjan
9:108,Let’s solve this once at the server level instead.,CASSANDRA-1123,"Let’s solve this once at the server level instead.
",,Architectural design configuration,14:1213 - 14:1264,1,arjan
9:109,One approach is given (but not completed) in my tree. Note that I’m ok…,CASSANDRA-1123,"One approach is given (but not completed) in my tree. Note that I’m okay with being *barely*  human-readable; the main use case we’re concerned with is tracing queries interactively, in which  case we already know the parameters and the logging is a formality. I do want it to be *possible*  to reconstruct a problematic query detected by probabilistic sampling, but it doesn’t have to be  easy. (That said, turning hex back into cli or cqlsh is at least possible without writing a Thrift  deserializer frst, so it has that much of an advantage over the initial patch.)",,Architectural design configuration,14:1265 - 14:1833,1,arjan
9:110,I’m fne with giving up some structure in exchange for ease of use.,CASSANDRA-1123,I’m fne with giving up some structure in exchange for ease of use.,,Trade-offs,14:1838 - 14:1903,1,arjan
9:111,"A single ""activity"" column,  with some metadata, is enough.",CASSANDRA-1123,"A single ""activity"" column,  with some metadata, is enough.
",,Architectural component behavior and structure,14:1905 - 14:1965,1,arjan
9:112,"I’m also fne with giving up any or all of the pretty printer, summary…",CASSANDRA-1123,"I’m also fne with giving up any or all of the pretty printer, summary by request type, and tests,  which I’ve made no efort to port. ",,Architectural solution benefits and drawbacks,14:1968 - 14:2100,1,arjan
9:113,"Would strongly prefer getting a bare bones implementation  fnished, th…",CASSANDRA-1123,"Would strongly prefer getting a bare bones implementation  fnished, then adding more functionality later. (I do note that the pretty printer probably makes  more sense to grow vertically rather than horizontally.)",,"Architectural design configuration
Architectural solution benefits and drawbacks",14:2101 - 14:2313,2,arjan
9:114,enabling tracing-by-probability should be in jmx rather than thrift,CASSANDRA-1123,enabling tracing-by-probability should be in jmx rather than thrift,,Motivation of design issue,14:2318 - 14:2384,1,arjan
9:115,unsure if max-sessions-to-  trace is useful.,CASSANDRA-1123,"unsure if max-sessions-to-  trace is useful.
",,Architectural solution benefits and drawbacks,14:2387 - 14:2432,1,arjan
9:116,I think you will like the improvements around DTPE and the Stage.,CASSANDRA-1123," I think you will like the improvements around DTPE and the Stage.
",,"Architectural solution benefits and drawbacks
Assumptions",14:2434 - 14:2501,2,arjan
9:117,Wiring up appenders at diferent levels (we’d want the fle appender at…,CASSANDRA-1123,"Wiring up appenders at diferent levels (we’d want the fle appender at INFO, the tracing one at  DEBUG) is kind of a bitch. Apologies in advance",,Architectural solution benefits and drawbacks,14:2504 - 14:2646,1,arjan
9:118,+1 on the new way of declaring KS’s and CF’s,CASSANDRA-1123,+1 on the new way of declaring KS’s and CF’s,,Architectural solution benefits and drawbacks,14:3250 - 14:3293,1,arjan
9:119,+1 on hooking the appender,CASSANDRA-1123,+1 on hooking the appender,,Architectural solution benefits and drawbacks,14:3298 - 14:3323,1,arjan
9:120,+1 on leaving cli summary out (it was just something I made for my own…,CASSANDRA-1123," +1 on leaving cli summary out (it was just something I made for my own purposes as I was  considering the uses of the tracing system/making something readable).
",,Architectural solution benefits and drawbacks,14:3327 - 14:3489,1,arjan
9:121,+1 on reducing overall clutter,CASSANDRA-1123,+1 on reducing overall clutter,,Architectural solution benefits and drawbacks,14:3492 - 14:3521,1,arjan
9:122,in order for thrift/cql3 to work together names still need to go throu…,CASSANDRA-1123, in order for thrift/cql3 to work together names still need to go through ColumNameBuilder  or weird stuf happens (e.g. an IAE on a bytebufer). Also eventId needs to be prefxed to the the  col names in events (and not in a col by itself),,Technical debt,15:16 - 15:252,1,arjan
9:123,the reason the the StageManager provided a bare ThreadPool for the tra…,CASSANDRA-1123," the reason the the StageManager provided a bare ThreadPool for the tracingstage instead of  the the JMX one was because the JMX one is a descendant of DebuggableTP and that one prop-  agates the trace state which we wouldn’t want when writing the traces themselves, what happens  otherwise is an infnite loop. (also state wasn’t being propagated propagated because: a) setup-  Context() was never called b) TPE.execute() never calls newTaskFor making meaning overriding  newTaskFor doesn’t work for all tasks, only for those that call submit() which are a small per-  centage).
",,Architectural solution benefits and drawbacks,15:256 - 15:835,1,arjan
9:124,I still think that for profling purposes having a single table would b…,CASSANDRA-1123," I still think that for profling purposes having a single table would be better, if someone wants to  get the sets of all events for ""batch_mutate"" sessions it will require doing two queries (and won’t  be feasible from cqlsh for instance).
",,"Architectural solution benefits and drawbacks
Assumptions",15:837 - 15:1078,2,arjan
9:125,"having a single ""activity"" feld means that any bulk processing will ha…",CASSANDRA-1123," having a single ""activity"" feld means that any bulk processing will have to do string parsing  and that no index will help in picking certain types of events.
",,Run-time quality issues,15:1080 - 15:1240,1,arjan
9:126,the typed payloads allowed to easily perform specifc gets to answer qu…,CASSANDRA-1123," the typed payloads allowed to easily perform specifc gets to answer questions such as ""whats the  avg returned size for get_range_slices"" these questions now are much harder to answer because:  a) they need multiple gets and b) the resulting string must be parsed (if it even includes the info)",,Run-time quality issues,15:1242 - 15:1536,1,arjan
9:182,dr-alves,CASSANDRA-1123,dr-alves,,Comment,15:1539 - 15:1546,1,arjan
9:127,All in all I think this version works fne to do distributed debugging…,CASSANDRA-1123,All in all I think this version works fne to do distributed debugging a single request,,"Architectural solution benefits and drawbacks
Assumptions",15:1549 - 15:1634,2,arjan
9:128,but that profling sets of request would beneft from the old schema/add…,CASSANDRA-1123,"but that profling sets of request would beneft from the old schema/additional typed info.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",15:1637 - 15:1727,3,arjan
9:183,dr-alves,CASSANDRA-1123,dr-alves,,Comment,15:1728 - 15:1735,1,arjan
9:129,- JMX enabled tracing  - simplifed enabling tracing  - completed cli a…,CASSANDRA-1123,- JMX enabled tracing  - simplifed enabling tracing  - completed cli and stress,,Existing system architecture description,15:1753 - 15:1831,1,arjan
9:184,jbellis,CASSANDRA-1123,jbellis,,Comment,15:1834 - 15:1840,1,arjan
9:130,"Hmm, can we do something clever like http://stackoverfow.com/questions…",CASSANDRA-1123,"Hmm, can we do something clever like http://stackoverfow.com/questions/4046228/log4j-excluding-  the-logging-of-some-classes to just log o.a.c.tracing to stdout + R so we don’t just error out silently  when something goes wrong w/ tracing?
",,Other system architectural solutions,15:1991 - 15:2231,1,arjan
9:185,jbellis,CASSANDRA-1123,jbellis,,Comment,15:2232 - 15:2238,1,arjan
9:131,"v6 attached. adds trace session.fnished_at, adds back debug logging fo…",CASSANDRA-1123," v6 attached. adds trace session.fnished_at, adds back debug logging for thrift methods  when tracing is of, removes probability from thrift interface.
uses newTaskFor in DTPE, but overrides execute as well. (otherwise we wrap, then newTaskFor  wraps a second time.",,Existing system architecture description,15:2240 - 15:2505,1,arjan
9:132,might as well just wrap once.),CASSANDRA-1123,might as well just wrap once.),,Run-time quality issues,15:2507 - 15:2536,1,arjan
9:186,dr-alves,CASSANDRA-1123,dr-alves,,Comment,15:2580 - 15:2587,1,arjan
9:133,"We can, I’m taking care of that on the next patch along with nodetool.",CASSANDRA-1123,"We can, I’m taking care of that on the next patch along with nodetool.",,Architectural solution benefits and drawbacks,15:2835 - 15:2904,1,arjan
9:134,"Although, just to be  clear, using a bare TPE is still the way to go b…",CASSANDRA-1123,"Although, just to be  clear, using a bare TPE is still the way to go because we still wouldn’t want to propagate tracing  to tracing mutation threads.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",15:2906 - 15:3057,2,arjan
9:187,dr-alves,CASSANDRA-1123,dr-alves,,Comment,16:1 - 16:8,1,arjan
9:135,- Fixed NPE in TracingAppender because of inlining isTracing() (the in…,CASSANDRA-1123,"- Fixed NPE in TracingAppender because of inlining isTracing() (the instance may not  be built at the time the appender is started)  - Added settraceprobability to nodetool  - Removed tracing settings from stress (assumed that was the goal, happy to readd if needed)",,Existing system architecture description,16:11 - 16:276,1,arjan
9:188,dr-alves,CASSANDRA-1123,dr-alves,,Comment,16:279 - 16:286,1,arjan
9:136,after I had done this I realized that there was no point. all log even…,CASSANDRA-1123,"after I had done this I realized that there was no point. all log events from everywhere (in-  cluding o.a.c.tracing) but the ones coming from tracing stage executions are already present in all  logs (tracing, rolling and stdout) if at the debug level. tracing writes do not inherit the debug-  gableTPE, which means log events coming from a tracing write do not go the tracing appender  but *do* go the rest of the appenders by default already.
",,Architectural solution benefits and drawbacks,16:534 - 16:981,1,arjan
9:137,ran some smoke tests (locally): 0.1% tracing probability under full lo…,CASSANDRA-1123,"ran some smoke tests (locally): 0.1% tracing probability under full load causes ~5.5%  slowdown (in writes), without any tracing event being discarded.
",,,16:992 - 16:1144,1,arjan
9:138,"(previous results were with regard to writes/sec rate), int_op_rate/ke…",CASSANDRA-1123,"(previous results were with regard to writes/sec rate), int_op_rate/key_rate see the  same results, avg latency does not see a diference",,,16:1155 - 16:1290,1,arjan
9:189,jbellis,CASSANDRA-1123,jbellis,,Comment,16:1293 - 16:1299,1,arjan
9:139,the point was that an exception from a FutureTask will not be seen unl…,CASSANDRA-1123,the point was that an exception from a FutureTask will not be seen unless get() is called,,Architectural solution benefits and drawbacks,16:1364 - 16:1452,1,arjan
9:140,or  we do some extra gymnastics a la DTPE. So what we want the tracing…,CASSANDRA-1123," or  we do some extra gymnastics a la DTPE. So what we want the tracing executor to do is to logEx-  ceptionsAfterExecute like DTPE, but we only want that to be logged to a fle, we don’t want to  try to insert it as a tracing event.
",,Architectural design configuration,16:1454 - 16:1687,1,arjan
9:190,dr-alves,CASSANDRA-1123,dr-alves,,Comment,16:1688 - 16:1695,1,arjan
9:141,since the responsibility of logging such an event would always fall on…,CASSANDRA-1123,"since the responsibility of logging such an event would always fall on the writing thread my  point was that any log event generated by that thread would already go to all appenders but the  tracing one because the TL state doen’t get propagated there (for instance if we used try/catch  in runMayThrow or if we logged in afterExecute).
",,"Architectural design configuration
Architectural solution benefits and drawbacks",16:1757 - 16:2094,2,arjan
9:142,CassandraDaemon already sets a default exception handler that logs to…,CASSANDRA-1123,"CassandraDaemon already sets a default exception handler that logs to error.
",,Existing system architecture description,16:2097 - 16:2174,1,arjan
9:143,The only thing that is not done is the test-whether-exception-handler-…,CASSANDRA-1123,"The only thing that is not done is the test-whether-exception-handler-is-set-and-if-not-log dance  that DTPE does but since one such handler is set this shouldn’t be a problem, correct?
",,"Architectural solution benefits and drawbacks
Assumptions",16:2177 - 16:2363,2,arjan
9:191,jbellis,CASSANDRA-1123,jbellis,,Comment,16:2438 - 16:2444,1,arjan
9:144,"Thus, the default exception handler doesn’t matter. This is the main p…",CASSANDRA-1123,"Thus, the default exception handler doesn’t matter. This is the main problem DTPE solves.
(That, and block-until-room-on-queue which is a better policy than the defaults.)",,Architectural solution benefits and drawbacks,16:2523 - 16:2694,1,arjan
9:145,I note that we always use .execute instead of .submit on the tracing s…,CASSANDRA-1123,I note that we always use .execute instead of .submit on the tracing stage for now,,Existing system architecture description,16:2697 - 16:2778,1,arjan
9:146,but I’d like to  cover our bases or this could be a real head-scratche…,CASSANDRA-1123,"but I’d like to  cover our bases or this could be a real head-scratcher if/when we do exercise the submit path.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",16:2781 - 16:2893,2,arjan
9:192,dr-alves,CASSANDRA-1123,dr-alves,,Comment,16:2894 - 16:2901,1,arjan
9:147,Moves the error handling out of debuggableTPE into a parent TPE that i…,CASSANDRA-1123,"Moves the error handling out of debuggableTPE into a parent TPE that is also used  as the bare TPE for tracing, debuggable TPE now does only tracing plus the blocking queue.
",,Existing system architecture description,16:2904 - 16:3078,1,arjan
9:193,jbellis,CASSANDRA-1123,jbellis,,Comment,16:3079 - 16:3085,1,arjan
9:148,How about this? v9 is v7 with an ExecuteOnlyExecutor to remind us in t…,CASSANDRA-1123,"How about this? v9 is v7 with an ExecuteOnlyExecutor to remind us in the future not  to use submit on the trace stage.
",,Architectural design configuration,16:3088 - 16:3207,1,arjan
9:194,dr-alves,CASSANDRA-1123,dr-alves,,Comment,16:3208 - 16:3215,1,arjan
9:149,"+1, wfm",CASSANDRA-1123,"+1, wfm",,Architectural solution benefits and drawbacks,16:3218 - 16:3224,1,arjan
9:195,jbellis,CASSANDRA-1123,jbellis,,Comment,17:30 - 17:36,1,arjan
9:150,"Hmm, looks like this broke our test log4j confg somehow. ant test give…",CASSANDRA-1123," Hmm, looks like this broke our test log4j confg somehow. ant test gives a lot of this:  [junit] ERROR 14:02:56,567 Fatal exception in thread Thread[MigrationStage:1,5,main]  [junit] java.lang.NullPointerException  [junit] at org.apache.cassandra.db.ColumnFamilyStore.getColumnFamily(ColumnFamilySt  [junit] at org.apache.cassandra.db.ColumnFamilyStore.getColumnFamily(ColumnFamilySt  [junit] at org.apache.cassandra.db.ColumnFamilyStore.getColumnFamily(ColumnFamilySt  [junit] at org.apache.cassandra.config.ColumnDefinition.readSchema(ColumnDefinition  [junit] at org.apache.cassandra.config.CFMetaData.fromSchema(CFMetaData.java:1320)  [junit] at org.apache.cassandra.config.KSMetaData.deserializeColumnFamilies(KSMetaD  [junit] at org.apache.cassandra.db.DefsTable.mergeColumnFamilies(DefsTable.java:342  [junit] at org.apache.cassandra.db.DefsTable.mergeSchema(DefsTable.java:255)  [junit] at org.apache.cassandra.service.MigrationManager$1.call(MigrationManager.ja  [junit] at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)  [junit] at java.util.concurrent.FutureTask.run(FutureTask.java:138)  [junit] at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecuto  [junit] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.ja  [junit] at java.lang.Thread.run(Thread.java:662)  where CFS:1195 is a logger.debug call.
ant test uses test/conf/log4j-server.properties, which just specifes a fle and stdout at DEBUG.",,Run-time quality issues,17:38 - 17:1512,1,arjan
9:196,jbellis,CASSANDRA-1123,jbellis,,Comment,17:1515 - 17:1521,1,arjan
9:151,Reverted pending tests fx.,CASSANDRA-1123,"Reverted pending tests fx.
",,Architectural design configuration,17:1524 - 17:1550,1,arjan
9:197,dr-alves,CASSANDRA-1123,dr-alves,,Comment,17:1552 - 17:1559,1,arjan
9:152,Fixes the NPE. Problem was the result.getColumnCount call inside the l…,CASSANDRA-1123,"Fixes the NPE. Problem was the result.getColumnCount call inside the logging state-  ment (result maybe null).
",,Run-time quality issues,17:1562 - 17:1673,1,arjan
9:198,jbellis,CASSANDRA-1123,jbellis,,Comment,17:1674 - 17:1680,1,arjan
9:153,"committed. (turns out I didn’t push the revert earlier, so I just left…",CASSANDRA-1123,"committed. (turns out I didn’t push the revert earlier, so I just left that out when I did  push.)",,Motivation of design issue,17:1683 - 17:1780,1,arjan
10:1,"Make bulk loading into Cassandra less crappy, more pluggable",CASSANDRA-1278,"Make bulk loading into Cassandra less crappy, more pluggable",,Quality Attribute requirement,3:52 - 3:111,1,arjan
10:2,Currently bulk loading into Cassandra is a black art. People are eithe…,CASSANDRA-1278,"Currently bulk loading into Cassandra is a black art. People are either directed to just do it  responsibly with thrift or a higher level client, or they have to explore the contrib/bmt example -  http://wiki.apache.org/cassandra/BinaryMemtable That contrib module requires delving into the  code to fnd out how it works and then applying it to the given problem. Using either method,  the user also needs to keep in mind that overloading the cluster is possible - which will hopefully  be addressed in CASSANDRA-685",,Run-time quality issues,3:131 - 3:646,1,arjan
10:3,This improvement would be to create a contrib module or set of documen…,CASSANDRA-1278,"This improvement would be to create a contrib module or set of documents dealing with bulk  loading. Perhaps it could include code in the Core to make it more pluggable for external clients  of diferent types.
",,Quality Attribute requirement,3:649 - 3:859,1,arjan
10:4,It is just that this is something that many that are new to Cassandra…,CASSANDRA-1278,"It is just that this is something that many that are new to Cassandra need to do - bulk load  their data into Cassandra.
",,User requirement,3:860 - 3:981,1,arjan
10:153,jbellis,CASSANDRA-1278,jbellis,,Comment,4:18 - 4:24,1,arjan
10:5,Let’s see how the streaming refactor shakes out. Replacing BMT w/ stre…,CASSANDRA-1278,"Let’s see how the streaming refactor shakes out. Replacing BMT w/ streaming  makes a lot of sense to me.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",4:27 - 4:132,2,arjan
10:154,jbellis,CASSANDRA-1278,jbellis,,Comment,4:136 - 4:142,1,arjan
10:6,"All a ""bulk load"" API needs to do is pretend it’s a streaming source,…",CASSANDRA-1278,"All a ""bulk load"" API needs to do is pretend it’s a streaming source, and send data  rows (in sorted order) to the target. Since Hadoop sorts as part of the reduce stage, we  should be able do this directly in CFOF/CFRW.
",,Architectural design configuration,4:145 - 4:366,1,arjan
10:7,The tricky part is that StreamOutSession.begin assumes that it has a l…,CASSANDRA-1278,"The tricky part is that StreamOutSession.begin assumes that it has a list of physical fles to  stream from (via addFilesToStream).
",,Technical debt,4:367 - 4:498,1,arjan
10:155,mdennis,CASSANDRA-1278,mdennis,,Comment,4:502 - 4:508,1,arjan
10:8,Attached patch implements a Cassandra Pipelined Thrift (CPT) loader.,CASSANDRA-1278,"Attached patch implements a Cassandra Pipelined Thrift (CPT) loader.
",,Existing system architecture description,4:511 - 4:579,1,arjan
10:9,"Thrift objects are serialized over a socket to C* in ""segments"". Once…",CASSANDRA-1278,"Thrift objects are serialized over a socket to C* in ""segments"". Once the segment is loaded,  C* responds with a CPTResponse object detailing the various counts about what was loaded  and the connection is closed. Rows and/or columns need not be sorted. No throttling need  occur - the client can safely write data to the socket as fast as it will accept it. CPT correctly  handles secondary indexes.
The format of sending a segment is:  PROTOCOL_MAGIC (i.e. MessagingService.PROTOCOL_MAGIC)  PROTOCOL_HEADER (i.e. IncomingCassandraPipelinedThriftReader.PROTOCOL_HEADER)  CPTHeader  CPTRowHeader (for each row sent)  Column|SuperColumn (for each Column|SuperColumn in the row)  Each row is terminated by an empty Column or SuperColumn (e.g. IncomingCassan-  draPipelinedThriftReader.END_OF_COLUMNS) Each segment is terminated by an empty  CPTRowHeader (e.g. IncomingCassandraPipelinedThriftReader.END_OF_ROWS)  A CPTHeader consists of several felds:  1 struct CPTHeader {  2 1: required string keyspace,  3 2: required string column_family,  4 3: required i32 table_flush_size,  5 4: required i32 forward_frame_size,  6 5: required i32 so_rcvbuf_size,  7 6: required i32 so_sndbuf_size,  8 7: required bool forward,  9 }  table_fush_size controls the amount of data that is bufered before applying the muta-  tion. Several KB is a good starting value for this.
forward_frame_size only applies with forward=true and controls what thrift frame size  to use when forwarding data to other nodes. 256K is a good value here, but it should be  1/2 or less the size of so_rcvbuf_size and so_sndbuf_size.
so_rcvbuf_size/so_sndbuf_size is the size of the socket bufer used by C* when accepting/-  forwarding CPT data respectively. It should be at least twice as big as forward_frame_size  3
and/or the frame sized used when sending CPT data. Values > 128K usually require chang-  ing net.core.rmem_max/net.core.wmem_max.
forward controls whether C* should forward data to other nodes.
bin/generatecptdata will produce test data with the parameters given in bin/generatecpt-  data.confg  bin/listcptdetails will list information about fle(s)/dir(s) given as arguments, including num-  ber of rows and size of the useful raw data (versus overhead/packaging).
bin/loadcptdata will load CPT fles to a cluster and serves as a great starting point for  doing this from other applications.
Thrift generates a *lot* of garbage and as such it is trivial to max out JVM GC with  the current implementation. Tuning GC for your loads is a good idea for best performance  (smallish memtables and larger newgen is a good place to start).
After a CPT load it is important to fush as CPT loading skips the commitlog (which  also implies that the ""retry"" division is on segments, not row and/or individual mutations).
Best performance, especially on larger clusters, will be achieved by partitioning your data  into segments such that a given segment corresponds to precisely one range in the cluster  (see loadcptdata for an example of how to do this). Then sending each segment to each of  the replicas for that range in a separate connection/thread with forward=false (note that  loadcptdata does *not* do this, it assumes segments can contain data for any node). This  provides two important benefts:  1) it allows all nodes at all times to make as much progress as possible independent of  other nodes/replicas slowing down (e.g. compaction, GC).
2) it allows you to retry precisely the failed segments on precisely the failed nodes if a  node fails during a CPT load (in the more general sense it lets you reason about what data  was loaded where instead of depending on AE, RR, HH).
",,Existing system architecture description,4:581 - 5:1889,1,arjan
10:156,tjake,CASSANDRA-1278,tjake,,Comment,5:1894 - 5:1898,1,arjan
10:10,compaction ran all during the bulk load,CASSANDRA-1278,compaction ran all during the bulk load,,Architectural solution benefits and drawbacks,5:2126 - 5:2164,1,arjan
10:12,{quote}1. took 12 + minutes to bulk load 1.8G of data locally. I have…,CASSANDRA-1278,"{quote}1. took 12 + minutes to bulk load 1.8G of data locally. I have no bearing  if that is fast or slow but it felt slow, what should I expect?{quote}  That is very slow. Likely your memtable is too large and the JVM is getting stuck in  GC. On a single EC2 XL instance loading from that instance it takes about 2.5 minutes  to load that 1.8 GB of data consisting of ~5.2M rows with compaction turned on, 64 MB  memtables and loading from the same node (it’s faster using a second node to load the data).
{quote}2. compaction ran all during the bulk load.{quote}  4
The CPT loader itself doesn’t do anything to turn compaction on or of. Better perfor-  mance is often achieved by turning it of though.
{quote}3. listcptdata needs a usage message{quote}  done  {quote}4. needs a readme fle explaining this, since it’s not obvious what’s going on  here{quote}  done. Also, generatecptdata.confg has also been commented.
",,,5:2300 - 6:354,1,arjan
10:157,mdennis,CASSANDRA-1278,mdennis,,Comment,6:358 - 6:364,1,arjan
10:13,"On a related note, I think AuthFlushingThriftTransport should likely b…",CASSANDRA-1278,"On a related note, I think AuthFlushingThriftTransport should likely be com-  mitted to thrift. If everyone agrees, I’ll split that out into a thrift patch...
",,"Architectural design configuration
Assumptions",6:367 - 6:526,2,arjan
10:158,tjake,CASSANDRA-1278,tjake,,Comment,6:530 - 6:534,1,arjan
10:14,"I understand why you did what you did here, but the concept of taking…",CASSANDRA-1278,"I understand why you did what you did here, but the concept of taking thrift encoded  data over streaming port then creating another set of thrift objects to create row mutations  feels, well, bulky :)",,Architectural solution benefits and drawbacks,6:537 - 6:737,1,arjan
10:15,It seems like there would be a way to refne what you’ve done to go fro…,CASSANDRA-1278,"It seems like there would be a way to refne what you’ve done to go from client -> memtable  more quickly.
",,"Architectural design configuration
Architectural tactics
Assumptions",6:740 - 6:846,3,arjan
10:16,if you took the column and supercolumn serializers and streamed the de…,CASSANDRA-1278,"if you took the column and supercolumn serializers and streamed the delimited byte ar-  rays you would build up a CSLM<ByteBufer,ByteBufer> and call SSTableWriter.append  once it’s ""full""  You could then kick of secondary index rebuilding in the background.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",6:847 - 6:1104,2,arjan
10:17,"8. jbellis: I don’t think we’re involving gossip here? 9. tjake: Oops,…",CASSANDRA-1278,"8. jbellis: I don’t think we’re involving gossip here?
9. tjake: Oops, mean’t streaming. fxed above.
",,,6:1106 - 6:1207,1,arjan
10:159,jbellis,CASSANDRA-1278,jbellis,,Comment,6:1213 - 6:1219,1,arjan
10:18,a custom format,CASSANDRA-1278,a custom format,,Architectural design configuration,6:1308 - 6:1322,1,arjan
10:19,thrift,CASSANDRA-1278,thrift,,Other system architectural solutions,6:1328 - 6:1333,1,arjan
10:20,native ColumnSerializer format,CASSANDRA-1278, native ColumnSerializer format,,Architectural design configuration,6:1338 - 6:1368,1,arjan
10:21,has little to recommend it. We have enough serialization formats alrea…,CASSANDRA-1278,"has little to recommend it. We have enough serialization formats already.
",,Architectural solution benefits and drawbacks,6:1374 - 6:1448,1,arjan
10:22,has the beneft of being cross-platform out of the box.,CASSANDRA-1278,"has the beneft of being cross-platform out of the box.
",,Architectural solution benefits and drawbacks,6:1452 - 6:1507,1,arjan
10:23,"is obviously going to be fastest, especially if you require rows to be…",CASSANDRA-1278,"is obviously going to be fastest, especially if you require rows to be in sorted order  so you can basically stream directly to an sstable data fle.
",,Architectural solution benefits and drawbacks,6:1511 - 6:1660,1,arjan
10:24,Neither 2. nor 3. is inherently unreasonable; the question is whether…,CASSANDRA-1278,"Neither 2. nor 3. is inherently unreasonable; the question is whether we can get to ""fast  enough"" with 2. That’s a question we couldn’t answer without building it.
",,Trade-offs,6:1661 - 6:1826,1,arjan
10:160,tjake,CASSANDRA-1278,tjake,,Comment,6:1831 - 6:1835,1,arjan
10:25,"I don’t think we’d need to change the client facing API, I was thinkin…",CASSANDRA-1278," I don’t think we’d need to change the client facing API, I was thinking of just moving  more of the work to the client.
We could make a java based importtool that a user can pipe the CPT format serialized data  into to which in turn would encode it to BMT or serialized rows to be streamed to the nodes.
",,"Architectural design configuration
Assumptions",6:1837 - 6:2143,2,arjan
10:26,That way most of the work of encoding / decoding happens locally and u…,CASSANDRA-1278,"That way most of the work of encoding / decoding happens locally and users can write  their loaders in any language.
",,Architectural solution benefits and drawbacks,7:1 - 7:117,1,arjan
10:161,jbellis,CASSANDRA-1278,jbellis,,Comment,7:123 - 7:129,1,arjan
10:27,"That’s more complex, but it does have a lot of ""best of both worlds"" t…",CASSANDRA-1278,"That’s more complex, but it does have a lot of ""best of both worlds"" to it.
",,Trade-offs,7:132 - 7:208,1,arjan
10:28,"If we do that, I’d like to make it gossip-aware so it can take care of…",CASSANDRA-1278,"If we do that, I’d like to make it gossip-aware so it can take care of proxying/replicating too  instead of doing that server-side.
",,Architectural design configuration,7:209 - 7:341,1,arjan
10:162,jbellis,CASSANDRA-1278,jbellis,,Comment,7:346 - 7:352,1,arjan
10:29,"Thinking about this some more, I think we can really simplify it from…",CASSANDRA-1278,"Thinking about this some more, I think we can really simplify it from a client  perspective.
We could implement the Thrift Cassandra interface (the interface implemented by Cas-  sandraServer) in a bulk loader server. (""Server"" in that thrift clients connect to it, but it  would run on client machines, not Cassandra nodes.)  Writes would be turned into streaming, serialized-byte-streams by using Memtable + sort.
We would keep Memtable-per-replica-range, so the actual Cassandra node doesn’t need to  deserialize to potentially forward. (Obviously we would not support any read operations.)",,"Architectural design configuration
Assumptions",7:355 - 7:949,2,arjan
10:30,This approach would yield _zero_ need for new work on the client side…,CASSANDRA-1278,"This approach would yield _zero_ need for new work on the client side -- you can use  Hector, Pycassa, Aquiles, whatever, and normal batch_mutate could be turned into bulk  load streams.",,Architectural solution benefits and drawbacks,7:952 - 7:1137,1,arjan
10:31,The one change we’d need on the client side would be a batch_complete…,CASSANDRA-1278,"The one change we’d need on the client side would be a batch_complete call to say ""we’re  done, now build 2ary indexes."" (per-sstable bloom + primary index can be built in parallel  w/ the load, the way StreamIn currently does.)",,Architectural design configuration,7:1140 - 7:1367,1,arjan
10:32,"Again, we could probably update the StreamIn/StreamOut interface to ha…",CASSANDRA-1278,"Again, we could probably update the StreamIn/StreamOut interface to handle the bulk-  load daemon -> Cassandra trafce.",,Architectural design configuration,7:1370 - 7:1487,1,arjan
10:33,It _may_ be simpler to create a new api but my guess  is not.,CASSANDRA-1278,"It _may_ be simpler to create a new api but my guess  is not.
",,"Architectural solution benefits and drawbacks
Assumptions",7:1489 - 7:1551,2,arjan
10:163,tjake,CASSANDRA-1278,tjake,,Comment,7:1556 - 7:1560,1,arjan
10:34,"This is pretty ideal. it puts most of the load on the client, and ofer…",CASSANDRA-1278,"This is pretty ideal. it puts most of the load on the client, and ofers little change  for the user...
",,Architectural solution benefits and drawbacks,7:1563 - 7:1666,1,arjan
10:164,appodictic,CASSANDRA-1278,appodictic,,Comment,7:1671 - 7:1680,1,arjan
10:35,I defnitely agree that having a 100% pure cassandra way to do this is…,CASSANDRA-1278," I defnitely agree that having a 100% pure cassandra way to do this is good.
",,Architectural solution benefits and drawbacks,7:1682 - 7:1759,1,arjan
10:36,I would personally like to see a JMX function like ’nodetool addsstabl…,CASSANDRA-1278,"I would personally like to see a JMX function like ’nodetool addsstable mykeyspace mycf  mysstable-fle’ . Most people can generating and move an SSTable on their own (sstableWriter  +scp) . Those people only need a way to alert cassandra about new SSTables in the data  directory. Doing that is a subset of the work needed to fnd a way to stream it.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",7:1760 - 7:2110,2,arjan
10:165,mdennis,CASSANDRA-1278,mdennis,,Comment,7:2115 - 7:2121,1,arjan
10:37,The attached v2 patch implements the requested proxy server. bin/proxy…,CASSANDRA-1278,"The attached v2 patch implements the requested proxy server. bin/proxyloader  starts the proxy server while proxy.conf, proxy-env.sh and log4j-proxy.conf control the the  confguration of the proxy server. Defaults are provided and described.
As requested, there is no CPT implementation in this patch; existing code using CPT should  be able to use BareMemtableManager directly without too much trouble.
The proxy server accepts calls via Thrift RPC and then eventually streams the results as an  SSTable to C* which will schedule a build of the indexes, bloom flters and secondary indexes.
In addition to the extensive suite of functional tests, testing was done across 5 C* nodes at  RF=3 and 3 proxy nodes all running on EC2 XL instances. stress.py was run on the same  nodes as the proxy and at 4 threads was easily able to saturate the CPU. As expected the  performance on each proxy is marginally higher than native C*. The important diferences  are:  6
* a (much) lower number of threads is required to fully utilize all the available CPU (though  adding more threads did not diminish the throughput).
* the proxy does not return timeouts, but instead just slows input if it’s completely over-  loaded.
* moved the load from C* to the proxies as intended, essentially requiring only one core to  build the indexes/flters once the data is streamed.
",,Existing system architecture description,7:2124 - 8:398,1,arjan
10:38,* a (much) lower number of threads is required to fully utilize all th…,CASSANDRA-1278,"* a (much) lower number of threads is required to fully utilize all the available CPU (though  adding more threads did not diminish the throughput).
* the proxy does not return timeouts, but instead just slows input if it’s completely over-  loaded.
* moved the load from C* to the proxies as intended, essentially requiring only one core to  build the indexes/flters once the data is streamed.
",,Architectural solution benefits and drawbacks,8:1 - 8:397,1,arjan
10:39,opened CASSANDRA-2438 to track exposing the table building via JMX,CASSANDRA-1278,opened CASSANDRA-2438 to track exposing the table building via JMX,,,8:412 - 8:477,1,arjan
10:40,"go ahead and use git to split this up into logical pieces (e.g., inter…",CASSANDRA-1278,"go ahead and use git to split this up into logical pieces (e.g., internals changes,  proxy server, tests).
where does throughput max out in rows/s as you add clients (proxy nodes), vs stress-  against-plain-cassandra?
",,,8:493 - 8:712,1,arjan
10:41,"Matt responded on IM,  bq. RF=3, 20 proxies, everything on XL nodes se…",CASSANDRA-1278,"Matt responded on IM,  bq. RF=3, 20 proxies, everything on XL nodes seems to be the magic number.âĂĆâĂĆC*  bumps up and of max CPU while the proxies are running.âĂĆâĂĆeach C* node sustains  ~150Mb/s incoming.âĂĆâĂĆAll the proxies fnished at roughly the same time (between 810  and 825 seconds).âĂĆâĂĆThere were 200M keys inserted by the stress into the proxies av-  eraging a bit over 3000 inserts/sec/core on the proxies with an ""efective"" insert rate on the  cluster of 12K+ /sec/core.",,,8:726 - 8:1212,1,arjan
10:42,rebased v2 attached,CASSANDRA-1278,rebased v2 attached,,,8:1228 - 8:1246,1,arjan
10:166,mdennis,CASSANDRA-1278,mdennis,,Comment,8:1253 - 8:1259,1,arjan
10:43,"The above numbers are correct, but at RF=1 (I mistyped it in IM). At b…",CASSANDRA-1278,"The above numbers are correct, but at RF=1 (I mistyped it in IM).
At both RF=1 and RF=3 there were 5 M1.XL C* nodes and 20 M1.XL proxy nodes, each  doing 10M inserts.
At RF=1 C* nodes bump up against max CPU while the proxies are running from building  indexes/flters and compacting. The nodes sustain ~150Mb/s incoming trafc each. All the  proxies fnished between 810 and 825 seconds. With 20 proxies * 10M inserts/proxy * RF=1  that is 200M inserts across 4 * 20 cores on the proxies or 4 * 5 cores when measured by  cluster cores resulting in a bit over 3K inserts/sec/core on the proxies and a bit over 12K  ""efective inserts""/sec/core on the cluster.
At RF=3 the results are as expected, taking about 2560 seconds to fnish (so about 100  seconds longer than expected when increasing from RF=1). This is just shy of 3K insert-  s/sec/core on the proxies and little under 12K ""efective inserts""/sec/core on the cluster.
As it looked like 20 proxies maxed out 5 nodes at RF=1 one would expect RF=3 to take  roughly 3 times as long. Network trafc was more variable though at RF=3 as it bounced  between 80-200 Mb/s.
There were no timeouts in either case.
",,Architectural solution benefits and drawbacks,8:1262 - 8:2423,1,arjan
10:167,stuhood,CASSANDRA-1278,stuhood,,Comment,8:2428 - 8:2434,1,arjan
10:44,Very interesting work here!,CASSANDRA-1278,"Very interesting work here!
",,Architectural solution benefits and drawbacks,8:2437 - 8:2465,1,arjan
10:45,Did you accidentally remove the bufering for non-streaming connections…,CASSANDRA-1278,"Did you accidentally remove the bufering for non-streaming connections in IncomingTCP-  Connection?
",,,8:2468 - 8:2568,1,arjan
10:46,What kind of failures are supported during a load? What’s the proper b…,CASSANDRA-1278,"What kind of failures are supported during a load? What’s the proper behavior for  fush_proxy when some hosts fail?
",,,8:2571 - 8:2687,1,arjan
10:47,Could we avoid coding in knowledge of the fle format in the inner loop…,CASSANDRA-1278,Could we avoid coding in knowledge of the fle format in the inner loop of IncomingLoad-  erStreamReader?,,,9:3 - 9:106,1,arjan
10:48,"I would much, much prefer that non-fle-format-specifc framing be added…",CASSANDRA-1278,"I would much, much prefer that non-fle-format-specifc framing be added,  and it would have the added beneft of not requiring as many system calls (4 per row vs 2  per frame)",,Architectural solution benefits and drawbacks,9:108 - 9:280,1,arjan
10:49,"What is the beneft of using an independent protocol for ""Loader"" strea…",CASSANDRA-1278,"What is the beneft of using an independent protocol for ""Loader"" streams?
",,,9:285 - 9:359,1,arjan
10:50,"Again, awesome.",CASSANDRA-1278,"Again, awesome.
",,Architectural solution benefits and drawbacks,9:360 - 9:376,1,arjan
10:168,mdennis,CASSANDRA-1278,mdennis,,Comment,9:381 - 9:387,1,arjan
10:51,It was intentional as previously only the streaming was bufered (at 4k…,CASSANDRA-1278,It was intentional as previously only the streaming was bufered (at 4k) but the bulk of the  work uses the socket channel; only the size and header are read from input and the header  uses readFully. ,,Existing system architecture description,9:503 - 9:702,1,arjan
10:53,It adds an extra call when constructing the stream because of the size…,CASSANDRA-1278,"It adds an extra call when constructing the stream because of the size but  avoids copying the data into the bufer (in the BuferedStream) and then into the byte array.
",,Architectural solution benefits and drawbacks,9:703 - 9:871,1,arjan
10:54,We could lower some of those calls by reading both the magic and the h…,CASSANDRA-1278,We could lower some of those calls by reading both the magic and the header int at the  same time into a ByteBufer and then viewing it as an IntBufer ,,Architectural design configuration,9:872 - 9:1021,1,arjan
10:55,but I don’t think that buys  you anything as it only happens on a new…,CASSANDRA-1278,"but I don’t think that buys  you anything as it only happens on a new connection. It also avoids bugs where something  has been read from the socket into the bufer and then the socket channel is used later even  though the bufer may not have been fully drained.
",,"Architectural solution benefits and drawbacks
Assumptions",9:1022 - 9:1284,2,arjan
10:56,On the server side all failures result in the same behaviour: close so…,CASSANDRA-1278,"On the server side all failures result in the same behaviour: close socket, delete temp fles.
On the client side if fushing of a BareMemtable to the server fails the proxy will log it and  continue running.
In both cases any data that was being loaded via the proxy needs to be reloaded.
",,Existing system architecture description,9:1351 - 9:1641,1,arjan
10:57,log failed fushes and continue running; any data that was being loaded…,CASSANDRA-1278,log failed fushes and continue running; any data that was being loaded via the proxy needs  to be reloaded.,,Existing system architecture description,9:1722 - 9:1828,1,arjan
10:58,We could construct something that bufers up X amount of data and then…,CASSANDRA-1278,We could construct something that bufers up X amount of data and then frames the data  being sent and change the inner loop to decompose that,,Architectural design configuration,9:2125 - 9:2265,1,arjan
10:59,"but it’s extra complexity, code and  overhead. If we bufer it on the o…",CASSANDRA-1278,"but it’s extra complexity, code and  overhead. If we bufer it on the other side we consume more memory for a longer period of  time (thus giving it a better chance that it needs to promoted and/or compacted) adding to  the already problematic GC pressure. If we don’t bufer the rows we end up framing every  row which is additional data and still doing 2 out of the 4 transfers we do now on data of  the same size (since the frames wouldn’t be any bigger). BTW, 2 or 4 xfes in this situation  doesn’t afect the performance; the latency on the network and CPU of compaction and  indexing building dwarf any gains to be made here.",,Architectural solution benefits and drawbacks,9:2267 - 9:2894,1,arjan
10:60,The current approach has the added  beneft that debugging is easy beca…,CASSANDRA-1278,"The current approach has the added  beneft that debugging is easy because it’s clear where the key and row boundaries are.
",,Architectural solution benefits and drawbacks,9:2896 - 9:3019,1,arjan
10:61,"If you’re comparing to the streams we use for repair and similar, they…",CASSANDRA-1278,"If you’re comparing to the streams we use for repair and similar, they require table names  and byte ranges be known up front. While a proxy could just generate a random name, it  doesn’t know the sizes because it doesn’t have a SSTable on disk (or bufered in memory).
There is also no way for a node to request a retry from a proxy if the stream fails because the  proxy won’t have the data and in general is probably frewalled of C*-to-Proxy connections.
8
And even if we did, we’d still have a bunch of small sessions because the proxy doesn’t know  when a client is going to stop sending data to it. In the most general sense it could be a  constant thing; a client may just continually pump an RSS feed or stock ticks or something  into it. tl;dr simplicity and code reduction.
",,Architectural solution benefits and drawbacks,9:3109 - 10:324,1,arjan
10:169,stuhood,CASSANDRA-1278,stuhood,,Comment,10:369 - 10:375,1,arjan
10:62,It was the other way around IIRC: (non-encrypted) streaming used chann…,CASSANDRA-1278,"It was the other way around IIRC: (non-encrypted) streaming used channel.transferTo,  which bypassed the bufering entirely. The bufering was for internode messaging: see  CASSANDRA-1943.
",,Existing system architecture description,10:453 - 10:640,1,arjan
10:63,You’re already bufering rows in StreamingProxyFlusher.buferRow: the ch…,CASSANDRA-1278,You’re already bufering rows in StreamingProxyFlusher.buferRow: the change would sim-  ply be to continue to bufer rows until a threshold was reached.,,Architectural component behavior and structure,10:836 - 10:985,1,arjan
10:64,The beneft here is that  the code on the receiving side doesn’t need t…,CASSANDRA-1278,"The beneft here is that  the code on the receiving side doesn’t need to change when the proxy starts sending it a  diferent SSTable version/format. I’ve never heard of somebody regretting having framing  in a protocol: it’s always the other way around.
",,Architectural solution benefits and drawbacks,10:987 - 10:1240,1,arjan
10:65,"Also, an SSTable version (as usually held by Descriptor) should be add…",CASSANDRA-1278,"Also, an SSTable version (as usually held by Descriptor) should be added to the header  of your protocol",,Architectural component behavior and structure,10:1241 - 10:1344,1,arjan
10:66,so that clients don’t break by sending unversioned blobs: not having v…,CASSANDRA-1278,"so that clients don’t break by sending unversioned blobs: not having ver-  sioning is my primary complaint vis-a-vis BinaryMemtables.
",,"Architectural solution benefits and drawbacks
User requirement",10:1346 - 10:1480,2,arjan
10:67,I was talking about bufering on the client side: the server side can d…,CASSANDRA-1278,"I was talking about bufering on the client side: the server side can do one system call to  fush to disk, such that it never enters userspace.",,Architectural design configuration,10:1568 - 10:1709,1,arjan
10:170,jbellis,CASSANDRA-1278,jbellis,,Comment,10:1725 - 10:1731,1,arjan
10:68,We’ve had enough trouble debugging streaming when people use it all th…,CASSANDRA-1278,"We’ve had enough trouble debugging streaming when people use it all the time for repair. I  shudder to think of the bugs we’ll introduce to a second-class protocol that gets used slightly  more often than BMT.
",,"Architectural solution benefits and drawbacks
Assumptions",10:1865 - 10:2075,2,arjan
10:69,Maybe we’ve been too clever here: why not just write out the full ssta…,CASSANDRA-1278,"Maybe we’ve been too clever here: why not just write out the full sstable on the client,  and stream it over (indexes and all) so that",,Architectural design configuration,10:2076 - 10:2209,1,arjan
10:70,"we move the [primary] index build of the server, which should give a n…",CASSANDRA-1278,"we move the [primary] index build of the server, which should give a nice performance  boost",,Architectural tactics,10:2214 - 10:2305,1,arjan
10:71,we have flenames and sizes ready to go so streaming will be happy,CASSANDRA-1278,we have flenames and sizes ready to go so streaming will be happy,,Architectural solution benefits and drawbacks,10:2310 - 10:2374,1,arjan
10:72,We’re still talking about a minor change to streaming of recognizing t…,CASSANDRA-1278,"We’re still talking about a minor change to streaming of recognizing that we’re getting all the  components and not just data, but that’s something we can deal with at the StreamInSession  level, I don’t think we’ll need to change the protocol itself.
",,Architectural design configuration,10:2377 - 10:2629,1,arjan
10:171,stuhood,CASSANDRA-1278,stuhood,,Comment,10:2634 - 10:2640,1,arjan
10:73,"As much as I want to merge the protocols, I’m not sure I like the limi…",CASSANDRA-1278,"As much as I want to merge the protocols, I’m not sure I like the limitations this puts on  clients: being able to send a stream without needing local tempspace is very, very benefcial,  9
IMO (for example, needing tempspace was by far the most annoying limitation of a Hadoop  LuceneOutputFormat I worked on).
",,"Architectural solution benefits and drawbacks
Assumptions",10:2783 - 11:123,2,arjan
10:74,"With versioned messaging, changing the protocol is at least possible,…",CASSANDRA-1278,"With versioned messaging, changing the protocol is at least possible, if painful... my  _dream_ would be:  # Deprecate the fle ranges in Streaming session objects, to be replaced with framing in the  stream  # Move the Streaming session object to a header of the streaming connection (almost iden-  tical to LoaderStream)  # Deprecate the Messaging based setup and teardown for streaming sessions: a sender initi-  ates a stream by opening a streaming connection, and tears it down with success codes after  each fle (again, like this protocol)",,Architectural design configuration,11:373 - 11:916,1,arjan
10:75,tl;dr: I’d prefer some slight adjustments to Matt’s protocol (mentione…,CASSANDRA-1278,"tl;dr: I’d prefer some slight adjustments to Matt’s protocol (mentioned above) over requiring  tempspace on the client.
",,Architectural solution benefits and drawbacks,11:925 - 11:1045,1,arjan
10:172,jbellis,CASSANDRA-1278,jbellis,,Comment,11:1050 - 11:1056,1,arjan
10:76,"OTOH, we already have a no-tempspace-required API for the client",CASSANDRA-1278,"OTOH, we already have a no-tempspace-required API for the client",,Existing system architecture description,11:1059 - 11:1122,1,arjan
10:77,It’s totally  reasonable to require tempspace for bulkload in exchange…,CASSANDRA-1278,"It’s totally  reasonable to require tempspace for bulkload in exchange for an extra 2x? performance win.
",,Architectural tactics,11:1125 - 11:1230,1,arjan
10:173,stuhood,CASSANDRA-1278,stuhood,,Comment,11:1235 - 11:1241,1,arjan
10:78,There are defnitely ways we can get this performance back on the serve…,CASSANDRA-1278,There are defnitely ways we can get this performance back on the server side (in the fu-  ture) without afecting clients.,,Architectural solution benefits and drawbacks,11:1354 - 11:1474,1,arjan
10:79,"In particular, we could build the index behind the data as it  arrives…",CASSANDRA-1278,"In particular, we could build the index behind the data as it  arrives:",,Architectural design configuration,11:1476 - 11:1546,1,arjan
10:80,the only blocker for doing this currently is that we need an estimated…,CASSANDRA-1278,"the only blocker for doing this currently is that we need an estimated size to start  building the bloom flter, but I see multiple ways around that (including partitioning the  flter, which has other benefts: see CASSANDRA-2466).
",,Architectural solution benefits and drawbacks,11:1548 - 11:1778,1,arjan
10:81,"Additionally, our existing streaming protocol requires that a client b…",CASSANDRA-1278,"Additionally, our existing streaming protocol requires that a client be able to communi-  cate out of band in our Messaging layer, where there be dragons. Honestly, I’d like to call  Matt’s protocol (plus framing and a version) ""streaming v2"".
",,Architectural solution benefits and drawbacks,11:1779 - 11:2023,1,arjan
10:82,"But if you feel strongly about it, then by all means... I’m not trying…",CASSANDRA-1278,"But if you feel strongly about it, then by all means... I’m not trying to block progress  here.
",,Architectural solution benefits and drawbacks,11:2024 - 11:2120,1,arjan
10:174,cburroughs,CASSANDRA-1278,cburroughs,,Comment,11:2125 - 11:2134,1,arjan
10:83,There is literature on scalable or dynamic BloomFilters to do this in…,CASSANDRA-1278,There is literature on scalable or dynamic BloomFilters to do this in a mathematically  sound way,,"Architectural solution benefits and drawbacks
Other system architectural solutions",11:2376 - 11:2472,2,arjan
10:84,For example?,CASSANDRA-1278,"For example?
",,,11:2595 - 11:2607,1,arjan
10:175,jbellis,CASSANDRA-1278,jbellis,,Comment,11:2613 - 11:2619,1,arjan
10:85,My main concern is that we have a single protocol for all streaming.,CASSANDRA-1278,My main concern is that we have a single protocol for all streaming.,,Technical debt,11:2705 - 11:2772,1,arjan
10:86,"Less concerned about  which protocol that is, although my impression i…",CASSANDRA-1278,"Less concerned about  which protocol that is, although my impression is that it’s easier to do bulk load w/ existing  10
(tested and debugged!) streaming, than to make ""streaming v2"" backwards compatible w/  the existing one.
",,"Architectural solution benefits and drawbacks
Assumptions",11:2774 - 12:106,2,arjan
10:87,"On the other hand, I don’t think it’s *strictly* necessary to require…",CASSANDRA-1278,"On the other hand, I don’t think it’s *strictly* necessary to require streaming compati-  bility since a cluster can run fne without it for a few days while doing a rolling upgrade.
(Although it does make the ""upgrade a single node, wait for a week to see how it does""  approach less viable.)",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",12:107 - 12:399,3,arjan
10:176,cburroughs,CASSANDRA-1278,cburroughs,,Comment,12:406 - 12:415,1,arjan
10:88,"References  [1] P. Almeida, C. Baquero, N. Preguica, and D. Hutchison.…",CASSANDRA-1278,"References  [1] P. Almeida, C. Baquero, N. Preguica, and D. Hutchison. Scalable  bloom  filters. Information Processing Letters, 101(6):255â˘ A¸S261, March  2007.
[2] Deke Guo, Jie Wu, Honghui Chen, Ye Yuan, and Xueshan Luo. The  dynamic bloom filters. IEEE Transactions on Knowledge and Data  Engineering, 22(1):120â˘ A¸S133, January 2010.
And also ""Dynamic Bloom Filters: Analysis and usability"" which is not appear to be in  a journal but does cast some doubt on the practicality. Google Scholar can fnd PDFs for  all of these.
",,Other system architectural solutions,12:544 - 12:1077,1,arjan
10:177,jbellis,CASSANDRA-1278,jbellis,,Comment,12:1082 - 12:1088,1,arjan
10:89,Thanks for the links. Chained BF looks like a lot of complexity to add…,CASSANDRA-1278,"Thanks for the links. Chained BF looks like a lot of complexity to add.
",,"Architectural solution benefits and drawbacks
Assumptions",12:1197 - 12:1269,2,arjan
10:90,Do we really need to go there?,CASSANDRA-1278,Do we really need to go there?,,,12:1270 - 12:1299,1,arjan
10:91,We have the ability to calculate approximate row counts  before we sta…,CASSANDRA-1278,"We have the ability to calculate approximate row counts  before we start streaming: in the bulk load and bootstrap case we obviously know how many  rows we have; in the repair case, we can estimate from the in-memory row index sample.
",,Existing system architecture description,12:1301 - 12:1536,1,arjan
10:178,stuhood,CASSANDRA-1278,stuhood,,Comment,12:1541 - 12:1547,1,arjan
10:92,That works too,CASSANDRA-1278,That works too,,Architectural solution benefits and drawbacks,12:1638 - 12:1651,1,arjan
10:93,"I’m not sure it is necessary for this particular ticket, but ""expected…",CASSANDRA-1278,"I’m not sure it is necessary for this particular ticket, but ""expected keys""  could certainly be an optional feld (via messaging versioning) in the header for newer stream-  ing clients.
",,"Architectural component behavior and structure
Assumptions",12:1654 - 12:1841,2,arjan
10:179,mdennis,CASSANDRA-1278,mdennis,,Comment,12:1846 - 12:1852,1,arjan
10:94,"Yes, I see now; that was unintentional and has been corrected.",CASSANDRA-1278,"Yes, I see now; that was unintentional and has been corrected.
",,Architectural solution benefits and drawbacks,12:2138 - 12:2201,1,arjan
10:96,"Yes, I understood what you were suggesting; that was precisely the ext…",CASSANDRA-1278,"Yes, I understood what you were suggesting; that was precisely the extra bufering I was  talking about. Bufering more than one row on the client side means we keep larger bufers  around and increase the GC pressure which is already a problem on the proxy because of  thrift.",,Architectural solution benefits and drawbacks,13:609 - 13:882,1,arjan
10:97,"That being said, I’ve changed the protocol to be framed but the proxy…",CASSANDRA-1278,"That being said, I’ve changed the protocol to be framed but the proxy still just sends  one row at a time (each row in a frame) to avoid the problems mentioned. If we later wanted  to change the proxy to bufer more or implement a diferent client the server won’t care.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",13:884 - 13:1153,2,arjan
10:98,"Added, along with a protocol version, to the header.",CASSANDRA-1278,"Added, along with a protocol version, to the header.
",,Existing system architecture description,13:1406 - 13:1459,1,arjan
10:99,"I was too, it’s primarily the bufering on the proxy side that is the p…",CASSANDRA-1278,"I was too, it’s primarily the bufering on the proxy side that is the problem. The goal  is to get the data of the proxy as quickly as possible. As quickly as possible is one row  at a time because of the serialization format (size must be known before entire row can be  written).
",,Motivation of design issue,13:1711 - 13:1992,1,arjan
10:100,that’s because the streaming used for repair is complex and fragile; i…,CASSANDRA-1278,"that’s because the streaming used for repair is complex and fragile; independent streams  are tightly coupled in a session, sizes must be known up front, retries are complex and re-  quire out-of-band messaging between nodes, everything is ""bufered"" on disk before building  of any indexes/flters starts, et cetera.",,Architectural solution benefits and drawbacks,13:2353 - 13:2667,1,arjan
10:101,In comparison the protocol used for loading is ex-  tremely simple; if…,CASSANDRA-1278,"In comparison the protocol used for loading is ex-  tremely simple; if it makes you feel better we could add a CRC/MD5 to the stream.
",,Architectural solution benefits and drawbacks,13:2669 - 13:2803,1,arjan
10:102,One of the main goals of the bulk loading was that no local/temp stora…,CASSANDRA-1278,One of the main goals of the bulk loading was that no local/temp storage was required  on the client; that has been the plan from the beginning.,,Architectural solution benefits and drawbacks,14:341 - 14:484,1,arjan
10:103,"If you have something that gener-  ates full tables, indexes and flter…",CASSANDRA-1278,"If you have something that gener-  ates full tables, indexes and flters it makes more sense to generate them locally by using the  SSTableWriter directly, push them to the box and then using CASSANDRA-2438 to ""add""  them to the node. ",,"Architectural design configuration
Architectural solution benefits and drawbacks",14:486 - 14:719,2,arjan
10:104,Maybe we could add this as an option to the proxy,CASSANDRA-1278,Maybe we could add this as an option to the proxy,,Architectural design configuration,14:720 - 14:768,1,arjan
10:105,to make it just a  bit easier to do but it certainly isn’t suitable as…,CASSANDRA-1278,to make it just a  bit easier to do but it certainly isn’t suitable as the only option,,Architectural solution benefits and drawbacks,14:770 - 14:855,1,arjan
10:106,"Overall though, I’m not really a fan of  requiring temp space on the p…",CASSANDRA-1278,"Overall though, I’m not really a fan of  requiring temp space on the proxy.",,Architectural solution benefits and drawbacks,14:939 - 14:1013,1,arjan
10:107,The problem I can think of at the moment is that for large clusters th…,CASSANDRA-1278,"The problem I can think of at the moment is that for large clusters this is a lot of seeking on  the proxy since you need to generate one table for every replica set or a lot of repeated passes  on the same data. Even if you do this or make it ""very fast"" (tm) it doesn’t much matter  because as you transfer small tables to nodes they will almost immediately be compacted  meaning the work saved to generate the indexes and flters was wasted and was only a small  percentage of the overall work moved of of the cluster. Compacting the tables on the clients  before sending them would just make a questionable idea worse...
",,Architectural solution benefits and drawbacks,14:1016 - 14:1640,1,arjan
10:108,Exactly; requiring temp space seems like an anti-feature to me.,CASSANDRA-1278,Exactly; requiring temp space seems like an anti-feature to me.,,Architectural solution benefits and drawbacks,14:2111 - 14:2173,1,arjan
10:109,The protocol is now versioned (as well as the table format) so this is…,CASSANDRA-1278,The protocol is now versioned (as well as the table format) so this is possible (though  certainly on a diferent ticket).,,Existing system architecture description,15:10 - 15:130,1,arjan
10:110,If we change the existing streaming to use this protocol,CASSANDRA-1278,If we change the existing streaming to use this protocol,,Architectural design configuration,15:132 - 15:187,1,arjan
10:111,I  think we end up with something a lot less fragile and a lot less co…,CASSANDRA-1278," I  think we end up with something a lot less fragile and a lot less complex.
",,"Architectural solution benefits and drawbacks
Assumptions",15:188 - 15:266,2,arjan
10:112,Essentially the sender is in control and keeps retrying until the rece…,CASSANDRA-1278,"Essentially the sender is in control and keeps retrying until the receiver has the data; dep-  recate sessions all together. When node A wants to send things to node B, it records that  fact in the system table. For each entry it sends the fle using the bulk loading protocol  and continues retrying until the fle is excepted. For each range it wants to send it frames  the entire range. The only complex part is preventing removal of the SSTable on the source  (node A) until it was successfully streamed to the destination (node B).
",,Architectural design configuration,15:267 - 15:802,1,arjan
10:113,ditto,CASSANDRA-1278,ditto,,Architectural solution benefits and drawbacks,15:938 - 15:942,1,arjan
10:180,jbellis,CASSANDRA-1278,jbellis,,Comment,15:949 - 15:955,1,arjan
10:114,"No, it hasn’t.",CASSANDRA-1278,"No, it hasn’t.
",,Architectural solution benefits and drawbacks,15:1107 - 15:1122,1,arjan
10:115,"But we can leave that aside for now; we already have ""build everything…",CASSANDRA-1278,"But we can leave that aside for now; we already have ""build everything else from the sstable  bits"" code, so we can add ""take advantage of local storage to ofoad that from the server""  later as an optimization.
",,"Architectural design configuration
Architectural tactics",15:1123 - 15:1333,2,arjan
10:116,"You’re going to need some kind ""when all of this is done, run this cal…",CASSANDRA-1278,"You’re going to need some kind ""when all of this is done, run this callback"" construct for  bootstrap/node movement. Currently we call that a Session.
",,Architectural design configuration,15:1372 - 15:1523,1,arjan
10:117,Sounds exactly like what existing streaming does.,CASSANDRA-1278,"Sounds exactly like what existing streaming does.
",,Architectural solution benefits and drawbacks,15:1731 - 15:1781,1,arjan
10:119,Currently we do this by simply maintaining a reference to the SSTR obj…,CASSANDRA-1278,Currently we do this by simply maintaining a reference to the SSTR object so the GC  doesn’t delete it.,,Existing system architecture description,15:1860 - 15:1962,1,arjan
10:118,There’s no need to make it more complicated than that.,CASSANDRA-1278,"There’s no need to make it more complicated than that.
",,Architectural solution benefits and drawbacks,15:1964 - 15:2018,1,arjan
10:120,"I took a look at the patch. Just superfcially, there’s a lot of gratui…",CASSANDRA-1278,"I took a look at the patch. Just superfcially, there’s a lot of gratuitous change in there,  e.g., refactoring test_thrift_server.py. Those changes also need to be moved to a separate  patch (again, I suggest git) so reviewers can easily distinguish refactoring from ticket-specifc  changes.
",,,15:2020 - 15:2312,1,arjan
10:181,jbellis,CASSANDRA-1278,jbellis,,Comment,15:2317 - 15:2323,1,arjan
10:121,I think we’ve been over-engineering the problem,CASSANDRA-1278,I think we’ve been over-engineering the problem,,"Architectural solution benefits and drawbacks
Assumptions",15:2326 - 15:2372,2,arjan
10:122,Ed was on the right track:,CASSANDRA-1278,Ed was on the right track:,,Architectural solution benefits and drawbacks,15:2375 - 15:2400,1,arjan
10:123,"(This is, btw, the HBase bulk load approach, which despite some clunki…",CASSANDRA-1278,"(This is, btw, the HBase bulk load approach, which despite some clunkiness does seem  to solve the problem for those users.)  The main drawback is that because of Cassandra’s replication strategies, data from a naively-  written sstable could span many nodes -- even the entire cluster.
",,Architectural solution benefits and drawbacks,16:1 - 16:288,1,arjan
10:124,So we can improve the experience a lot with a simple tool that just st…,CASSANDRA-1278,"So we can improve the experience a lot with a simple tool that just streams ranges from a  local table to the right nodes. Since it’s doing the exact thing that existing node movement  needs -- sending ranges from an existing sstable -- it should not require any new code from  Streaming.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",16:289 - 16:578,2,arjan
10:125,Sylvain volunteered to take a stab at this.,CASSANDRA-1278,"Sylvain volunteered to take a stab at this.
",,,16:579 - 16:623,1,arjan
10:182,slebresne,CASSANDRA-1278,slebresne,,Comment,16:628 - 16:636,1,arjan
10:126,"Attaching patch that implements the ""simpler"" idea.",CASSANDRA-1278,"Attaching patch that implements the ""simpler"" idea.",,Architectural solution benefits and drawbacks,16:639 - 16:689,1,arjan
10:127,It provide a new utility  ’sstableloader’ (a fat client basically) tha…,CASSANDRA-1278,"It provide a new utility  ’sstableloader’ (a fat client basically) that given a sstable (or more) will stream the relevant  parts of that sstable to the relevant nodes.
The tool tries to be self-documented but basically you must have a sstable with -Data  and -Index component (we really need a -Index component to be able to do anything) in a  directory dir whose name is the keyspace and call ’sstableloader dir’.
Alternatively, if dir seats on one of the machine of the cluster, you can simply use a JMX  call with as argument the path to dir.
",,Existing system architecture description,16:691 - 16:1240,1,arjan
10:128,Can we give it an optional keyspace name argument to override the dire…,CASSANDRA-1278,"Can we give it an optional keyspace name argument to override the directory name?
",,,16:1254 - 16:1335,1,arjan
10:183,slebresne,CASSANDRA-1278,slebresne,,Comment,16:1341 - 16:1349,1,arjan
10:129,"I’d love to, but as it turns out it is fairly heavily hardwired in Des…",CASSANDRA-1278,"I’d love to, but as it turns out it is fairly heavily hardwired in Descriptor that  the keyspace name is the directory where the fle sits. And by hardwired I mean that even  if you add a constructor to Descriptor to decorrelate the ksname feld from the directory  argument this doesn’t work, because streaming only transmit the name of the fle (including  the directory), not the ksname feld and thus would get the wrong name.
",,Architectural solution benefits and drawbacks,16:1352 - 16:1779,1,arjan
10:130,"That is, I don’t think we can do that without adding a new argument to…",CASSANDRA-1278,"That is, I don’t think we can do that without adding a new argument to the stream header,  which felt a bit overkill at frst (it’s probably doable though).
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",16:1780 - 16:1936,3,arjan
10:131,can we move script + source to tools/ like sstabledebug?,CASSANDRA-1278,can we move script + source to tools/ like sstabledebug?,,,16:1950 - 16:2005,1,arjan
10:132,"The server performed HH to the loader:  INFO 11:17:23,184 Node /127.0.…",CASSANDRA-1278," The server performed HH to the loader:  INFO 11:17:23,184 Node /127.0.0.2 is now part of the cluster  INFO 11:17:23,189 InetAddress /127.0.0.2 is now UP  INFO 11:17:29,222 Started hinted handoff for endpoint /127.0.0.2  INFO 11:17:29,353 Finished hinted handoff of 0 rows to endpoint /127.0.0.2  Shouldn’t we start in client-only mode?
",,,16:2020 - 16:2357,1,arjan
10:133,I didn’t do it because if I’m correct the tool stuf don’t go into rele…,CASSANDRA-1278,"I didn’t do it because if I’m correct the tool stuf don’t go into releases (which  I believe is the reason why we don’t have cli, sstable2json, ... in tools). I fgured that’s not  necessarily something we want user to grab the source to get. But I suppose we can if we  want (at least the script + BulkLoader.java, I’d be in favor of leaving SSTableLoader where  it is).",,,16:2373 - 16:2742,1,arjan
10:134,"+ outputHandler.output(""Starting client and waiting 15 seconds  for go…",CASSANDRA-1278,"+ outputHandler.output(""Starting client and waiting 15 seconds  for gossip ..."");  + try  + {  + // Init gossip  + StorageService.instance.initClient();  It is in client-only mode as far as I can tell. Maybe client-only mode is screwed up though,  I don’t know.
",,,17:17 - 17:279,1,arjan
10:184,jbellis,CASSANDRA-1278,jbellis,,Comment,17:284 - 17:290,1,arjan
10:135,"also, suggest giving a little more visibility into the streaming proce…",CASSANDRA-1278,"also, suggest giving a little more visibility into the streaming process:",,"Assumptions
Run-time quality issues",17:413 - 17:485,2,arjan
10:136,streamed N sstables of M (P%)  [then later]  waiting for targets to re…,CASSANDRA-1278,"streamed N sstables of M (P%)  [then later]  waiting for targets to rebuild indexes...
",,Run-time quality issues,17:488 - 17:575,1,arjan
10:185,jbellis,CASSANDRA-1278,jbellis,,Comment,17:580 - 17:586,1,arjan
10:137,"INFO 11:38:45,826 InetAddress /127.0.0.2 is now dead. INFO 11:38:56,84…",CASSANDRA-1278,"INFO 11:38:45,826 InetAddress /127.0.0.2 is now dead.
INFO 11:38:56,844 FatClient /127.0.0.2 has been silent for 30000ms,  removing from gossip  looks like it does recognize the client-only fag, there’s just a bug there w/ HH.
",,Run-time quality issues,17:590 - 17:818,1,arjan
10:138,attached fx to CASSANDRA-2668,CASSANDRA-1278,attached fx to CASSANDRA-2668,,,17:868 - 17:896,1,arjan
10:186,brandon.williams,CASSANDRA-1278,brandon.williams,,Comment,17:903 - 17:918,1,arjan
10:139,"f it printed the flename and the  time it took for each time, since ju…",CASSANDRA-1278,"f it printed the flename and the  time it took for each time, since just having the percentages reset is a bit confusing. Also,  this should respect SS.RING_DELAY instead of arbitrarily choosing an amount of time to  wait for gossip.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",17:958 - 17:1192,2,arjan
10:140,"I loaded 10M rows with stress.java defaults, then bulkloaded them from…",CASSANDRA-1278,"I loaded 10M rows with stress.java defaults, then bulkloaded them from one machine to  another in 75s (accounting for gossip delay.) This totaled 3.1G of data, so about 44MB/s.
Conversely, it took about 15 minutes to load with stress.
",,,17:1193 - 17:1429,1,arjan
10:142,bq. if I’m correct the tool stuf don’t go into releases  we should fx…,CASSANDRA-1278,"bq. if I’m correct the tool stuf don’t go into releases  we should fx that then.
bq. (which I believe is the reason why we don’t have cli, sstable2json, ... in tools)  cli is more ""core"" than a tool. sstable2json hasn’t been moved yet because my ant-fu wasn’t  up to the challenge (CASSANDRA-1805)",,,17:1443 - 17:1740,1,arjan
10:187,jbellis,CASSANDRA-1278,jbellis,,Comment,18:5 - 18:11,1,arjan
10:143,"Part of me likes that idea, but it might be dangerous to print a flena…",CASSANDRA-1278,"Part of me likes that idea, but it might be dangerous to print a flename and have the  user assume it’s ""done,"" when in reality it only has the data component streamed (with the  rest pending rebuild on the target) so if the target is killed & reset the tmp data fle will  just be deleted.
",,"Assumptions
Risks",18:154 - 18:444,2,arjan
10:144,"Repeated the bulkload test, this time loading into a 3 node cluster  (…",CASSANDRA-1278,"Repeated the bulkload test, this time loading into a 3 node cluster  (rf=1) and it completed in about 41 seconds (gossip delay adjusted.) Approximately 77MB/s.
",,,18:467 - 18:627,1,arjan
10:188,slebresne,CASSANDRA-1278,slebresne,,Comment,18:632 - 18:640,1,arjan
10:145,The fact that the percentages reset is really just a bug (I test at fr…,CASSANDRA-1278,"The fact that the percentages reset is really just a bug (I test at frst with only one sstable,  my bad). ",,Run-time quality issues,18:784 - 18:889,1,arjan
10:146,I also agree with Jonathan’s objection about printing the  flename. An…,CASSANDRA-1278,"I also agree with Jonathan’s objection about printing the  flename. And in general I’m not sure giving too much information is really necessary.
",,"Architectural solution benefits and drawbacks
Assumptions",18:911 - 18:1056,2,arjan
10:147,"Yes, I think this is the fat client that wasn’t respecting it, it was…",CASSANDRA-1278,"Yes, I think this is the fat client that wasn’t respecting it, it was waiting for an hard-  coded time of 5 seconds, which is almost always not enough.",,"Assumptions
Run-time quality issues",18:1102 - 18:1252,2,arjan
10:148,I’ve updated SS.initClient() to  use RING_DELAY instead.,CASSANDRA-1278,"I’ve updated SS.initClient() to  use RING_DELAY instead.
",,Architectural component behavior and structure,18:1254 - 18:1310,1,arjan
10:149,Attaching v2 that:  * use RING_DELAY  * update the progress indication…,CASSANDRA-1278,"Attaching v2 that:  * use RING_DELAY  * update the progress indication so that percentage works. It also add for each host the  number of fles that should be transfered to it and how many have already been. Lastly it  adds a total percentage as well as approximate transfer rate infos.
",,Architectural design configuration,18:1312 - 18:1598,1,arjan
10:189,jbellis,CASSANDRA-1278,jbellis,,Comment,18:1603 - 18:1609,1,arjan
10:150,+1,CASSANDRA-1278,+1,,Architectural solution benefits and drawbacks,18:1612 - 18:1613,1,arjan
10:151,Committed,CASSANDRA-1278,Committed,,,18:1761 - 18:1769,1,arjan
10:190,slebresne,CASSANDRA-1278,slebresne,,Comment,18:1776 - 18:1784,1,arjan
10:152,Note that I’m marking this resolved since that has been committed. How…,CASSANDRA-1278,"Note that I’m marking this resolved since that has been committed. However, as  it stands sstableloader doesn’t handler failure very well (because streaming doesn’t). Once  CASSANDRA-2433 is committed, this can be easily improved.
",,Architectural solution benefits and drawbacks,18:1787 - 18:2018,1,arjan
11:1,Allow Concurrent Schema Migrations,CASSANDRA-1391,Allow Concurrent Schema Migrations,,User requirement,3:52 - 3:85,1,arjan
11:2,CASSANDRA-1292 fxed multiple migrations started from the same node to…,CASSANDRA-1391,"CASSANDRA-1292 fxed multiple migrations started from the same node to properly queue them-  selves, but it is still possible for migrations initiated on diferent nodes to confict and leave the  cluster in a bad state. ",,Run-time quality issues,3:105 - 3:322,1,arjan
11:3,Since the system_add/drop/rename methods are accessible directly from…,CASSANDRA-1391,"Since the system_add/drop/rename methods are accessible directly from  the client API, they should be completely safe for concurrent use.
",,Existing system architecture description,3:323 - 3:461,1,arjan
11:4,It should be possible to allow for most types of concurrent migrations…,CASSANDRA-1391,"It should be possible to allow for most types of concurrent migrations by converting the UUID  schema ID into a VersionVectorClock (as provided by CASSANDRA-580).
",,Architectural design configuration,3:462 - 3:625,1,arjan
11:168,stuhood,CASSANDRA-1391,stuhood,,Comment,3:837 - 3:843,1,arjan
11:5,"But, vitally, if concurrent Migrations do confict in a way that can’t…",CASSANDRA-1391," But, vitally, if concurrent Migrations do confict in a way that can’t be resolved,  keyspaces that didn’t confict should not be afected.
",,Existing system architecture description,3:845 - 3:983,1,arjan
11:169,jbellis,CASSANDRA-1391,jbellis,,Comment,3:987 - 3:993,1,arjan
11:6,ISTM we can allow concurrent migrations by computing the schema ID as…,CASSANDRA-1391," ISTM we can allow concurrent migrations by computing the schema ID as an md5  of the keyspaces and CFs, instead of pushing that to VC. it’s exactly the kind of set-merge  problem that both columns-within-a-CF and VC can handle.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",3:995 - 3:1224,2,arjan
11:170,ithkuil,CASSANDRA-1391,ithkuil,,Comment,4:4 - 4:10,1,arjan
11:7,is there a way to fx this bad state?,CASSANDRA-1391, is there a way to fx this bad state?,,,4:12 - 4:48,1,arjan
11:8,"I’m not sure if this bug afects me or something  similar, but my clust…",CASSANDRA-1391,"I’m not sure if this bug afects me or something  similar, but my cluster cannot create new keyspaces  ""Cluster schema does not yet agree""  I tried to drop all the nodes but one, but it still complains. Any idea?
",,"Assumptions
Run-time quality issues",4:50 - 4:262,2,arjan
11:9,"Does this sound sane at all to you, Gary?",CASSANDRA-1391,"Does this sound sane at all to you, Gary?
",,,4:275 - 4:317,1,arjan
11:171,gdusbabek,CASSANDRA-1391,gdusbabek,,Comment,4:321 - 4:329,1,arjan
11:10,Not with the current state of things.,CASSANDRA-1391,"Not with the current state of things.
",,Architectural solution benefits and drawbacks,4:332 - 4:370,1,arjan
11:11,What would have to change?,CASSANDRA-1391,"What would have to change?
",,,4:383 - 4:410,1,arjan
11:172,gdusbabek,CASSANDRA-1391,gdusbabek,,Comment,4:414 - 4:422,1,arjan
11:12,Bottom line: we need to solve the problem of how to handle conficts. I…,CASSANDRA-1391,"Bottom line: we need to solve the problem of how to handle conficts. I view  this as a similar problem of handling merge conficts in change sets: a good subset of the  conficts can be merged automatically because they are independent of each other. But ev-  ery once a while there is a confict that needs a manual edit-the solution is not computable  because it isn’t deterministic.
",,Motivation of design issue,4:425 - 4:808,1,arjan
11:13,This is currently addressed right now by strictly enforcing the relati…,CASSANDRA-1391,"This is currently addressed right now by strictly enforcing the relationship of a migration  with its predecessor to ensure that all migrations are applied serially.
",,Existing system architecture description,4:809 - 4:975,1,arjan
11:14,There is probably a pragmatic approach that I’m not able to see becaus…,CASSANDRA-1391,"There is probably a pragmatic approach that I’m not able to see because the merge-confict  problem makes it a non-starter for me.
",,"Architectural design configuration
Assumptions",4:976 - 4:1106,2,arjan
11:173,jbellis,CASSANDRA-1391,jbellis,,Comment,4:1110 - 4:1116,1,arjan
11:15,"Seems like if we could come up with some way of ""ordering"" schema comp…",CASSANDRA-1391,"Seems like if we could come up with some way of ""ordering"" schema components we  could solve that: user A says ""set default_validation_class=ascii"", B says ""d_v_c=utf8"",  but we semi-arbitrarily decide that ascii is higher priority so when they confict ascii wins.
",,"Architectural component behavior and structure
Assumptions",4:1119 - 4:1384,2,arjan
11:174,gdusbabek,CASSANDRA-1391,gdusbabek,,Comment,4:1388 - 4:1396,1,arjan
11:16,A lamport-ish clock consisting of node name and counter/timestamp woul…,CASSANDRA-1391,"A lamport-ish clock consisting of node name and counter/timestamp would probably be  sufcient for ordering.
",,"Architectural component behavior and structure
Assumptions",4:1484 - 4:1592,2,arjan
11:17,This could be used with an approach that quarantines schema changes fo…,CASSANDRA-1391,"This could be used with an approach that quarantines schema changes for a period of time.
",,Architectural design configuration,4:1593 - 4:1683,1,arjan
11:18,This would allow for changes to come in from throughout the cluster an…,CASSANDRA-1391,"This would allow for changes to come in from throughout the cluster and would allow them  to be reordered before being applied.
",,Architectural solution benefits and drawbacks,4:1684 - 4:1812,1,arjan
11:19,"I think this is sensible, but still gives some rope from which we can…",CASSANDRA-1391,"I think this is sensible, but still gives some rope from which we can hang ourselves--the  strict predecessor relationship is gone and we’d have to trust that nodes would be doing the  right thing (by applying migrations) independently after the quarantine is over.
",,"Architectural solution benefits and drawbacks
Assumptions",4:1813 - 4:2079,2,arjan
11:175,jbellis,CASSANDRA-1391,jbellis,,Comment,4:2084 - 4:2090,1,arjan
11:20,"That would probably work too, although it feels weird to base it on wh…",CASSANDRA-1391,"That would probably work too, although it feels weird to base it on who generated the  migration, rather than the migration contents.
",,"Architectural solution benefits and drawbacks
Assumptions",4:2205 - 4:2339,2,arjan
11:21,"Right. I’m totally comfortable with this, feels like a good ft with ho…",CASSANDRA-1391,"Right. I’m totally comfortable with this, feels like a good ft with how the rest of the  system works.
",,Architectural solution benefits and drawbacks,4:2477 - 4:2580,1,arjan
11:176,jbellis,CASSANDRA-1391,jbellis,,Comment,4:2585 - 4:2591,1,arjan
11:22,"Thinking about this more, the really important part is that all nodes…",CASSANDRA-1391,"Thinking about this more, the really important part is that all nodes agree on  the same schema no matter what order they get the Migrations in. If we can make that  3
guarantee, the actual confict resolution doesn’t have to be particularly good (since it will  still be a rare occurrence).
So what is ""the simplest thing that can work"" here?
I think we need to be able to merge Migrations at a fner granularity.
If we do not, we have problems like this:  - Mutation 1 (M1) says ""set default_validation_class=ascii, comment=’foo’"" at time T1.
- M2 says ""set row_cache_size=1000000"" at time T0 < T1.
If node A gets M2 frst, applies it, then gets M1, it has all 3 changes made. If node B  however gets M1 frst, then rejects M2 because T0 < T1 (for whatever kind of clock/com-  parator we are talking about), nodes A and B will end up with diferent schemas.
I think wall-clock-time plus content-based tiebreaker (like we currently do with Column  values) will be just as good as more complex ordering, as long as we have the fne-grained  merging.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",4:2594 - 5:883,3,arjan
11:177,xedin,CASSANDRA-1391,xedin,,Comment,5:888 - 5:892,1,arjan
11:23,Moved all static collections that hold information about schema from D…,CASSANDRA-1391,Moved all static collections that hold information about schema from DatabaseDescrip-  tor/CFMetaData/Table classes to union o.a.c.confg.DBSchema class (also refactored o.a.c.db.migration  classes to support that change),,Architectural design configuration,5:895 - 5:1114,1,arjan
11:24,that also will enable us to apply schema migrations in the  isolated e…,CASSANDRA-1391,that also will enable us to apply schema migrations in the  isolated environment.,,Architectural solution benefits and drawbacks,5:1117 - 5:1197,1,arjan
11:178,jbellis,CASSANDRA-1391,jbellis,,Comment,5:1204 - 5:1210,1,arjan
11:28,"I’d prefer ""Schema"" to DBSchema, and ""Schema.instance"" to a static fna…",CASSANDRA-1391," I’d prefer ""Schema"" to DBSchema, and ""Schema.instance"" to a static fnal DBD.schema  reference (and inlining the DBD.getX calls that just wrap a Schema method of the same  name).
",,,5:1212 - 5:1391,1,arjan
11:26,Otherwise +1,CASSANDRA-1391,Otherwise +1,,Architectural solution benefits and drawbacks,5:1392 - 5:1403,1,arjan
11:27,"Ok, I will do renaming and inline and commit this, thanks!",CASSANDRA-1391,"Ok, I will do renaming and inline and commit this, thanks!
",,,5:1417 - 5:1476,1,arjan
11:29,Committed 0001 with changes proposed by Jonathan. 0002 will follow up…,CASSANDRA-1391,"Committed 0001 with changes proposed by Jonathan. 0002 will follow up with  migration merge strategy.
",,,5:1488 - 5:1590,1,arjan
11:179,xedin,CASSANDRA-1391,xedin,,Comment,5:1595 - 5:1599,1,arjan
11:30,Update{Keyspace/ColumnFamily) migrations now update only modifed felds…,CASSANDRA-1391,"Update{Keyspace/ColumnFamily) migrations now update only modifed felds in-  stead of blindly copying everything, applyModels can be skipped now if it makes no modif-  cations.
",,Architectural design configuration,5:1602 - 5:1778,1,arjan
11:31,Merge algorithm is based on isolated schema initialized from merging m…,CASSANDRA-1391,"Merge algorithm is based on isolated schema initialized from merging migration lastVersion  point: merging migration applied frst then all older migrations, after that Schema.instance  gets safely updated.
",,Architectural design configuration,5:1779 - 5:1985,1,arjan
11:32,Rebased with latest trunk (last commit 38a55bab7ee054bce83028b5f0abda3…,CASSANDRA-1391,Rebased with latest trunk (last commit 38a55bab7ee054bce83028b5f0abda3e9e9e7ebf),,,5:1986 - 5:2065,1,arjan
11:33,"Pavel, can you please rebase?",CASSANDRA-1391," Pavel, can you please rebase?
",,,5:2082 - 5:2113,1,arjan
11:34,rebased with trunk (last commit 0a4b1667bee674f7c0a22057cbdab97e368a20…,CASSANDRA-1391,rebased with trunk (last commit 0a4b1667bee674f7c0a22057cbdab97e368a20d1),,,5:2125 - 5:2197,1,arjan
11:35,rebased with latest trunk (last commit 38a51a8d2da4c3756a5b5fe5709a1aa…,CASSANDRA-1391,rebased with latest trunk (last commit 38a51a8d2da4c3756a5b5fe5709a1aa97300250e),,,5:2211 - 5:2290,1,arjan
11:180,xedin,CASSANDRA-1391,xedin,,Comment,5:2297 - 5:2301,1,arjan
11:36,I have fgured out a problem with Avro - it can’t correctly handle map…,CASSANDRA-1391," I have fgured out a problem with Avro - it can’t correctly handle map comparison:  ""org.apache.avro.AvroRuntimeException: Can’t compare maps!"" I will try to this issue and  re-attach working patch.
",,Run-time quality issues,5:2303 - 5:2502,1,arjan
11:181,xedin,CASSANDRA-1391,xedin,,Comment,6:5 - 6:9,1,arjan
11:37,updated patch to fx problem with avro map comparisons.,CASSANDRA-1391,updated patch to fx problem with avro map comparisons.,,Architectural design configuration,6:12 - 6:65,1,arjan
11:38,This has a side efect in  a good sense - you don’t need to include opt…,CASSANDRA-1391,"This has a side efect in  a good sense - you don’t need to include options that you don’t want to update when you  do CLI ‘update {keyspace/column family}‘.
",,Architectural solution benefits and drawbacks,6:67 - 6:224,1,arjan
11:39,rebased with latest trunk (last commit 38a51a8d2da4c3756a5b5fe5709a1aa…,CASSANDRA-1391,rebased with latest trunk (last commit 38a51a8d2da4c3756a5b5fe5709a1aa97300250e),,,6:236 - 6:315,1,arjan
11:40,rebased.,CASSANDRA-1391,"rebased.
",,,6:329 - 6:338,1,arjan
11:41,what is the isIsolated mode stuf for?,CASSANDRA-1391," what is the isIsolated mode stuf for?
",,,6:351 - 6:390,1,arjan
11:182,xedin,CASSANDRA-1391,xedin,,Comment,6:395 - 6:399,1,arjan
11:42,Isolated fag is used to indicate that migration will be applied using…,CASSANDRA-1391,Isolated fag is used to indicate that migration will be applied using isolated schema,,Architectural component behavior and structure,6:402 - 6:486,1,arjan
11:43,so SystemTable.Schema record for LAST_MIGRATION_KEY won’t be updated a…,CASSANDRA-1391,"so SystemTable.Schema record for LAST_MIGRATION_KEY won’t be updated and no  real fle operations will be made. This allows us to old deserialize migrations and re-apply  them one-by-one to in case on merging migration (after each re-apply information about  that migration going to be updated in SystemTable.Schema and SystemTable.Migrations).
",,Architectural solution benefits and drawbacks,6:489 - 6:833,1,arjan
11:44,rebased and fxed SchemaMergeTest to work post CASSANDRA-3001,CASSANDRA-1391,rebased and fxed SchemaMergeTest to work post CASSANDRA-3001,,,6:845 - 6:904,1,arjan
11:183,gdusbabek,CASSANDRA-1391,gdusbabek,,Comment,6:911 - 6:919,1,arjan
11:50,"Could you clarify what you mean by ""merging migration applied frst, th…",CASSANDRA-1391,"Could you clarify what you mean by ""merging migration applied frst, then all older mi-  grations...""?
",,,6:1133 - 6:1235,1,arjan
11:51,It seems like a side efect of applying a migration is that it can appl…,CASSANDRA-1391,"It seems like a side efect of applying a migration is that it can apply other migrations.
",,Run-time quality issues,6:1236 - 6:1326,1,arjan
11:52,Does MigrationManager.applyMigrations() need to be updated because of…,CASSANDRA-1391,"Does MigrationManager.applyMigrations() need to be updated because of this?
",,,6:1327 - 6:1403,1,arjan
11:47,"What does ""isolated"" indicate?",CASSANDRA-1391,"What does ""isolated"" indicate?
",,,6:1404 - 6:1435,1,arjan
11:48,Try to put things like fushSystemTables() in a separate patch (ok on t…,CASSANDRA-1391,Try to put things like fushSystemTables() in a separate patch (ok on the same ticket)  to make reviewing the actual changes easier.,,,6:1436 - 6:1566,1,arjan
11:49,Would it be possible to create some unit tests for CFMD.dif()?,CASSANDRA-1391,"Would it be possible to create some unit tests for CFMD.dif()?
",,,6:1569 - 6:1632,1,arjan
11:184,xedin,CASSANDRA-1391,xedin,,Comment,6:1637 - 6:1641,1,arjan
11:53,Take a look at the Migration.apply() starting from line 114 and Migrat…,CASSANDRA-1391,Take a look at the Migration.apply() starting from line 114 and Migration.tryMerge methods  if we detect that current migration is outdated and should be merged we do the follow-  ing actions:  - initialize isolated Schema from the point of migration’s lastVersion (this sets isolated =  true)  - reload migration’s system defnition to refect that isolated schema  - call applyModels on the merging migration to apply it’s schema changes  - merge phrase:  -- read from SystemTable.Migrations all migrations that go after current  -- for each of those migrations:  --- replaces their schema with isolated (from merging migration) and reload system defnition  --- call apply() method to re-write records in SystemTable.Migrations and SystemTable.Schema  - after all migrations were applied we try to merge isolated schema with current system  schema (Schema.instance)  - fush system tables to persist changes,,Existing system architecture description,6:1749 - 6:2654,1,arjan
11:54,No because all modifcations are done using isolated schema,CASSANDRA-1391,No because all modifcations are done using isolated schema,,Existing system architecture description,7:175 - 7:232,1,arjan
11:55,Isolated indicates that migration will be applied with isolated Schema…,CASSANDRA-1391,"Isolated indicates that migration will be applied with isolated Schema so no real fle op-  erations are going to be made, such as snapshot, create of the keyspace directory, remove of  the SSTable fles etc.",,Existing system architecture description,7:271 - 7:476,1,arjan
11:56,"I see only one such a refactoring change, is it really worse splitting…",CASSANDRA-1391,"I see only one such a refactoring change, is it really worse splitting current patch?
",,,7:615 - 7:701,1,arjan
11:57,CFMD.dif is used all over the place so if it was broken other tests wo…,CASSANDRA-1391,"CFMD.dif is used all over the place so if it was broken other tests would fail but if you  think that this is necessary I can do that.
",,,7:769 - 7:904,1,arjan
11:185,jbellis,CASSANDRA-1391,jbellis,,Comment,7:909 - 7:915,1,arjan
11:58,My preference would be to model this on our Row confict resolution: fo…,CASSANDRA-1391,"My preference would be to model this on our Row confict resolution: for rows, we have  a single code path where distinct columns are simply merged, and for conficting columns  we pick a winner based on user-provided timestamp and, if necessary, value contents.",,Architectural design configuration,7:1064 - 7:1323,1,arjan
11:59,So  the result is guaranteed to be the same on all replicas no matter…,CASSANDRA-1391,"So  the result is guaranteed to be the same on all replicas no matter what order updates were  received in.
",,Architectural solution benefits and drawbacks,7:1325 - 7:1433,1,arjan
11:60,"Similarly, I’d like to see schemas merge feld-at-a-time in KSMetadata/…",CASSANDRA-1391,"Similarly, I’d like to see schemas merge feld-at-a-time in KSMetadata/CFMetadata, with  commutative confict resolution. (I suggested byte ordering of the feld contents; Gary sug-  gested using some clock value created by coordinator.)",,Architectural design configuration,7:1434 - 7:1667,1,arjan
11:61,"Seems to me this would make the ""isolation"" complexity go away.",CASSANDRA-1391,"Seems to me this would make the ""isolation"" complexity go away.
",,"Architectural solution benefits and drawbacks
Assumptions",7:1670 - 7:1734,2,arjan
11:186,xedin,CASSANDRA-1391,xedin,,Comment,7:1739 - 7:1743,1,arjan
11:62,Migration merging is more complex process comparing to row merging whi…,CASSANDRA-1391,"Migration merging is more complex process comparing to row merging which is pretty  straight-forward, current approach easily handles all possible confits without any tie-breakers  or coordinators because it simply detects what modifcations where made by each of the  migrations starting from merging one, combines them (modifcations) together in isolated  schema and updates Schema.instance _so the resulting schema is guaranteed to be the same  on all replicas no matter what order migrations were received in_.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",7:2163 - 7:2677,2,arjan
11:63,I still think that this is the simplest solution of all proposed becau…,CASSANDRA-1391,"I still think that this is the simplest solution of all proposed because actual modifcations  are: KSMetaData/CFMetaData.dif(...) methods to detect modifed felds, one fag mem-  ber Migration.isolated to indicate that migration is running in the isolated mode and one  6
method to update system Schema.instance with resulting Schema after all migrations where  applied.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",7:2747 - 8:100,3,arjan
11:187,jbellis,CASSANDRA-1391,jbellis,,Comment,8:105 - 8:111,1,arjan
11:64,"You may be right, but I’d need some time to convince myself of that an…",CASSANDRA-1391,"You may be right, but I’d need some time to convince myself of that and it sounds  from IRC that Gary would too.",,"Architectural solution benefits and drawbacks
Assumptions",8:114 - 8:225,2,arjan
11:188,jbellis,CASSANDRA-1391,jbellis,,Comment,8:263 - 8:269,1,arjan
11:65,"I think we can make it even simpler,",CASSANDRA-1391,"I think we can make it even simpler,",,"Architectural solution benefits and drawbacks
Assumptions",8:344 - 8:379,2,arjan
11:66,Schema version would become some kind of md5 or sha of the CF contents…,CASSANDRA-1391,"
Schema version would become some kind of md5 or sha of the CF contents (all rows +  all columns).
",,Architectural design configuration,8:669 - 8:768,1,arjan
11:67,The only problem is you need to be a little careful to open the schema…,CASSANDRA-1391,"The only problem is you need to be a little careful to open the schema CFs before any-  thing else, but that’s relatively easy I think.
",,"Architectural solution benefits and drawbacks
Assumptions",8:769 - 8:905,2,arjan
11:189,tjake,CASSANDRA-1391,tjake,,Comment,8:910 - 8:914,1,arjan
11:68,I think the patch is a good start but I do like Jonathans idea of movi…,CASSANDRA-1391," I think the patch is a good start but I do like Jonathans idea of moving to native  CFs too.
",,"Architectural solution benefits and drawbacks
Assumptions",8:916 - 8:1010,2,arjan
11:69,We just want to make sure this gets into 1.1 since it’s a problem a lo…,CASSANDRA-1391,"We just want to make sure this gets into 1.1 since it’s a problem a lot of people run into.
",,Run-time quality issues,8:1011 - 8:1103,1,arjan
11:70,"Regarding the current impl, my concern is missing felds added to migra…",CASSANDRA-1391,"Regarding the current impl, my concern is missing felds added to migration structs over  time. like we had happen a lot in CFMetaData conversion code.",,"Assumptions
Run-time quality issues",8:1104 - 8:1253,2,arjan
11:71,Could you add a test verifes all migration struct felds are accounted…,CASSANDRA-1391,Could you add a test verifes all migration struct felds are accounted for in the merge  logic? so if someone adds a new feld and doesn’t update the migration merge logic it would  cause this test to fail,,Architectural design configuration,8:1256 - 8:1458,1,arjan
11:190,xedin,CASSANDRA-1391,xedin,,Comment,8:1465 - 8:1469,1,arjan
11:72,"It seems like what we really want from migrations is ""schema state"" be…",CASSANDRA-1391,"It seems like what we really want from migrations is ""schema state"" before any given  migration and actual modifcations migration makes like ""add keyspace <ks> with attributes  = ..."", ""update <cf> with attributes = ....""  As all of the migrations are user initiated we can easily calculate what modifcations migra-  tion makes and propagate only them keeping TimeUUID as ID of the migration to identify  ""apply"" order. As it’s okay for us to require full cluster update before accepting schema  modifcations it makes merge a trivial task where modifcations should be applied one-by-  one on some ""initial state"" of the schema (that also allows as to remove Avro overhead from  migrations). Abandoning Avro would make things less fragile because there would be no  need to modify CFMetaData or any other classes to support new (or deleted) attributes.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",8:1472 - 8:2324,3,arjan
11:191,tjake,CASSANDRA-1391,tjake,,Comment,8:2329 - 8:2333,1,arjan
11:73,By moving to CF based migration logic it would be very useful to have…,CASSANDRA-1391,"By moving to CF based migration logic it would be very useful to have the logic  abstracted from schemas so it can be used for other use cases.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",8:2336 - 8:2480,2,arjan
11:74,Migrations give you the following:  * RF = N where N is the size of th…,CASSANDRA-1391,"Migrations give you the following:  * RF = N where N is the size of the ring.
* All changes are ""pushed"" to new nodes when they join the ring.
* previously sent data is available locally on startup",,Architectural design configuration,8:2481 - 8:2679,1,arjan
11:192,jbellis,CASSANDRA-1391,jbellis,,Comment,9:5 - 9:11,1,arjan
11:75,"Yes, that’s implied by moving to a CF-based structure I think.",CASSANDRA-1391,"Yes, that’s implied by moving to a CF-based structure I think.
",,"Architectural solution benefits and drawbacks
Assumptions",9:148 - 9:211,2,arjan
11:76,I don’t see why you’d want to complicate things by doing this. We alre…,CASSANDRA-1391,"I don’t see why you’d want to complicate things by doing this. We already have perfectly  good per-column confict resolution without it.
",,Architectural solution benefits and drawbacks,9:283 - 9:420,1,arjan
11:77,I’m okay in principle with introducing a EveryNodeReplicationStrategy…,CASSANDRA-1391,"I’m okay in principle with introducing a EveryNodeReplicationStrategy but refactoring mi-  grations to that is a separate step from this ticket.
",,Architectural solution benefits and drawbacks,9:531 - 9:676,1,arjan
11:78,So you suggest we replicate schema the same way as we do data?,CASSANDRA-1391,"So you suggest we replicate schema the same way as we do data?
",,,9:688 - 9:751,1,arjan
11:193,jbellis,CASSANDRA-1391,jbellis,,Comment,9:756 - 9:762,1,arjan
11:79,It seems to make sense eventually. But for this ticket let’s stick wit…,CASSANDRA-1391,"It seems to make sense eventually. But for this ticket let’s stick with LocalPartitioner  and the existing schema replication.
",,Architectural solution benefits and drawbacks,9:765 - 9:891,1,arjan
11:194,xedin,CASSANDRA-1391,xedin,,Comment,9:897 - 9:901,1,arjan
11:80,Than we need to preserve an order of the migrations that we accept fro…,CASSANDRA-1391,Than we need to preserve an order of the migrations that we accept from remote  nodes otherwise we don’t have sufcient information to apply modifcations or am I missing  something?,,"Assumptions
Motivation of design issue",9:904 - 9:1083,2,arjan
11:81,Can you please brigly describe the process how you see it?,CASSANDRA-1391,"Can you please brigly describe the process how you see it?
",,,9:1085 - 9:1144,1,arjan
11:195,jbellis,CASSANDRA-1391,jbellis,,Comment,9:1149 - 9:1155,1,arjan
11:82,Here is one way to model it:  *keyspaces*  name: { // key  ’durable_wr…,CASSANDRA-1391,"Here is one way to model it:  *keyspaces*  name: { // key  ’durable_writes’: bool,  ’replication_strategy’ : { // composite columns ahead!
’class’: str,  ’options’: {  // strat-dependent options  }  }  }  Example (w/ composite names spelled out):  ’Keyspace1’: {  ’durable_writes’: True,  (’replication_strategy’, ’class’): ’SimpleStrategy’,  (’replication_strategy’, ’options’, ’replication_factor’): 1  }  *columnfamilies*  name: { // key  ’keyspace’: str,  ’comparator’: str,  ... ’columns’: { // composite!
column name: {  8
’validation_class’: str,  ’index_type’: str,  ’index_name’: str,  ’index_options’: { }  }  }  }  Since each option is its own column, we leverage Cassandra’s own confict resolution: it’s  easy to see how if client 1 changes Keyspace1.durable_writes to False, and another client  changes replication_strategy to NTS, there is no confict and life is good. But if one changes  r_s to NTS and another changes it to ONTS, then the one w/ higher timestamp wins. This  is important to tolerate diferent nodes receiving the changes in diferent orders, which is  necessary for everyone to end up in the same state.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",9:1158 - 10:607,2,arjan
11:196,jbellis,CASSANDRA-1391,jbellis,,Comment,10:612 - 10:618,1,arjan
11:83,"For example, suppose we have two clients C1 and C2, and two nodes A an…",CASSANDRA-1391,"For example, suppose we have two clients C1 and C2, and two nodes A and B. They  have a columnfamily that includes the following options:  ColumnFamily1: {  ’default_validation_class’: ’bytes’,  ’comment’: ’an example’,  ’row_cache_size’: 0  }  Next, C1 and C2 update ColumnFamily1 with M1 and M2 as follows:  M1 = ColumnFamily1: {’d_v_c’: ’ascii’, ’comment’: ’foo’} @ T1}}  M2 = ColumnFamily1: {’d_v_c’: ’utf8’, ’row_cache_size’: 1000000} @ T0  < T1  (Note that we have a confict on default_validation_class.)  Node A receives M1 frst, while node B receives M2 frst.
*Node A:*  (applies M1)  ColumnFamily1: {  ’default_validation_class’: ’ascii’,  ’comment’: ’foo’,  ’row_cache_size’: 0  }  (applies M2)  ColumnFamily1: {  9
’default_validation_class’: ’ascii’, // M2.dvc has no effect since  T0 < T1  ’comment’: ’foo’,  ’row_cache_size’: 1000000  }  *Node B:*  (applies M2)  ColumnFamily1: {  ’default_validation_class’: ’utf8’,  ’comment’: ’an example’,  ’row_cache_size’: 1000000  }  (applies M1)  ColumnFamily1: {  ’default_validation_class’: ’ascii’,  ’comment’: ’foo’,  ’row_cache_size’: 1000000  }  Because timestamp-based confict resolution is commutative, all nodes end with the same  schema no matter what order they get the updates in.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",10:621 - 11:523,2,arjan
11:197,jbellis,CASSANDRA-1391,jbellis,,Comment,11:528 - 11:534,1,arjan
11:84,I’m enthusiastic about this approach for several reasons:  - ultimatel…,CASSANDRA-1391,"I’m enthusiastic about this approach for several reasons:  - ultimately we end up with simpler code with less special cases, although the migration  (*cough*) from Avro-based schema will be a pain initially  - gets rid of Avro dependency!
- fxes CASSANDRA-2477 (""SELECT * FROM keyspaces"")",,Architectural solution benefits and drawbacks,11:537 - 11:825,1,arjan
11:198,xedin,CASSANDRA-1391,xedin,,Comment,11:832 - 11:836,1,arjan
11:85,New migration model uses internal ’system’.’keyspace’ CF as backing st…,CASSANDRA-1391,"New migration model uses internal ’system’.’keyspace’ CF as backing storage from  the state of the schema. Internal structure of the ’keyspaces’ CF was described in the  Jonathan’s comment. Decisions about attribute updates are made according to timestamps  of the columns in new that CF.
Avro dependency is completely removed, all {to/from}Avro methods cleaned. Please make  sure that you apply both patches.
",,Architectural design configuration,11:839 - 11:1250,1,arjan
11:86,Rebased with the latest trunk (last commit 3ed1e0789f10de8e9638bec20be…,CASSANDRA-1391,Rebased with the latest trunk (last commit 3ed1e0789f10de8e9638bec20bed2e59fa35b0d0),,,11:1251 - 11:1334,1,arjan
11:87,If you remove avro how do people upgrade?,CASSANDRA-1391,"If you remove avro how do people upgrade?
",,,11:1348 - 11:1390,1,arjan
11:199,xedin,CASSANDRA-1391,xedin,,Comment,11:1395 - 11:1399,1,arjan
11:88,I’m planing to add a special tool which would help convert schema from…,CASSANDRA-1391," I’m planing to add a special tool which would help convert schema from avro to new  model in the separate patch. I don’t see a reason to hold avro in lib as core code does not  use it.
",,Architectural design configuration,11:1401 - 11:1587,1,arjan
11:89,rebased with the lastest trunk (last commit e37bd7e8d344332f41bd1015e6…,CASSANDRA-1391,rebased with the lastest trunk (last commit e37bd7e8d344332f41bd1015e6018c81ca81fa3),,,11:1599 - 11:1682,1,arjan
11:200,jbellis,CASSANDRA-1391,jbellis,,Comment,11:1689 - 11:1695,1,arjan
11:90,"Thanks, Pavel. This is getting closer. But I think continuing to use U…",CASSANDRA-1391,"Thanks, Pavel. This is getting closer. But I think continuing to use UUIDs is the  wrong approach. In particular, code like this means we’ve failed to achieve our goal:  10
1 . if (newVersion.timestamp() <= lastVersion.timestamp())  2 throw new ConfigurationException(""New version timestamp is not newer  than the current version timestamp."");  If two migrations X and Y propagate through the cluster concurrently from diferent coor-  dinators, some nodes will apply X frst, some Y; whichever migration has a lower timestamp  will then error out on the remaining nodes and we’ll end up with the same kind of version  confict snafu we encounter now.
",,Architectural solution benefits and drawbacks,11:1698 - 12:477,1,arjan
11:91,Here’s how I think it should work:  * Coordinator turns KsDef and CfDe…,CASSANDRA-1391,"Here’s how I think it should work:  * Coordinator turns KsDef and CfDef objects into RowMutations by applying them to the ex-  isting (local) schema. Maybe you use something like your attributesToCheck code since you  already have that written. Give that mutation a normal local timestamp (FBU.timestampMicros).
Then each node applying the change:  * makes a deep copy of the existing schema ColumnFamily objects  * calls Table.apply on the migration RowMutations  * calls ColumnFamily.dif on the new schema ColumnFamily object vs the copied one. (This  is where I was going above by saying ""let the existing resolve code do the work."" No matter  which order nodes apply X and Y in, they will always agree on the result after applying  both. Note that this does not depend on X and Y getting ""correctly"" ordered timestamps,  either.)  * makes the appropriate Table + CFS + Schema changes dicated by the dif  * (above obvously needs to be synchronized at least against the Table/CFS objects afected)  Schema ""version"" may then be computed as an md5 of the Schema objects. (Again: goal  is that nodes can apply X and Y in any order, and we don’t care. So version needs to be  entirely content-based, not time-based.) Probably the easiest way to do this is to just use  CF.updateDigest. We can cut this down to the frst 16 bytes if we need to cram it into a  UUID, but I don’t see a reason for that (the Thrift API uses Strings already).
Nit: fushSystemCFs could use FBUtilities.waitOnFutures(fushes) instead of rolling its own  multi-future wait.
",,"Architectural design configuration
Assumptions",12:478 - 12:2025,2,arjan
11:201,xedin,CASSANDRA-1391,xedin,,Comment,12:2030 - 12:2034,1,arjan
11:92,"I fgured out that we don’t really need ""lastVersion"" feld in Migration…",CASSANDRA-1391," I fgured out that we don’t really need ""lastVersion"" feld in Migration class anymore  so it’s now removed.",,Architectural component behavior and structure,12:2036 - 12:2142,1,arjan
11:93,I have removed migration ordering validation from DefnitionsUpdate-  V…,CASSANDRA-1391,I have removed migration ordering validation from DefnitionsUpdate-  VerbHandler and fxed nit you mentioned. ,,Architectural component behavior and structure,12:2144 - 12:2252,1,arjan
11:94,Also I think that we still need versions to be of  TimeUUID type becau…,CASSANDRA-1391,"Also I think that we still need versions to be of  TimeUUID type because it’s useful for example in MigrationManager.rectify were we need  to know if and what migrations do we want to send to others.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",12:2253 - 12:2453,3,arjan
11:202,jbellis,CASSANDRA-1391,jbellis,,Comment,12:2458 - 12:2464,1,arjan
11:95,"That doesn’t work, though: what if we have two updates at the same tim…",CASSANDRA-1391,"That doesn’t work, though: what if we have two updates at the same timestamp?
I think it really does need to be content-based.
",,"Architectural solution benefits and drawbacks
Assumptions",12:2467 - 12:2595,2,arjan
11:96,"Also, I still think using Table.apply and CF.dif is the ""right"" way to…",CASSANDRA-1391,"Also, I still think using Table.apply and CF.dif is the ""right"" way to do this, instead of  efectively duplicating that code as a special case. Are there any downsides to that approach  I’m missing?
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",12:2596 - 12:2795,3,arjan
11:203,xedin,CASSANDRA-1391,xedin,,Comment,12:2800 - 12:2804,1,arjan
11:97,We could compare uuids instead in the isMergingMigration method.,CASSANDRA-1391,"We could compare uuids instead in the isMergingMigration method.
",,Architectural component behavior and structure,12:2807 - 12:2872,1,arjan
11:98,How do node determine if it is ahead or behind of the ring with conten…,CASSANDRA-1391,"How do node determine if it is ahead or behind of the ring with content based version-  ing? Even if able to determine state, how do you fnd out what migrations node needs to  send/receive to get ring in sync?
",,,13:1 - 13:211,1,arjan
11:204,jbellis,CASSANDRA-1391,jbellis,,Comment,13:216 - 13:222,1,arjan
11:99,"You don’t need to -- just send it the current schema, and apply/dif wi…",CASSANDRA-1391,"You don’t need to -- just send it the current schema, and apply/dif will take care  of any redundancies. (This means we don’t need to worry about schema propagation taking  a long time during bootstrap or rebuild of a new node, either, as in CASSANDRA-3629 or  CASSANDRA-2056.)",,Architectural design configuration,13:225 - 13:501,1,arjan
11:205,xedin,CASSANDRA-1391,xedin,,Comment,13:508 - 13:512,1,arjan
11:100,Isn’t that an over-complication? Starting from step 2 in your previous…,CASSANDRA-1391," Isn’t that an over-complication? Starting from step 2 in your previous comment,  node would always need to do dif to all of the CF objects plus determine were any of the  keyspaces deleted/added which on the other hand migrations give us for free because we  always know exactly what does migration modify. Also when node starts with such content-  based version and it’s version does not much others, does it really know what to do - send  own schema or request one?.. I also think that once ring will get to some frequency of  the schema changes it would create a noticeable trafc and nodes won’t be able to keep up  migrating anymore...
",,"Architectural design configuration
Architectural solution benefits and drawbacks",13:514 - 13:1155,2,arjan
11:206,jbellis,CASSANDRA-1391,jbellis,,Comment,13:1160 - 13:1166,1,arjan
11:101,"Feels more like a simplifcation, than a complication to me. Syncing sc…",CASSANDRA-1391,"Feels more like a simplifcation, than a complication to me. Syncing schema becomes  always sending exactly one message instead of potentially hundreds/thousands. And, we get  full concurrency support instead of ""mostly"" (the equal-timestamp weakness I mentioned).
Seems worth it to me.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",13:1169 - 13:1456,2,arjan
11:102,"Currently, schema changes are push-only (see: SS.pushMigrations). So w…",CASSANDRA-1391,"Currently, schema changes are push-only (see: SS.pushMigrations). So without changing  that, yes, both nodes will send schema to each other (which will be a no-op on the newer  one). That’s not a blocker for me",,"Architectural solution benefits and drawbacks
Existing system architecture description",13:1457 - 13:1666,2,arjan
11:103,I’d be fne switching to a pull model in either this or  a followup tic…,CASSANDRA-1391,"I’d be fne switching to a pull model in either this or  a followup ticket, which would let the newer side skip its pull if it recognizes the remote  version as one it used to have (which would reliably indicate it’s ""older"" even if timestamp  ties are involved).
",,"Architectural design configuration
Architectural solution benefits and drawbacks",13:1669 - 13:1932,2,arjan
11:104,Trafc from schema changes will be negligible for any known workload. W…,CASSANDRA-1391,"Trafc from schema changes will be negligible for any known workload. We can optimize for  that if/when it becomes a problem (my prediction: never).
",,Architectural solution benefits and drawbacks,13:1933 - 13:2081,1,arjan
11:207,xedin,CASSANDRA-1391,xedin,,Comment,13:2086 - 13:2090,1,arjan
11:105,Sounds reasonable and this would also change how we do announce of the…,CASSANDRA-1391," Sounds reasonable and this would also change how we do announce of the new  schema,",,Architectural solution benefits and drawbacks,13:2092 - 13:2175,1,arjan
11:106,"so if it’s possible, could we do it in the separate ticket (or subtick…",CASSANDRA-1391,"so if it’s possible, could we do it in the separate ticket (or subticket)? Because this  one is getting really big and I’d like to settle on the local migration handling code before we  start with schema propagation changes...
",,,13:2177 - 13:2404,1,arjan
11:107,"I’d rather do them together in this case, it’s pretty hard to work in…",CASSANDRA-1391,"I’d rather do them together in this case, it’s pretty hard to work in trunk w/o  schema announce working.
",,,13:2418 - 13:2524,1,arjan
11:208,xedin,CASSANDRA-1391,xedin,,Comment,13:2529 - 13:2533,1,arjan
11:108,rebased parts 1-2 and part 3,CASSANDRA-1391,rebased parts 1-2 and part 3,,,13:2536 - 13:2563,1,arjan
11:109,"handles the new way of schema distribution, now each  node after apply…",CASSANDRA-1391,"handles the new way of schema distribution, now each  node after applying migration locally calculates a content-based schema version (calculated  from system.keyspaces CF) and gossips it, others listen on onChange and onAlive methods  and when schema update is received them match version to their and in case it does not equal  node requests migrations but sending MIGRATION_REQUEST message with serialized list  of the local migration ids, coordinator sends set of missing migrations (in the serialized form)  in response. After migrations are received by requesting node it applies them locally one by  one on the Migration stage.
",,Architectural design configuration,13:2565 - 13:3200,1,arjan
11:110,rebased with the lastest trunk (last commit 38c04fef0a431bf29010074bad…,CASSANDRA-1391, rebased with the lastest trunk (last commit 38c04fef0a431bf29010074bad1d35d87a739c02),,,13:3211 - 13:3296,1,arjan
11:111,0003 properly rebased,CASSANDRA-1391,0003 properly rebased,,,13:3310 - 13:3330,1,arjan
11:209,jbellis,CASSANDRA-1391,jbellis,,Comment,13:3337 - 13:3343,1,arjan
11:112,"While getting rid of avro is great, replacing ""serialize to avro"" with…",CASSANDRA-1391,"While getting rid of avro is great, replacing ""serialize to avro"" with ""serialize to thrift""  isn’t as much improvement as I was hoping for.",,Architectural solution benefits and drawbacks,13:3346 - 13:3485,1,arjan
11:113,"I thought we were on board with modeling the  12schema ""natively"" in s…",CASSANDRA-1391,"I thought we were on board with modeling the  12
schema ""natively"" in system columnfamilies as sketched in https://issues.apache.org/jira/browse/CASSANDRA-  1391?focusedCommentId=13149875&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-  tabpanel#comment-13149875. Which would allow the apply/dif design I keep talking about  instead of having to do that manually in UCF, allow dropping the last_migration_key in-  direction, pave the way for CASSANDRA-2477, and probably more simplifcations.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",13:3487 - 14:458,3,arjan
11:114,Is there a reason that doesn’t work?,CASSANDRA-1391,"Is there a reason that doesn’t work?
",,,14:459 - 14:496,1,arjan
11:210,xedin,CASSANDRA-1391,xedin,,Comment,14:501 - 14:505,1,arjan
11:115,I still don’t see how/why apply/dif would be better than migrations (w…,CASSANDRA-1391," I still don’t see how/why apply/dif would be better than migrations (which are  localized actions on the schema)...
",,Architectural solution benefits and drawbacks,14:507 - 14:624,1,arjan
11:116,We can drop it even with my current patches but what does it give us?…,CASSANDRA-1391,"We can drop it even with my current patches but what does it give us? Instead of converting  deserialized thrift objects to KSMetaData we would need to initialize KSMetaData/CFMeta-  Data and populate those with parameters from db, is it really better?
",,Architectural solution benefits and drawbacks,14:680 - 14:933,1,arjan
11:117,"With current patch user will be able to do ""SELECT * FROM system.keysp…",CASSANDRA-1391,"With current patch user will be able to do ""SELECT * FROM system.keyspaces"" and other  queries but after CASSANDRA-2474 is done because ‘system.keyspaces‘ uses composite  columns.
",,Contextual constraints,14:971 - 14:1150,1,arjan
11:211,jbellis,CASSANDRA-1391,jbellis,,Comment,14:1156 - 14:1162,1,arjan
11:118,"At the least, it lets you re-use apply/dif instead of rewriting that,…",CASSANDRA-1391,"At the least, it lets you re-use apply/dif instead of rewriting that, and easy CASSANDRA-  2477.
",,Architectural solution benefits and drawbacks,14:1351 - 14:1448,1,arjan
11:119,Does it? It sure looks like it uses serialized Thrift objects to me. (…,CASSANDRA-1391,Does it? It sure looks like it uses serialized Thrift objects to me. (Looking at Def-  sTable.loadFromStorage.),,"Architectural design configuration
Assumptions",14:1635 - 14:1745,2,arjan
11:212,xedin,CASSANDRA-1391,xedin,,Comment,14:1752 - 14:1756,1,arjan
11:120,There is a SCHEMA_CF (where we store serialized schema state after eac…,CASSANDRA-1391,"There is a SCHEMA_CF (where we store serialized schema state after each of the  migrations) and KEYSPACES_CF which is involved in the ks/cf attribute dif process, you  can create a keyspace, open a CLI and do ""use system; list ’keyspaces’;’ to see that I don’t  lie about that :)",,User requirement,14:1759 - 14:2037,1,arjan
11:213,jbellis,CASSANDRA-1391,jbellis,,Comment,14:2044 - 14:2050,1,arjan
11:121,"From experience, that sounds like a great way to get bugs that update…",CASSANDRA-1391," From experience, that sounds like a great way to get bugs that update one but not  the other. ",,Architectural solution benefits and drawbacks,14:2052 - 14:2146,1,arjan
11:122,"We really need a single ""source of truth.",CASSANDRA-1391,"We really need a single ""source of truth.",,Architectural design configuration,14:2147 - 14:2187,1,arjan
11:214,xedin,CASSANDRA-1391,xedin,,Comment,14:2195 - 14:2199,1,arjan
11:123,I can remove SCHEMA_CF and remove KEYSPACES_CF to SCHEMA_CF and  use i…,CASSANDRA-1391,"I can remove SCHEMA_CF and remove KEYSPACES_CF to SCHEMA_CF and  use it to build a schema from db on startup easily.
",,Architectural design configuration,14:2202 - 14:2319,1,arjan
11:215,slebresne,CASSANDRA-1391,slebresne,,Comment,14:2324 - 14:2332,1,arjan
11:124,"Besides, I really think that ’get rid of thrift (or avro) internally’…",CASSANDRA-1391,"Besides, I really think that ’get rid of thrift (or avro) internally’ is a win in the  long run for doing it using apply/dif if there was no other argument. But, as Jonathan, I  see no reason not to apply/dif if we can instead of rewriting equivalent methods.
Moreover, it seems to me that the apply/dif approach would mean that a schema change  would basically be ’send new schema as batch mutation to all nodes’ and the ’does node1 and  node2 agree on schema’ is just ’read node1 and node2 schema row, dif the result and send  a batch mutation with whatever each node needs’. There is no need for ’schema versions’  13
or anything, column timestamp just deal with that problem. You only ever keep one row  for the schema and that’s it. So it seems to me that it’s basically making concurrency a  non issue (because we already handle concurrency internally and through the use of column  timestamps), while I don’t see how those concurrency issues can be free if you use some  thrift serialization.
As Jonathan said, there may be a fundamental problem with the apply/dif approach, but  I don’t see any right away (and truth is I’m much more confdent in C* existing data and  concurrency model to handle conficts during schema update than in the current (or any)  had-hoc migration thingy).
",,"Architectural design configuration
Architectural solution benefits and drawbacks",14:2335 - 15:672,2,arjan
11:216,xedin,CASSANDRA-1391,xedin,,Comment,15:677 - 15:681,1,arjan
11:125,Let me get this clear - migrations use apply/dif internally for their…,CASSANDRA-1391,"Let me get this clear - migrations use apply/dif internally for their actions upon  KEYSPACE_CF. 0003 patch introduces content-based schema version which is calculated  from KEYSPACES_CF.
KEYSPACES_CF layout  name: { // key  ’keyspace’: str,  ’comparator’: str,  ... ’columns’: { // composite!
column name: {  ’validation_class’: str,  ’index_type’: str,  ’index_name’: str,  ’index_options’: { }  }  }  }  Current schema distribution is switched to be pull oriented: node A, let’s call it coordi-  nator, applies migration locally and gossips its new (content-based) version to the ring.
Node B checks if it’s current version difers from new version of Node A and if so, it makes a  migration request to coordinator by sending MIGRATION_REQUEST message with list of  its local migrations attached. Coordinator upon receiving that message makes a dif between  B migrations and its local and replies to B with missing migrations. The last thing for B  to do is just deserialize received migrations and apply them one-by-one. Upon startup node  uses onAlive gossip handler to check versions on other nodes and request missing migrations  if needed.
",,Architectural design configuration,15:684 - 15:1834,1,arjan
11:126,It feels to be better than sending the whole KEYSPACES_CF on each sche…,CASSANDRA-1391,"It feels to be better than sending the whole KEYSPACES_CF on each schema change and  let receiver to decide what actions to do upon it. Migrations are good ft for that part  because they know exactly what to do related to specifc changes e.g. when Add Keyspace  issued - load new CF defnitions to the schema, open table, create corresponding directories  etc.
",,Architectural solution benefits and drawbacks,15:1835 - 15:2195,1,arjan
11:217,slebresne,CASSANDRA-1391,slebresne,,Comment,15:2200 - 15:2208,1,arjan
11:127,But then why do the patches still use thrift internally (I have only q…,CASSANDRA-1391,"But then why do the patches still use thrift internally (I have only quickly eyeballed the  patches but it does seem to use thrift, which seems confrmed by Jonathan comments).
",,,15:2312 - 15:2488,1,arjan
11:128,Does that mean we still keep the list of all migrations (difs) that ha…,CASSANDRA-1391,"Does that mean we still keep the list of all migrations (difs) that have ever been applied?
",,,16:83 - 16:175,1,arjan
11:129,"If so, I would be in favor of getting rid of it, as it seems to me we…",CASSANDRA-1391,"If so, I would be in favor of getting rid of it, as it seems to me we can do without (node  could use the difs between their schema and another node schema and base whatever action  have to be done (directories creation, etc...) on that, be we wouldn’t keep the dif afterwards).
",,"Architectural design configuration
Architectural solution benefits and drawbacks",16:176 - 16:455,2,arjan
11:130,This is probably not a huge deal but it means that schema changes will…,CASSANDRA-1391,"This is probably not a huge deal but it means that schema changes will be a tad slower,  based on gossip reactivity.
",,Architectural solution benefits and drawbacks,16:521 - 16:638,1,arjan
11:218,xedin,CASSANDRA-1391,xedin,,Comment,16:643 - 16:647,1,arjan
11:131,Thrift is only used to keep current/new state of the ks/cf inside of t…,CASSANDRA-1391,"Thrift is only used to keep current/new state of the ks/cf inside of the migration to be  used for dif upon apply, it doesn’t really matter how we would keep that - thrift, json, even  comma separated plain text. I was guided by the fact that we already use thrift internally  and it makes it easy to get attributes of the object when needed.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",16:832 - 16:1175,2,arjan
11:132,I still don’t get that huge deal why we need to re-implement migration…,CASSANDRA-1391,"I still don’t get that huge deal why we need to re-implement migration logic that way,  what does it really gives us comparing to migrations? Migrations already give as a straight  way to tell a node what to do without involving any schema transfers or decision making.
",,Architectural solution benefits and drawbacks,16:1554 - 16:1824,1,arjan
11:219,jbellis,CASSANDRA-1391,jbellis,,Comment,16:1829 - 16:1835,1,arjan
11:133,I think pull is the right ft for a content-based schema version:,CASSANDRA-1391,I think pull is the right ft for a content-based schema version:,,"Architectural solution benefits and drawbacks
Assumptions",16:1838 - 16:1901,2,arjan
11:220,jbellis,CASSANDRA-1391,jbellis,,Comment,16:2390 - 16:2396,1,arjan
11:134,"it should be equivalent to ""one big migration"" when we use apply/dif.…",CASSANDRA-1391,"it should be equivalent to ""one big migration"" when we use apply/dif. which is a lot simpler  than recording each change since the beginning of time and replaying them, and a lot more  convenient when adding new nodes to do it all at once.
",,Architectural solution benefits and drawbacks,16:2458 - 16:2698,1,arjan
11:221,xedin,CASSANDRA-1391,xedin,,Comment,16:2703 - 16:2707,1,arjan
11:135,It doesn’t feel to simple for me to do it in one big run - where you w…,CASSANDRA-1391,"It doesn’t feel to simple for me to do it in one big run - where you would need to  go through whole schema (possibly few times) comparing to applying a single well-defned  change. We are not expecting migrations to be very frequent e.g. because special conditions  should be ensured according to ks/cf getting updated, so even with 1000 (I don’t know if it’s  even a real deal) migrations it’s not a problem for a new node to get them in one request  and apply sequentially.
",,Architectural solution benefits and drawbacks,16:2710 - 16:3186,1,arjan
11:222,jbellis,CASSANDRA-1391,jbellis,,Comment,16:3191 - 16:3197,1,arjan
11:136,"But if it’s modeled as ""the migration is just a RowMutation whose CF i…",CASSANDRA-1391,"But if it’s modeled as ""the migration is just a RowMutation whose CF is in the  same format we store the schema internally"" there is no extra code involved to do both. You  can have a small ""migration"" rowmutation for when the user adds a column, and just send  the entire schema at once for new nodes joining.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",16:3200 - 16:3511,2,arjan
11:223,xedin,CASSANDRA-1391,xedin,,Comment,17:5 - 17:9,1,arjan
11:137,"Migrations are made one-time local thing, serialization/deserializatio…",CASSANDRA-1391,"Migrations are made one-time local thing, serialization/deserialization and save to  system cfs are removed. Schema is propagated in from of row mutations to be applied  on the system ’keyspaces’ cf (apply/dif strategy), upon local user-initiated migration node  uses push tactic (sends updated schema state to all alive nodes in the cluster), pull tactic  (when node requests schema from remote node) is enabled only when node detects schema  disagreement by means of Gossip e.g. when new node joins the ring or push was lost  due to network or other circumstances. Supports automatic schema migration from old  storage (after migration deprecated system ’schema’ and ’migrations’ column families are  dropped). toAvro() methods are removed as no longer needed, fromAvro(...) methods are  kept as @Deprecated to support schema migration from schema cf to new cf. ’Keyspaces’  CF contain data in the human-readable JSON format.
",,Architectural design configuration,17:12 - 17:940,1,arjan
11:224,jbellis,CASSANDRA-1391,jbellis,,Comment,17:945 - 17:951,1,arjan
11:138,rebased patch attached.,CASSANDRA-1391,rebased patch attached.,,,17:954 - 17:976,1,arjan
11:141,validateSchemaAgreement is unnecessary now right?,CASSANDRA-1391,validateSchemaAgreement is unnecessary now right?,,"Architectural solution benefits and drawbacks
Assumptions",17:991 - 17:1039,2,arjan
11:139,the old Migration infrastructure feels unnecessarily heavyweight now.,CASSANDRA-1391, the old Migration infrastructure feels unnecessarily heavyweight now.,,Architectural solution benefits and drawbacks,17:1043 - 17:1112,1,arjan
11:140,"Can we move the val-  idation into the CassandraServer methods, and th…",CASSANDRA-1391,"Can we move the val-  idation into the CassandraServer methods, and then just invoke a MigrationHelper method  from a runnable there?
",,"Architectural design configuration
Assumptions",17:1114 - 17:1248,2,arjan
11:142,SystemTable.dropOldSchemaTables is a no-op. I think we can take this o…,CASSANDRA-1391,"SystemTable.dropOldSchemaTables is a no-op. I think we can take this out entirely since  loadSchema/fromAvro takes care of it?
",,"Architectural solution benefits and drawbacks
Assumptions",17:1311 - 17:1438,2,arjan
11:143,I’d prefer to leave the low level slicing / deserialize in SystemTable…,CASSANDRA-1391,I’d prefer to leave the low level slicing / deserialize in SystemTable class instead of scattered  between Schema and DefsTable,,"Architectural design configuration
Architectural solution benefits and drawbacks",17:1542 - 17:1668,2,arjan
11:225,xedin,CASSANDRA-1391,xedin,,Comment,17:1675 - 17:1679,1,arjan
11:144,I think it’s still a good idea to validate if all nodes have the same…,CASSANDRA-1391,"I think it’s still a good idea to validate if all nodes have the same schema.
",,"Architectural solution benefits and drawbacks
Assumptions",17:1737 - 17:1815,2,arjan
11:145,I tried to optimize it as much as possible because I still think that…,CASSANDRA-1391,"I tried to optimize it as much as possible because I still think that there is a reason to  keep it because it encapsulates all announce, apply and validation logic pretty good. I tried  to move validation and stuf to the CassandraServer but it shows itself as hardly readable  and heavy-weight.
",,Architectural solution benefits and drawbacks,17:2023 - 17:2319,1,arjan
11:146,"Ugh, I forgot to remove it from the fnal version of the patch, sorry..…",CASSANDRA-1391,"Ugh, I forgot to remove it from the fnal version of the patch, sorry...
",,Architectural solution benefits and drawbacks,17:2625 - 17:2697,1,arjan
11:147,"Sure, I will move serialize and serialized methods from Schema to Syst…",CASSANDRA-1391,"Sure, I will move serialize and serialized methods from Schema to SystemTable, plus Def-  sTable.readSchemaRow and getSchema also go there.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",18:1 - 18:141,2,arjan
11:226,xedin,CASSANDRA-1391,xedin,,Comment,18:146 - 18:150,1,arjan
11:148,Rebased main patch and fxes from Jonathan’s previous comment,CASSANDRA-1391,Rebased main patch and fxes from Jonathan’s previous comment,,,18:153 - 18:212,1,arjan
11:149,"dropped unused  method from SystemTable - dropOldSchemaTables, added K…",CASSANDRA-1391,"dropped unused  method from SystemTable - dropOldSchemaTables, added KEYSPACES_CF layout infor-  mation to DefsTable class header (made comment about that in the SystemTable), combined  all low-level methods from Schema and DefsTable into SystemTable.
",,Architectural design configuration,18:215 - 18:466,1,arjan
11:227,jbellis,CASSANDRA-1391,jbellis,,Comment,18:472 - 18:478,1,arjan
11:150,I think we can make life easier for clients dealing with CASSANDRA-247…,CASSANDRA-1391,"I think we can make life easier for clients dealing with CASSANDRA-2477 if we split out  the columns into a separate CF, and adjust how we use composites for the columnfamilies  cf:  schema_keyspaces  ----------------  schema_keyspaces  ----------------  RowKey: ks  => (column=durable_writes, value=true, timestamp=1327061028312185000)  => (column=name, value=""ks"", timestamp=1327061028312185000)  => (column=replication_factor, value=0, timestamp=1327061028312185000)  => (column=strategy_class, value=""org.apache.cassandra.locator.NetworkTopologyStra  timestamp=1327061028312185000)  => (column=strategy_options, value={""datacenter1"":""1""}, timestamp=1327061028312185  schema_columnfamilies  ---------------------  RowKey: ks  => (column=cf:bloom_filter_fp_chance, value=0.0, timestamp=1327061105833119000)  => (column=cf:caching, value=""NONE"", timestamp=1327061105833119000)  => (column=cf:column_type, value=""Standard"", timestamp=1327061105833119000)  => (column=cf:comment, value=""ColumnFamily"", timestamp=1327061105833119000)  => (column=cf:default_validation_class, value=""org.apache.cassandra.db.marshal.Byt  timestamp=1327061105833119000)  => (column=cf:gc_grace_seconds, value=864000, timestamp=1327061105833119000)  => (column=cf:id, value=1000, timestamp=1327061105833119000)  => (column=cf:key_alias, value=""S0VZ"", timestamp=1327061105833119000)  schema_columns  --------------  RowKey: ks  => (column=cf:c:index_name, value=null, timestamp=1327061105833119000)  => (column=cf:c:index_options, value=null, timestamp=1327061105833119000)  => (column=cf:c:index_type, value=null, timestamp=1327061105833119000)  => (column=cf:c:name, value=""aGVsbG8="", timestamp=1327061105833119000)  => (column=cf:c:validation_class, value=""org.apache.cassandra.db.marshal.AsciiType  timestamp=1327061105833119000)  17
This will be more forwards-compatible with CASSANDRA-2474/CQL 3.0, since these cor-  respond to tables having PRIMARY KEY (keyspace, columnfamily) and PRIMARY KEY  (keyspace, columnfamily, column), respectively.
This also has the side beneft of grouping everything for a single keyspace under the same  row key, which means it will be a single atomic RowMutation.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",18:508 - 19:366,2,arjan
11:151,I think leaving strategy_options as json is fne.,CASSANDRA-1391,"I think leaving strategy_options as json is fne.
",,Architectural solution benefits and drawbacks,19:367 - 19:416,1,arjan
11:228,brandon.williams,CASSANDRA-1391,brandon.williams,,Comment,19:421 - 19:436,1,arjan
11:152,I get exceptions while inducing concurrent schema changes:  ERROR 20:5…,CASSANDRA-1391," I get exceptions while inducing concurrent schema changes:  ERROR 20:58:10,904 Fatal exception in thread Thread[MigrationStage:1,5,main]  java.lang.NullPointerException  at org.apache.cassandra.config.ColumnDefinition.toMap(ColumnDefinition.java:  at org.apache.cassandra.config.CFMetaData.diff(CFMetaData.java:978)  at org.apache.cassandra.db.migration.MigrationHelper.updateColumnFamily(Migr  at org.apache.cassandra.db.migration.MigrationHelper.updateColumnFamily(Migr  at org.apache.cassandra.db.DefsTable.mergeRemoteSchema(DefsTable.java:360)  at org.apache.cassandra.db.DefinitionsUpdateVerbHandler$1.runMayThrow(Defini  at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:30)  at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)  at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)  at java.util.concurrent.FutureTask.run(FutureTask.java:138)  at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.jav  at java.lang.Thread.run(Thread.java:662)",,Run-time quality issues,19:438 - 19:1545,1,arjan
11:229,xedin,CASSANDRA-1391,xedin,,Comment,19:1552 - 19:1556,1,arjan
11:153,"Jonathan: Sure, I will do that, although would it be better to name Co…",CASSANDRA-1391,"Jonathan: Sure, I will do that, although would it be better to name ColumnFamilies  using camel-case like SchemaKeyspaces, SchemaColumnFamilies, SchemaColumns instead?
",,,19:1559 - 19:1727,1,arjan
11:154,"Brandon: can you please describe the situation when that happend, have…",CASSANDRA-1391,"Brandon: can you please describe the situation when that happend, have you deleted all  of the columns in update? It seems like I just forgot to add if (columnDefs == null) return  <empty map>; case in ColumnDeftion.toMap(List<ColumnDef>) method.
",,Run-time quality issues,19:1728 - 19:1975,1,arjan
11:230,brandon.williams,CASSANDRA-1391,brandon.williams,,Comment,19:1980 - 19:1995,1,arjan
11:155,"It was pretty simple, I was just getting warmed up :) I issued a creat…",CASSANDRA-1391,"It was pretty simple, I was just getting warmed up :) I issued a creation of a CF on three  machines at once; one got a schema disagreement and the other two received this exception.
",,Run-time quality issues,19:2060 - 19:2243,1,arjan
11:231,xedin,CASSANDRA-1391,xedin,,Comment,19:2248 - 19:2252,1,arjan
11:156,"Ok, gotcha :) I will add null check to ColumnDefnition, that I mention…",CASSANDRA-1391,"Ok, gotcha :) I will add null check to ColumnDefnition, that I mentioned previously,  and re-test everything once again when done with changes requested by Jonathan.
",,Architectural component behavior and structure,19:2255 - 19:2421,1,arjan
11:232,slebresne,CASSANDRA-1391,slebresne,,Comment,19:2426 - 19:2434,1,arjan
11:157,Making them fully lowercase internally would make them case-insensitiv…,CASSANDRA-1391,"Making them fully lowercase internally would make them case-insensitive without any work  using the current patch for CASSANDRA-3761. It’s not really a big deal in any case be-  cause 1) the patch for CASSANDRA-3761 is not yet committed so it could change and 2) it  won’t be very hard to had some special casing for those if we wish so. But if nobody has a  preference, I would suggest calling them ’keyspaces’ and ’columnfamilies’ directly.
",,Architectural solution benefits and drawbacks,19:2510 - 19:2953,1,arjan
11:233,xedin,CASSANDRA-1391,xedin,,Comment,19:2958 - 19:2962,1,arjan
11:158,"I’m fne dropping ""schema_"" prefx and going with ""keyspaces"", ""columnfa…",CASSANDRA-1391,"I’m fne dropping ""schema_"" prefx and going with ""keyspaces"", ""columnfamilies""",,Architectural solution benefits and drawbacks,19:2965 - 19:3041,1,arjan
11:159,"but how do we name ""columns"" cf then, something like ""columnfamily_col…",CASSANDRA-1391,"but how do we name ""columns"" cf then, something like ""columnfamily_columns""?
",,,19:3044 - 19:3121,1,arjan
11:234,jbellis,CASSANDRA-1391,jbellis,,Comment,20:5 - 20:11,1,arjan
11:160,"It’s not a big deal, but IMO undescore + lowercase fts better with CQL…",CASSANDRA-1391,"It’s not a big deal, but IMO undescore + lowercase fts better with CQL 3.0 making  everything case-insensitive by default.
",,Architectural solution benefits and drawbacks,20:14 - 20:137,1,arjan
11:235,xedin,CASSANDRA-1391,xedin,,Comment,20:142 - 20:146,1,arjan
11:161,"Works for me, so be it ""schema_keyspaces"", ""schema_columnfamilies"" and…",CASSANDRA-1391,"Works for me, so be it ""schema_keyspaces"", ""schema_columnfamilies"" and ""schema_columns"".
",,Architectural solution benefits and drawbacks,20:149 - 20:238,1,arjan
11:162,Is this going to be done today or tomorrow for 1.1 freeze?,CASSANDRA-1391," Is this going to be done today or tomorrow for 1.1 freeze?
",,,20:251 - 20:311,1,arjan
11:163,Absolutely! I’m fnishing up few last things and going to attach a patc…,CASSANDRA-1391," Absolutely! I’m fnishing up few last things and going to attach a patch in few  hours.
",,,20:322 - 20:410,1,arjan
11:236,xedin,CASSANDRA-1391,xedin,,Comment,20:415 - 20:419,1,arjan
11:164,squashed previous two comments in one and added schema diferentiation…,CASSANDRA-1391,"squashed previous two comments in one and added schema diferentiation between  schema_keyspaces, schema_columnfamilies and schema_columns.
",,Architectural design configuration,20:422 - 20:561,1,arjan
11:165,No exceptions while testing v2.,CASSANDRA-1391,"No exceptions while testing v2.
",,,20:584 - 20:615,1,arjan
11:237,jbellis,CASSANDRA-1391,jbellis,,Comment,20:621 - 20:627,1,arjan
11:166,"LGTM, +1.",CASSANDRA-1391,"LGTM, +1.
",,Architectural solution benefits and drawbacks,20:630 - 20:640,1,arjan
11:167,Committed.,CASSANDRA-1391,"Committed.
",,,20:652 - 20:663,1,arjan
12:1,Provide confgurable encryption support for internode communication,CASSANDRA-1567,Provide confgurable encryption support for internode communication,,Quality Attribute requirement,3:52 - 3:117,1,arjan
12:2,Provide the option to encrypt internode communication,CASSANDRA-1567,Provide the option to encrypt internode communication,,Quality Attribute requirement,3:137 - 3:189,1,arjan
12:3,The initial thought is to use JSSE  (http://download.oracle.com/javase…,CASSANDRA-1567,"The initial thought is to use JSSE  (http://download.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html) to  wrap the existing ServerSocket & Sockets. This will only be an optional confguration and not  enabled by default. The defaults would be TLS V1, RSA 1024-bit keys for handshake and  SSL_RSA_WITH_RC4_128_MD5 as the cipher suite. Although this can be made confgurable  if the need arises.
",,Architectural design configuration,3:192 - 3:610,1,arjan
12:4,working code. Need to update the confguration for keystores,CASSANDRA-1567,working code. Need to update the confguration for keystores,,,3:670 - 3:728,1,arjan
12:30,stuhood,CASSANDRA-1567,stuhood,,Comment,3:734 - 3:740,1,arjan
12:5,"* For 0001, I would really like to see an {{A(bstract)StreamableSocket…",CASSANDRA-1567,"* For 0001, I would really like to see an {{A(bstract)StreamableSocket}} rather  than complete duplication of the Stream classes",,Technical debt,3:743 - 3:870,1,arjan
12:6,"* Rather than a boolean, the {{internode_encryption}} setting should p…",CASSANDRA-1567,"* Rather than a boolean, the {{internode_encryption}} setting should probably be an enum,  to leave room to add conditional encryption based on zones returned by the snitch",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",3:873 - 3:1044,2,arjan
12:7,"* The SSL settings in JVM_OPTS should be disabled by default, and need…",CASSANDRA-1567,"* The SSL settings in JVM_OPTS should be disabled by default, and need a comment  linking to a place to get more information about the keystore and truststore fles (probably  the ’Creating Keystores’ section of the link in the description)",,Run-time quality issues,3:1047 - 3:1285,1,arjan
12:31,stuhood,CASSANDRA-1567,stuhood,,Comment,3:1359 - 3:1365,1,arjan
12:8,"Also, can we add a startup message that indicates the encryption mode…",CASSANDRA-1567,"Also, can we add a startup message that indicates the encryption mode being  used?
",,User requirement,3:1368 - 3:1451,1,arjan
12:32,rnirmal,CASSANDRA-1567,rnirmal,,Comment,3:1455 - 3:1461,1,arjan
12:9,Done,CASSANDRA-1567,Done,,Architectural solution benefits and drawbacks,3:1592 - 3:1595,1,arjan
12:10,"Updated to use an enum, just (all, none) for now.",CASSANDRA-1567,"Updated to use an enum, just (all, none) for now.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",4:84 - 4:134,2,arjan
12:11,Having those properties in should not be a problem. We can provide a w…,CASSANDRA-1567,"Having those properties in should not be a problem. We can provide a wiki page on how to  get everything setup.
",,Architectural solution benefits and drawbacks,4:378 - 4:490,1,arjan
12:33,rnirmal,CASSANDRA-1567,rnirmal,,Comment,4:494 - 4:500,1,arjan
12:13,"There’s one more change I’m going to add, and will hopefully have it o…",CASSANDRA-1567,"There’s one more change I’m going to add, and will hopefully have it out soon,  rebased and all.",,,4:503 - 4:598,1,arjan
12:12,I’m going to make the default cipher suite we use to AES_128/256 with…,CASSANDRA-1567,"I’m going to make the default cipher suite we use to AES_128/256 with  SHA.
",,Architectural component behavior and structure,4:600 - 4:675,1,arjan
12:14,Nirmal mentioned that he was going to do a bit more refactoring of thi…,CASSANDRA-1567,"Nirmal mentioned that he was going to do a bit more refactoring of this one  before calling it reviewable again.
",,,4:689 - 4:802,1,arjan
12:34,rnirmal,CASSANDRA-1567,rnirmal,,Comment,4:806 - 4:812,1,arjan
12:15,So for this I think we’ll go with just all internode encryption with A…,CASSANDRA-1567,"So for this I think we’ll go with just all internode encryption with AES_128/256  in an either/or situation. Either all your cluster node transfers is encrypted or not. Based  on if there’s demand to have just cross DC encrypted we can update it at that point and if  users want to confgure encryption options.
",,"Architectural design configuration
Assumptions",4:815 - 4:1125,2,arjan
12:16,8. jbellis: Where did patch 0001 go? Was it committed separately? 9. r…,CASSANDRA-1567,"8. jbellis: Where did patch 0001 go? Was it committed separately?
9. rnirmal: During the last update I combined 0001 & 0002. So everything is in 0002 and  0003 is a sample keystore and env confg. yet to upload the latest changes, but what’s there  works  10. jbellis: bq. make the default cipher suite we use to AES_128/256 with SHA  This looks like all that needs to be done to close out this ticket. That and probably a  fairly hairy rebase. :)  11. rnirmal: Attaching rebased versions (-V2) with the latest updates. I’ve tested it a bit and  seems to work fne. Would be nice to test it out a little more.
12. xedin: Nirmal Ranganathan: Can the latest 002 and 003 patches be considered as complete  solution?
13. rnirmal: Yes it can be considered as patch ready. Pavel it will be great if you can review  it too.
14. xedin: Great! I will review it too. Can you please change status to Patch Available?
",,,4:1127 - 4:2035,1,arjan
12:20,Minor notes:  1. Clean code style of the method defnitions (e.g. Datab…,CASSANDRA-1567,"Minor notes:  1. Clean code style of the method defnitions (e.g. DatabaseDescriptor methods size-  MemtableThroughput, sizeMemtableOperations)  2. remove space in line ""bytesRead += buf. limit();"" of SSLIncomingStreamReader class  Everything else looks good.
",,,4:2047 - 4:2305,1,arjan
12:21,"Am I missing something big, or does this only encrypt stream communica…",CASSANDRA-1567,"Am I missing something big, or does this only encrypt stream communications?
EDIT: nm. Stu pointed out the parts that I missed.
",,,4:2322 - 4:2450,1,arjan
12:35,stuhood,CASSANDRA-1567,stuhood,,Comment,4:2456 - 4:2462,1,arjan
12:22,"Nirmal, thanks again for your work here: this will really be a killer…",CASSANDRA-1567,"Nirmal, thanks again for your work here: this will really be a killer feature.
",,Architectural solution benefits and drawbacks,4:2465 - 4:2544,1,arjan
12:23,* Could we add a class level javadoc to SSLFileStreamTask to indicate…,CASSANDRA-1567,"* Could we add a class level javadoc to SSLFileStreamTask to indicate that it exists be-  cause FileStreamTask uses sendFile?
",,,4:2545 - 4:2671,1,arjan
12:24,+1 aside from that.,CASSANDRA-1567,"+1 aside from that.
",,Architectural solution benefits and drawbacks,4:2672 - 4:2692,1,arjan
12:25,"Pavel: I’ve updated based on your notes, btw sizeMemtableThroughput an…",CASSANDRA-1567," Pavel: I’ve updated based on your notes, btw sizeMemtableThroughput and size-  MemtableOperations shouldn’t be there in the frst place, I think it got left behind in one  of my rebases, removed it now.
StuHood: Thanks for looking through it, I’ve added comments to explain why SSLSock-  et/SSLServerSocket cannot encrypt data transferred using FileChannel.transferTo/transferFrom.
Gary: As StuHood mentioned that’s the reason the additional SSL versions. But all intern-  ode data is getting encrypted.
",,,5:13 - 5:519,1,arjan
12:26,* setReuseAddress happens before bind.,CASSANDRA-1567,"* setReuseAddress happens before bind.
",,,5:535 - 5:574,1,arjan
12:27,* added link to keytool docs in cassandra.yaml.,CASSANDRA-1567,* added link to keytool docs in cassandra.yaml.,,,5:575 - 5:621,1,arjan
12:28,20. rnirmal: Updated the patch to cleanly apply on 0.7 branch and trun…,CASSANDRA-1567,"20. rnirmal: Updated the patch to cleanly apply on 0.7 branch and trunk  21. gdusbabek: Moving to 0.8 based on the ""shorter release schedule"" thread on -dev.
22. gdusbabek: committed. excellent work!
23. hudson: Integrated in Cassandra #678 (See [https://hudson.apache.org/hudson/job/Cassandra/678/])  confgurable internode encryption. patch by rnirmal, reviewed by gdusbabek. CASSANDRA-  1567",,,5:624 - 5:1018,1,arjan
12:29,24. jbellis: where did we document how to use this? 25. rnirmal: Haven…,CASSANDRA-1567,"24. jbellis: where did we document how to use this?
25. rnirmal: Haven’t documented yet, just the info in the conf fle for now, since it was moved  to 0.8 release. I haven’t looked at the wiki recently, if we have sections or docs for 0.8 release,  I’ll add this with a note.
",,,5:1021 - 5:1298,1,arjan
13:9,Redesigned Compaction,CASSANDRA-1608,Redesigned Compaction,,Run-time quality issues,3:52 - 3:72,1,arjan
13:1,"After seeing the I/O issues in CASSANDRA-1470, I’ve been doing some mo…",CASSANDRA-1608,"After seeing the I/O issues in CASSANDRA-1470, I’ve been doing some more thinking on this  subject that I wanted to lay out.
",,Run-time quality issues,3:92 - 3:217,1,arjan
13:2,I propose we redo the concept of how compaction works in Cassandra,CASSANDRA-1608,I propose we redo the concept of how compaction works in Cassandra,,Architectural design configuration,3:218 - 3:283,1,arjan
13:3,"At the moment, com-  paction is kicked of based on a write access patt…",CASSANDRA-1608,"At the moment, com-  paction is kicked of based on a write access pattern, not read access pattern. In most cases, you  want the opposite. You want to be able to track how well each SSTable is performing in the  system.",,Run-time quality issues,3:286 - 3:504,1,arjan
13:4,"If we were to keep statistics in-memory of each SSTable, prioritize th…",CASSANDRA-1608,"If we were to keep statistics in-memory of each SSTable, prioritize them based on most  accessed, and bloom flter hit/miss ratios, we could intelligently group sstables that are being read  most often and schedule them for compaction. We could also schedule lower priority maintenance  on SSTable’s not often accessed.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",3:506 - 3:825,2,arjan
13:5,"I also propose we limit the size of each SSTable to a fx sized, that g…",CASSANDRA-1608,"I also propose we limit the size of each SSTable to a fx sized, that gives us the ability to better  utilize our bloom flters in a predictable manner.",,"Architectural design configuration
Architectural solution benefits and drawbacks",3:826 - 3:975,2,arjan
13:6,"At the moment after a certain size, the bloom  flters become less reli…",CASSANDRA-1608,"At the moment after a certain size, the bloom  flters become less reliable.",,Run-time quality issues,3:977 - 3:1051,1,arjan
13:7,This would also allow us to group data most accessed.,CASSANDRA-1608,This would also allow us to group data most accessed. ,,Architectural solution benefits and drawbacks,3:1053 - 3:1106,1,arjan
13:8,Currently the  size of an SSTable can grow to a point where large port…,CASSANDRA-1608,"Currently the  size of an SSTable can grow to a point where large portions of the data might not actually be  accessed as often.
",,Run-time quality issues,3:1107 - 3:1235,1,arjan
13:198,stuhood,CASSANDRA-1608,stuhood,,Comment,4:51 - 4:57,1,arjan
13:10,One way to provide locality of reference for sstables would be to pers…,CASSANDRA-1608,"One way to provide locality of reference for sstables would be to persist sum-  maries of individual rows which ’supersede’ the content in sstables written before them. For  example, if you have fve sstables containing key ’A’, you would create a new sstable #6  containing all content for ’A’, and marked as superseding for ’A’. Then, since you have a full  copy of data for ’A’, you no longer need to read from the other sstables.
But how would a reader know which sstables to check for a particular key? We have sstable  generation numbers, but they are currently only used as unique ids.",,Architectural design configuration,4:60 - 4:651,1,arjan
13:11,# The ’superseding’ mark for a particular key could indicate which gen…,CASSANDRA-1608,"# The ’superseding’ mark for a particular key could indicate which generations it super-  seded, so we could prevent reads to superseded sstables",,Architectural component behavior and structure,4:672 - 4:816,1,arjan
13:12,# If we refactored the system to read memtables/sstables in generation…,CASSANDRA-1608,"# If we refactored the system to read memtables/sstables in generation order, we could stop  looking for content for A when we reached an sstable that superseded older sstables",,Architectural design configuration,4:819 - 4:994,1,arjan
13:13,"# When superseding a value, we could delete it from the bloom flters f…",CASSANDRA-1608,"# When superseding a value, we could delete it from the bloom flters for the superseded  sstables. While hella cool, this solution would be a big change:",,Architectural design configuration,4:997 - 4:1149,1,arjan
13:14,"While hella cool, this solution would be a big change:",CASSANDRA-1608,"While hella cool, this solution would be a big change:",,Architectural solution benefits and drawbacks,4:1096 - 4:1149,1,arjan
13:15,"** If you reached a threshold of emptiness in the bloom flter, you cou…",CASSANDRA-1608,"** If you reached a threshold of emptiness in the bloom flter, you could perform single-  sstable-compactions fltered by values that still match",,Architectural design configuration,4:1152 - 4:1295,1,arjan
13:16,** Requires a bloom flter which supports deletes (ours don’t yet),CASSANDRA-1608,** Requires a bloom flter which supports deletes (ours don’t yet),,Architectural design configuration,4:1298 - 4:1362,1,arjan
13:199,scode,CASSANDRA-1608,scode,,Comment,4:1368 - 4:1372,1,arjan
13:17,One thing to consider when deferring or omitting compaction of sstable…,CASSANDRA-1608,"One thing to consider when deferring or omitting compaction of sstables is that  it, similarly to a cache, will tend to optimize the performance in the common case but is  susceptible to a sudden degredation of performance in response to a suddenly changing work-  load. That might be something to keep within reasonable limits, at least in out-of-the-box  confgurations.
",,Architectural solution benefits and drawbacks,4:1375 - 4:1747,1,arjan
13:18,On Stu’s (3); what bloom flter would you have in mind that supports de…,CASSANDRA-1608,On Stu’s (3); what bloom flter would you have in mind that supports deletions? Is there a  good paper to read?,,,4:1748 - 4:1857,1,arjan
13:19,Is there anything better than what is described at http://en.wikipedia…,CASSANDRA-1608,"Is there anything better than what is described at http://en.wikipedia.org/wiki/Bloom_flter#C  (indicating some algorithm that consumes roughly half as much as a counting bf; but still  scaling linearly with max count)?
",,Other system architectural solutions,4:1859 - 4:2079,2,arjan
13:200,scode,CASSANDRA-1608,scode,,Comment,4:2083 - 4:2087,1,arjan
13:20,"Although now that I think about it some more, I guess Cassandra would…",CASSANDRA-1608,"Although now that I think about it some more, I guess Cassandra would only need  a fxed count of exactly 2, making it a non-issue.
",,"Architectural solution benefits and drawbacks
Assumptions",4:2090 - 4:2221,2,arjan
13:201,stuhood,CASSANDRA-1608,stuhood,,Comment,4:2225 - 4:2231,1,arjan
13:21,As you said: we would need a counting flter with 2 bits per bucket: if…,CASSANDRA-1608,"As you said: we would need a counting flter with 2 bits per bucket: if both bits are set, the  bucket has collided.
If any of the buckets for a key have collided, you can’t perform the delete, but that isn’t the  end of the world here.
EDIT: Actually, if you couldn’t perform the delete, you might end up superseding a given  sstable multiple times, so this is something we’d want to avoid.",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",4:2322 - 4:2713,2,arjan
13:202,scode,CASSANDRA-1608,scode,,Comment,4:2719 - 4:2723,1,arjan
13:22,Regarding superseding rows in sstables; what would be the criteria for…,CASSANDRA-1608,Regarding superseding rows in sstables; what would be the criteria for picking which  rows to supersede for?,,,4:2726 - 4:2833,1,arjan
13:23,A simple threshold would be easy and certainly addresses extreme  case…,CASSANDRA-1608,A simple threshold would be easy and certainly addresses extreme  cases of rows being spread.,,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",4:2835 - 4:2927,2,arjan
13:24,But if one also expects to take into account of often the rows  are re…,CASSANDRA-1608,"But if one also expects to take into account of often the rows  are read, that would imply recenticity or frequency tracking?
",,"Architectural design configuration
Assumptions",4:2929 - 4:3055,2,arjan
13:25,A simple threshold on sstable count would certainly help avoiding the…,CASSANDRA-1608,"A simple threshold on sstable count would certainly help avoiding the extreme cases of  reads across many sstables.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:1 - 5:117,2,arjan
13:26,But in terms of trying to keep frequently accessed data together with…,CASSANDRA-1608,"But in terms of trying to keep frequently accessed data together with high locality (as briefy  alluded to in CASSANDRA-1625), would that require tracking some information over time  at row level granularity? (I’m concerned about the overhead of such tracking.)",,"Architectural component behavior and structure
Assumptions",5:118 - 5:378,2,arjan
13:27,"If so, an observation is that false positives are allowed for the stat…",CASSANDRA-1608,"If so, an observation is that false positives are allowed for the stats. I.e., recenticity/fre-  quency could be associated with something like 64-bit-hash-of-key rather than keys, meaning  that some optimizations become possible (e.g. smacking hash-of-key:counter pairs into large  byte arrays).
",,"Architectural design configuration
Architectural tactics",5:381 - 5:678,2,arjan
13:203,stuhood,CASSANDRA-1608,stuhood,,Comment,5:682 - 5:688,1,arjan
13:28,A confgurable threshold on access count is one metric: you could attac…,CASSANDRA-1608,"A confgurable threshold on access count is one metric: you could attach an access counter  to rows in the memtable or rowcache. If a row reaches a threshold of accesses, then you  supersede it by storing the data for the read in the memtable, and marking it superseded in  any sstables.
",,Architectural component behavior and structure,5:803 - 5:1090,1,arjan
13:29,"This works for skinny rows, but just like with the row cache, we need…",CASSANDRA-1608,"This works for skinny rows, but just like with the row cache, we need a strategy for wider  rows.",,Architectural solution benefits and drawbacks,5:1092 - 5:1188,1,arjan
13:30,Another metric would be the minimum number of sstables to supersede: i…,CASSANDRA-1608,"Another metric would be the minimum number of sstables to supersede: if a row is stored  in 1 sstable, (obviously) don’t supersede, but if it is stored in 4, supersede, etc.
",,Architectural component behavior and structure,5:1192 - 5:1366,1,arjan
13:31,"I don’t think so? If something was recently superseded, it will be sto…",CASSANDRA-1608,"I don’t think so? If something was recently superseded, it will be stored in 1 sstable, and  there is no need to supersede it reaches your threshold.
",,"Architectural component behavior and structure
Assumptions",5:1505 - 5:1655,2,arjan
13:32,I think this is what we get from the bloom flter edits: sometimes a su…,CASSANDRA-1608,"I think this is what we get from the bloom flter edits: sometimes a supersede will fail for  some sstables, but it’s not really a big deal, since the whole operation probably still pushes  you below your threshold for sstables.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",5:1731 - 5:1959,3,arjan
13:204,scode,CASSANDRA-1608,scode,,Comment,5:1963 - 5:1967,1,arjan
13:33,"With respect to tracking information, I meant tracking the information…",CASSANDRA-1608,"With respect to tracking information, I meant tracking the information necessary to  make the determination as to which rows to supersede or otherwise act upon, rather than  keeping track of what *has* been superseded (which as you point out is dealt with by bloom  flters).
",,Architectural design configuration,5:1970 - 5:2245,1,arjan
13:34,In the case of simple criteria (such as seeing a single read spread ac…,CASSANDRA-1608,In the case of simple criteria (such as seeing a single read spread across more than N sstables)  no such tracking is necessary,,Architectural design configuration,5:2246 - 5:2372,1,arjan
13:35,But I am concerned with strategies that imply having to keep  signifca…,CASSANDRA-1608,"But I am concerned with strategies that imply having to keep  signifcant amounts of data over time, such as anything based on row-level frequency/recency  of access.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",5:2375 - 5:2541,3,arjan
13:36,"In particular, if one hopes to supersede so efectively that hot rows (…",CASSANDRA-1608,"In particular, if one hopes to supersede so efectively that hot rows (regardless of sstable  spread) end up in separate sstables with high locality of access, will not this need such row-  level information tracking?",,"Architectural design configuration
Assumptions",5:2542 - 5:2757,2,arjan
13:205,kelvin,CASSANDRA-1608,kelvin,,Comment,6:4 - 6:9,1,arjan
13:37,An alternative strategy that dovetails w/ the above proposal (fxed-siz…,CASSANDRA-1608,"An alternative strategy that dovetails w/ the above proposal (fxed-size SSTs and  keeping track of SST co-access stats):  Lazily coordinate timestamps across the cluster by maintaining increasing timestamps across  SSTs on each replica.
",,Architectural design configuration,6:12 - 6:249,1,arjan
13:38,"If we can enforce increasing timestamps across SSTs, then lookups will…",CASSANDRA-1608,"If we can enforce increasing timestamps across SSTs, then lookups will be cheaper. In-  stead of doing a slice (under the hood) for each lookup, we only need to read from the last  SST where a key+column was written based on BFs (FPs not withstanding). Slices will not  be improved by this scheme.
",,Architectural solution benefits and drawbacks,6:250 - 6:548,1,arjan
13:39,"A way to implement this would be to:  1) on a CL.ONE write, always wri…",CASSANDRA-1608,"A way to implement this would be to:  1) on a CL.ONE write, always write to a lead replica, and  2) on a CL.QUORUM write, a replica will reject a write w/ a timestamp less than the high-  est timestamp in that CF’s last SST (may need to be MT); upon which, the client will need  to re-submit a write w/ the appropriate timestamp ofset.
A consideration that needs to be taken into account is AES and other SST streaming oper-  ations across replicas. e.g. streamed SSTs will need to be lined up by min/max timestamp  of the SSTs; if an SST overlaps, then we may need to, either:  1) re-partition/compact the overlapping SSTs, or  2) lazily compact the overlapping SSTs and absorb the cost to lookups, in the meantime.
",,Architectural design configuration,6:549 - 6:1267,1,arjan
13:40,The benefts of loosely coordinated timestamps are:  1) lookups will be…,CASSANDRA-1608,"The benefts of loosely coordinated timestamps are:  1) lookups will be measurably improved,  2) dovetails nicely w/ fxed-size SSTs, and  3) SST co-access stats can be more coarse-grained (based on SST), instead of fne-grained  row-level stats.
The above proposal is would align our data model to be closer to BigTable and HBase.
i.e. lookups won’t be penalized, anymore.
",,Architectural solution benefits and drawbacks,6:1268 - 6:1641,1,arjan
13:206,kingryan,CASSANDRA-1608,kingryan,,Comment,6:1645 - 6:1652,1,arjan
13:41,I think if we just start with tracking which sstables are accessed tog…,CASSANDRA-1608," I think if we just start with tracking which sstables are accessed together, then  prioritizing those for being compacted together we can improve our locality with minimal  overhead.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",6:1654 - 6:1838,3,arjan
13:42,Fixed size (or variable within a range) SSTables could then also help.…,CASSANDRA-1608,"Fixed size (or variable within a range) SSTables could then also help. If we achieve the  fxed size by splitting by token range when doing a compaction, we would have much more  predictable read time for both skinny rows and wide rows. I’m not sure how well this would  react to a rapidly changing workload, though.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",6:1839 - 6:2155,3,arjan
13:207,stuhood,CASSANDRA-1608,stuhood,,Comment,6:2160 - 6:2166,1,arjan
13:43,"Although it probably sounds like I have bloom flter fever, we could us…",CASSANDRA-1608,"Although it probably sounds like I have bloom flter fever, we could use a bloom flter for this  as well: flters based on multisets, (spectral bloom flters, count min sketches), allow storing  approximate counts for values. The access counts for rows for the lifetime of a memtable  could be stored in a flter attached to the memtable: at read time, the approximate access  count of the row key could be checked against a threshold of accesses, and be stored in the  memtable as superseding.
",,Architectural design configuration,6:2340 - 6:2831,1,arjan
13:208,m0nstermind,CASSANDRA-1608,m0nstermind,,Comment,6:2836 - 6:2846,1,arjan
13:44,"I propose to limit size of sstables not directly in megabytes, but by…",CASSANDRA-1608," I propose to limit size of sstables not directly in megabytes, but by parti-  tioning them by token ranges, like normal cassandra ring is implemented. This way, data  are partitioned on cassandra cluster by token ranges across nodes, and , additionally on  each node it is partitioned into several subranges of the node’s token range.Each of token  subranges is tracked separatedly and is stored in separate memtable and sstable set. Rows  from diferent subranges are never stored in the same memtable and sstable. Compactions  5
and other operations are running on sstables from exactly 1 subrange.
This way complexities with rows tracking, prioretization, etc of fxed size sstables are elim-  inated, I believe and we have smaller sstables (well, not exactly at 500Mb limit each, but  this is not the target, I think) and lighter compactions.
",,Architectural design configuration,6:2848 - 7:317,1,arjan
13:45,"This way complexities with rows tracking, prioretization, etc of fxed…",CASSANDRA-1608,"This way complexities with rows tracking, prioretization, etc of fxed size sstables are elim-  inated, I believe and we have smaller sstables (well, not exactly at 500Mb limit each, but  this is not the target, I think) and lighter compactions.
",,"Architectural solution benefits and drawbacks
Assumptions",7:72 - 7:316,2,arjan
13:209,jbellis,CASSANDRA-1608,jbellis,,Comment,7:322 - 7:328,1,arjan
13:46,Partitioning by token ranges is functionally equivalent to virtual nod…,CASSANDRA-1608,"Partitioning by token ranges is functionally equivalent to virtual nodes, no? Which  in the OPP case means you now have to deal with intra-node load balancing.
",,"Architectural solution benefits and drawbacks
Assumptions",7:331 - 7:491,2,arjan
13:210,m0nstermind,CASSANDRA-1608,m0nstermind,,Comment,7:496 - 7:506,1,arjan
13:47,"Yes, but having split individual node’s data to more subranges we can…",CASSANDRA-1608,"Yes, but having split individual node’s data to more subranges we can make  negative impact of not well balanced sstables practically negligible.
",,Architectural solution benefits and drawbacks,7:509 - 7:655,1,arjan
13:211,kingryan,CASSANDRA-1608,kingryan,,Comment,7:660 - 7:667,1,arjan
13:48,I don’t think we should partition internally unless we’re willing to g…,CASSANDRA-1608," I don’t think we should partition internally unless we’re willing to go all the way  and implement vnodes.
",,"Architectural solution benefits and drawbacks
Assumptions",7:669 - 7:777,2,arjan
13:50,Oleg- I think a simpler strategy for ensuring locality,CASSANDRA-1608,Oleg- I think a simpler strategy for ensuring locality,,"Architectural solution benefits and drawbacks
Assumptions",7:778 - 7:831,2,arjan
13:49,Oleg- I think a simpler strategy for ensuring locality is you split th…,CASSANDRA-1608,"Oleg- I think a simpler strategy for ensuring locality is you split them by token order.
Let’s say you want to limit SSTable size to 2GB. When you go to compact 2 2GB SSTables,  you could end up with anywhere from 2-4GB of data (ok not exactly true, but go with it for  now). This means you’ll likely still be producing 2 SSTables. I propose that you split those  two by token range.",,Architectural design configuration,7:778 - 7:1161,1,arjan
13:212,jbellis,CASSANDRA-1608,jbellis,,Comment,7:1168 - 7:1174,1,arjan
13:51,partitions are required for vnodes but not vice versa.,CASSANDRA-1608,"partitions are required for vnodes but not vice versa.
",,Architectural solution benefits and drawbacks,7:1289 - 7:1344,1,arjan
13:213,m0nstermind,CASSANDRA-1608,m0nstermind,,Comment,7:1349 - 7:1359,1,arjan
13:52,"Ryan: yes, the idea is exactly in splitting sstables by uniform token…",CASSANDRA-1608," Ryan: yes, the idea is exactly in splitting sstables by uniform token ranges.
So, if total node’s data is 4Gb and you split to 2 subranges, after major compaction you’ll  have 2 sstables, each with size around 2gb-4gb. If you split to 256 subranges, you’ll have  256 sstables. It is unlikely, that any one of them will be close to 4gb otherwise your cluster  is very badly unbalanced and you should rethink what you’re really doing.
IMHO it it much better to have 256 subranges by node than 2. No negative efect on  performance, but compactions as well as disk space management become much lighter.
",,Architectural design configuration,7:1361 - 7:1963,1,arjan
13:53,IMHO it it much better to have 256 subranges by node than 2. No negati…,CASSANDRA-1608,"IMHO it it much better to have 256 subranges by node than 2. No negative efect on  performance, but compactions as well as disk space management become much lighter",,Architectural solution benefits and drawbacks,7:1797 - 7:1960,1,arjan
13:214,tjake,CASSANDRA-1608,tjake,,Comment,7:1968 - 7:1972,1,arjan
13:54,1) Compaction Coordination: read performance impact can be mitigated i…,CASSANDRA-1608,"1) Compaction Coordination: read performance impact can be mitigated if we make sure  replicas of data are not doing compaction at the same time as the other replicas. dynamic  snitch would do bulk of the work. Just encode compaction workload into gossip?
",,Architectural design configuration,7:2075 - 7:2331,1,arjan
13:55,read performance impact can be mitigated,CASSANDRA-1608,read performance impact can be mitigated,,Architectural solution benefits and drawbacks,7:2103 - 7:2142,1,arjan
13:56,2) Compaction Sharing: Beneft of splitting SStable by token range is w…,CASSANDRA-1608,"2) Compaction Sharing: Beneft of splitting SStable by token range is we can send the  resulting SStables to replicas of this data rather than have these nodes compact their own  data. this could help 1 node do the work of the others.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",7:2332 - 7:2566,2,arjan
13:215,jbellis,CASSANDRA-1608,jbellis,,Comment,7:2571 - 7:2577,1,arjan
13:57,1) is a possibility but the implementation details would be very difer…,CASSANDRA-1608, 1) is a possibility but the implementation details would be very diferent,,"Architectural design configuration
Architectural solution benefits and drawbacks",7:2579 - 7:2652,2,arjan
13:58,snitch  has nothing to do with compaction and gossip is too high-laten…,CASSANDRA-1608,"snitch  has nothing to do with compaction and gossip is too high-latency.
",,Architectural solution benefits and drawbacks,7:2655 - 7:2729,1,arjan
13:59,2) sounds like a great way to make things very very fragile,CASSANDRA-1608,2) sounds like a great way to make things very very fragile,,Architectural solution benefits and drawbacks,7:2730 - 7:2788,1,arjan
13:216,tjake,CASSANDRA-1608,tjake,,Comment,7:2795 - 7:2799,1,arjan
13:60,I think you could use snitch since the performance of the node doing c…,CASSANDRA-1608,"I think you could use snitch since the performance of the node doing compaction would  degrade and dynamic snitch would naturally prefer the other replicas.
",,Architectural design configuration,7:2803 - 7:2960,1,arjan
13:217,jbellis,CASSANDRA-1608,jbellis,,Comment,8:5 - 8:11,1,arjan
13:61,"sure, that is what snitch already does. but inferring from ""node X is…",CASSANDRA-1608,"sure, that is what snitch already does. but inferring from ""node X is slow"" to ""avoid  compacting CF Y"" is a leap it can’t make, and shouldn’t. that’s the wrong hole for this peg.
",,Architectural solution benefits and drawbacks,8:14 - 8:194,1,arjan
13:218,tjake,CASSANDRA-1608,tjake,,Comment,8:199 - 8:203,1,arjan
13:62,"Right, I’m not saying it blindly makes that assumption, snitch would b…",CASSANDRA-1608,"Right, I’m not saying it blindly makes that assumption, snitch would be passive,  unchanged. There would be another method for identifying what nodes are currently com-  pacting.
",,Architectural design configuration,8:206 - 8:385,1,arjan
13:219,davidboxenhorn,CASSANDRA-1608,davidboxenhorn,,Comment,8:390 - 8:403,1,arjan
13:63,I don’t see any reason why OPP has to be used within a node just becau…,CASSANDRA-1608,"I don’t see any reason why OPP has to be used within a node just because it is used between  nodes. I think RP should always be used within a node, and the number of partitions should  be chosen to keep SST size optimal.
RP makes OPP range queries a little harder, but not much: All partitions must be queried  to fnd the next row, but since range queries are done in batches (e.g. get the next 100 rows)  I don’t think it will slow things down.
",,Architectural design configuration,8:570 - 8:1017,1,arjan
13:64,"RP makes OPP range queries a little harder, but not much: All partitio…",CASSANDRA-1608,"RP makes OPP range queries a little harder, but not much: All partitions must be queried  to fnd the next row, but since range queries are done in batches (e.g. get the next 100 rows)  I don’t think it will slow things down",,Architectural solution benefits and drawbacks,8:792 - 8:1014,1,arjan
13:220,slebresne,CASSANDRA-1608,slebresne,,Comment,8:1022 - 8:1030,1,arjan
13:65,A little harder ? How can you return efciently the 100 next rows in th…,CASSANDRA-1608,"A little harder ? How can you return efciently the 100 next rows in the sense  of the OPP if you don’t store the rows in that order within a node ?
",,Architectural solution benefits and drawbacks,8:1033 - 8:1180,1,arjan
13:221,jbellis,CASSANDRA-1608,jbellis,,Comment,8:1186 - 8:1192,1,arjan
13:66,Here is the approach used by LevelDB (http://leveldb.googlecode.com/sv…,CASSANDRA-1608,"Here is the approach used by LevelDB (http://leveldb.googlecode.com/svn/trunk/doc/impl.html)  ""The set of sorted tables are organized into a sequence of levels. The sorted table generated  from a [fush] is placed in a special young level (also called level-0). When the number of  young fles exceeds a certain threshold (currently four), all of the young fles are merged  together with all of the overlapping level-1 fles to produce a sequence of new level-1 fles  (we create a new level-1 fle for every 2MB of data.)  ""Files in the young level may contain overlapping keys. However fles in other levels have  distinct non-overlapping key ranges. Consider level number L where L >= 1. When the  combined size of fles in level-L exceeds (10ˆL) MB (i.e., 10MB for level-1, 100MB for level-2,  ...), one fle in level-L, and all of the overlapping fles in level-(L+1) are merged to form a set  of new fles for level-(L+1). These merges have the efect of gradually migrating new updates  from the young level to the largest level using only bulk reads and writes (i.e., minimizing  expensive seeks)  ""When the size of level L exceeds its limit, we compact it in a background thread. The  compaction picks a fle from level L and all overlapping fles from the next level L+1. Note  that if a level-L fle overlaps only part of a level-(L+1) fle, the entire fle at level-(L+1)  is used as an input to the compaction and will be discarded after the compaction. Aside:  because level-0 is special (fles in it may overlap each other), we treat compactions from  level-0 to level-1 specially: a level-0 compaction may pick more than one level-0 fle in case  some of these fles overlap each other.
""A compaction merges the contents of the picked fles to produce a sequence of level-(L+1)  fles. We switch to producing a new level-(L+1) fle after the current output fle has reached  the target fle size (2MB). We also switch to a new output fle when the key range of the  current output fle has grown enough to overlap more then ten level-(L+2) fles. This last  rule ensures that a later compaction of a level-(L+1) fle will not pick up too much data  from level-(L+2).
""Compactions for a particular level rotate through the key space. In more detail, for each  level L, we remember the ending key of the last compaction at level L. The next compaction  for level L will pick the frst fle that starts after this key (wrapping around to the beginning  of the key space if there is no such fle).
7
""Level-0 compactions will read up to four 1MB fles from level-0, and at worst all the level-1  fles (10MB). I.e., we will read 14MB and write 14MB.
""Other than the special level-0 compactions, we will pick one 2MB fle from level L. In  the worst case, this will overlap ~ 12 fles from level L+1 (10 because level-(L+1) is ten  times the size of level-L, and another two at the boundaries since the fle ranges at level-L  will usually not be aligned with the fle ranges at level-L+1). The compaction will therefore  read 26MB and write 26MB. Assuming a disk IO rate of 100MB/s (ballpark range for mod-  ern drives), the worst compaction cost will be approximately 0.5 second.
""If we throttle the background writing to something small, say 10% of the full 100MB/s  speed, a compaction may take up to 5 seconds. If the user is writing at 10MB/s, we might  build up lots of level-0 fles (~50 to hold the 5*10MB). This may signfcantly increase the  cost of reads due to the overhead of merging more fles together on every read.
Then there is some discussion on possible solutions to this problem.
",,Other system architectural solutions,8:1195 - 9:1096,1,arjan
13:222,kingryan,CASSANDRA-1608,kingryan,,Comment,9:1101 - 9:1108,1,arjan
13:67,"Its important to remember that LevelDB is key/value, not a column fami…",CASSANDRA-1608,"Its important to remember that LevelDB is key/value, not a column family data  model, so there are concerns and constraints that apply to cassandra which do not apply to  LevelDB.
",,Contextual constraints,9:1111 - 9:1291,1,arjan
13:223,jbellis,CASSANDRA-1608,jbellis,,Comment,9:1296 - 9:1302,1,arjan
13:68,Sure. But while bitcask (for instance) takes advantage of that to do t…,CASSANDRA-1608,"Sure. But while bitcask (for instance) takes advantage of that to do things we can’t,  I don’t see anything in here like that.
",,Architectural solution benefits and drawbacks,9:1305 - 9:1432,1,arjan
13:224,kingryan,CASSANDRA-1608,kingryan,,Comment,9:1437 - 9:1444,1,arjan
13:69,I only read the LevelDB stuf briefy. I think there’s a lot we can lear…,CASSANDRA-1608,"I only read the LevelDB stuf briefy. I think there’s a lot we can learn, but  there’s at least 2 challenges:  1) client supplied timestamps mean that you can’t know that newer fles supercede older  ones  2) the CF data model means that data for a given key in multiple sstables may need to be  merged",,Motivation of design issue,9:1447 - 9:1746,1,arjan
13:225,jbellis,CASSANDRA-1608,jbellis,,Comment,9:1753 - 9:1759,1,arjan
13:70,"Right, but I see that as an orthogonal concern. (CASSANDRA-2498 will p…",CASSANDRA-1608,"Right, but I see that as an orthogonal concern. (CASSANDRA-2498 will provide similar  benefts to reads as being able to sort by timestamp, but again, that’s basically independent  of compaction strategy.)",,Architectural solution benefits and drawbacks,9:1857 - 9:2060,1,arjan
13:71,Also right. I don’t think changing that (or changing that you may have…,CASSANDRA-1608,"Also right. I don’t think changing that (or changing that you may have to merge data  from multiple sstables on reads) should be a goal for us.
",,"Architectural solution benefits and drawbacks
Assumptions",9:2161 - 9:2305,2,arjan
13:72,"I guess I wasn’t clear; I’m not proposing ""let’s try to make Cassandra…",CASSANDRA-1608,"I guess I wasn’t clear; I’m not proposing ""let’s try to make Cassandra ft in the leveldb  design.""  Compaction is about ""how do we avoid rewriting the same data over and over, while minimiz-  ing the space penalty from not doing overwrites"" and the leveldb approach almost certainly  does better on both of those metrics than our current approach, specfcally because of the  non-overlapping-sstables-within-a-Level approach. That’s the interesting part to me.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",9:2306 - 9:2766,2,arjan
13:226,bcoverston,CASSANDRA-1608,bcoverston,,Comment,9:2771 - 9:2780,1,arjan
13:73,I like the LevelDB approach in almost every way except that recovery b…,CASSANDRA-1608,I like the LevelDB approach in almost every way except that recovery becomes  more complicated than our current scenario.,,Architectural solution benefits and drawbacks,9:2783 - 9:2903,1,arjan
13:74,Right now we can basically ship fles from one  server to another witho…,CASSANDRA-1608,"Right now we can basically ship fles from one  server to another without any special consideration, the reliance on a manifest requires us  8
to solve a new problem in the case where a manifest is lost, or we want to recover from a  snapshot.
",,Existing system architecture description,9:2905 - 10:102,1,arjan
13:227,jbellis,CASSANDRA-1608,jbellis,,Comment,10:107 - 10:113,1,arjan
13:75,I don’t see anything preventing us from recording that information on…,CASSANDRA-1608," I don’t see anything preventing us from recording that information on a per-sstable  basis, the way we do fush point information now (CASSANDRA-2419).
",,"Architectural design configuration
Architectural solution benefits and drawbacks",10:115 - 10:267,2,arjan
13:228,bcoverston,CASSANDRA-1608,bcoverston,,Comment,10:272 - 10:281,1,arjan
13:76,There’s probably nothing that prevents us from doing that.,CASSANDRA-1608,There’s probably nothing that prevents us from doing that.,,"Architectural solution benefits and drawbacks
Assumptions",10:284 - 10:341,2,arjan
13:77,Is our goal here  to replace compaction entirely?,CASSANDRA-1608,"Is our goal here  to replace compaction entirely?
",,,10:343 - 10:393,1,arjan
13:78,"The manifest information consists, minimally of the level information…",CASSANDRA-1608,"The manifest information consists, minimally of the level information and ranges. For us  ranges are easy as they are readily available when the SSTables are read in at restart, fush-  ing, or compaction.
",,Architectural solution benefits and drawbacks,10:394 - 10:599,1,arjan
13:79,"Taking a stab at this I made the compaction manager abstract, then cre…",CASSANDRA-1608,"Taking a stab at this I made the compaction manager abstract, then created a concrete  implementation for the current compaction implementation.",,Architectural design configuration,10:600 - 10:743,1,arjan
13:80,Happily hacking on a level  based compaction manager I kept running in…,CASSANDRA-1608,Happily hacking on a level  based compaction manager I kept running into a delemma: Where do I store the level infor-  mation. ,,Motivation of design issue,10:745 - 10:871,1,arjan
13:81,"1. The descriptor A hack, simple, but also adds information that proba…",CASSANDRA-1608,"1. The descriptor A hack, simple, but also adds information that probably wouldn’t be  used by any other compaction manager, yet it would be there. Unless we’re moving head-  long into a level-db approach I’m not super excited about this.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",10:898 - 10:1137,2,arjan
13:82,2. Store it on a per-sstable basis -in- the sstable: To continue along…,CASSANDRA-1608,"2. Store it on a per-sstable basis -in- the sstable: To continue along this path I would  like to have a standard place to put ""extra"" metadata in the sstables. A header of some sort.
I like the idea of using a metadata block in the SSTables to store this type of information.
",,Architectural design configuration,10:1138 - 10:1416,1,arjan
13:83,3. Use an on-disk manifest. -- Pro: only my compaction manager needs t…,CASSANDRA-1608,"3. Use an on-disk manifest. -- Pro: only my compaction manager needs to deal with  this information, but there is a non-trivial amount of bookeeping that would need to be  done to ensure this is kept up to day and valid.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",10:1417 - 10:1638,2,arjan
13:84,"4. This is probably the best option, create a new component type: META…",CASSANDRA-1608,"4. This is probably the best option, create a new component type: METADATA_STORE  which will hold namespaced key/value pairs on a per-sstable basis.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",10:1646 - 10:1795,2,arjan
13:229,jbellis,CASSANDRA-1608,jbellis,,Comment,10:1800 - 10:1806,1,arjan
13:85,"We’ve been sticking metadata into the statistics component, fwiw. It’s…",CASSANDRA-1608,"We’ve been sticking metadata into the statistics component, fwiw. It’s easier to leave the  flename the same, but it’s defnitely not just statistics anymore.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",10:1961 - 10:2119,2,arjan
13:230,bcoverston,CASSANDRA-1608,bcoverston,,Comment,10:2124 - 10:2133,1,arjan
13:86,Adding a patch for leveldb style compaction. I see this as a ’good sta…,CASSANDRA-1608,Adding a patch for leveldb style compaction. I see this as a ’good start’ and  I’m looking for some further input. ,,Architectural solution benefits and drawbacks,10:2136 - 10:2250,1,arjan
13:87,This implementation requires no durable manifest. Ranges are created a…,CASSANDRA-1608,"This implementation requires no durable manifest.
Ranges are created at SSTable creation (fush or compaction) or sstable index creation.
Exponent used for levels is 10.
Preliminary runs show that high write rates do make level 0 to level 1 promotions back  up substantially, but when cleared promotions out of level one seem to be very fast.
9
I found the best performance by removing the compaction throughput throttling and setting  concurrent compactors to 1.
The SSTable size in this implementation is determined by the fush size in mb setting.
The recovery path reads the list of SSTables, groups them by non-overlapping ranges then  places each range in its appropriate level.
Finally credit is due to the leveldb team as this design was inspired by the leveldb im-  plementation.
",,Architectural design configuration,10:2384 - 11:447,1,arjan
13:231,jbellis,CASSANDRA-1608,jbellis,,Comment,11:452 - 11:458,1,arjan
13:88,"Thanks, Ben. This is promising!",CASSANDRA-1608,"Thanks, Ben. This is promising!
",,Architectural solution benefits and drawbacks,11:461 - 11:493,1,arjan
13:89,"I pretty much concententrated on the Manifest, which I moved to a top-…",CASSANDRA-1608,"I pretty much concententrated on the Manifest, which I moved to a top-level class",,Architectural design configuration,11:494 - 11:574,1,arjan
13:90,Can  you summarize what is diferent in LDBCompactionTask?,CASSANDRA-1608,Can  you summarize what is diferent in LDBCompactionTask?,,,11:578 - 11:634,1,arjan
13:91,I don’t think trying to build levels out of non-leveled data is useful…,CASSANDRA-1608,I don’t think trying to build levels out of non-leveled data is useful. Even if you tried  all permutations the odds of ending up with something useful are infnitesmally small,,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",11:638 - 11:812,3,arjan
13:92,"I’d  suggest adding a startup hook instead to CompactionStrategy, and…",CASSANDRA-1608,"I’d  suggest adding a startup hook instead to CompactionStrategy, and if we start up w/ un-  leveled SSTables we level them before doing anything else. (This will take a while, but not  as long as leveling everything naively would, since we can just do a single compaction-of-  everything, spitting out non-overlapping sstables of the desired size, and set those to the  appropriate level.)",,"Architectural design configuration
Architectural solution benefits and drawbacks",11:815 - 11:1204,2,arjan
13:93,Updated DataTracker to add streamed sstables to level 0.,CASSANDRA-1608,Updated DataTracker to add streamed sstables to level 0.,,Architectural component behavior and structure,11:1207 - 11:1262,1,arjan
13:94,DataTracker public API probably  needs a more thorough look though to…,CASSANDRA-1608,DataTracker public API probably  needs a more thorough look though to see if we’re missing anything.,,Motivation of design issue,11:1264 - 11:1363,1,arjan
13:95,"Speaking of streaming,  I think we do need to go by data size not ssta…",CASSANDRA-1608,"Speaking of streaming,  I think we do need to go by data size not sstable count b/c streamed sstables from repair  can be arbitrarily large or small",,"Assumptions
Motivation of design issue",11:1366 - 11:1513,2,arjan
13:96,"In promote, do we need to check for all the removed ones being on the…",CASSANDRA-1608,"In promote, do we need to check for all the removed ones being on the same level? I  can’t think of a scenario where we’re not merging from multiple levels. If so I’d change that  to an assert. (In fact there should be exactly two levels involved, right?)",,"Architectural design configuration
Assumptions",11:1518 - 11:1772,2,arjan
13:97,Did some surgery on getCompactionCandidates. Generally renamed things…,CASSANDRA-1608,"Did some surgery on getCompactionCandidates. Generally renamed things to be more suc-  cinct. Feels like we getCompactionCandidates should do lower levels before doing higher  levels?
",,,11:1775 - 11:1959,1,arjan
13:98,We’ll also need to think about which parts of the strategy/manifest ne…,CASSANDRA-1608,We’ll also need to think about which parts of the strategy/manifest need to be thread-  safe. ,,Motivation of design issue,11:1960 - 11:2053,1,arjan
13:232,bcoverston,CASSANDRA-1608,bcoverston,,Comment,11:2120 - 11:2129,1,arjan
13:99,The LDBCompaction task was changed to limit the size of the SSTables t…,CASSANDRA-1608," The LDBCompaction task was changed to limit the size of the SSTables that  are output by the compaction itself. Once the size of rows compacted exceeds the size of the  default size in MB then it creates a new SSTable:  »  if(position > cfs.metadata.getMemtableThroughputInMb() * 1024 * 1024  || nni.hasNext() == false)  { «  It feels like a bit of a hack because an optimal fush size may not always be an optimal  storage size, but my goal was to try to keep the SSTable size in a reasonably small range to  10
make compactions into into level 1 fast.
",,"Architectural component behavior and structure
Trade-offs",11:2131 - 12:42,2,arjan
13:100,I’ll make some more modifcations to the manifest s.t. there is a singl…,CASSANDRA-1608,"I’ll make some more modifcations to the manifest s.t. there is a single path for getting  new SSTables (fushed and streamed) into the manifest. I found a bug on the plane today  where they were getting added to the manifest, but they weren’t being added to the queue  that I was adding fushed SSTables to. I’ll get that into my next revision.
",,Run-time quality issues,12:43 - 12:386,1,arjan
13:101,I considered this. There are some boundary cases where every SSTable t…,CASSANDRA-1608,"I considered this. There are some boundary cases where every SSTable that gets compacted  will be in the same level. Most of them have to do with L+1 being empty. Also sending the  SSTables through the same compaction path will evict expired tombstones before they end  up in the next level where compactions become increasingly unlikely.
",,Architectural design configuration,12:650 - 12:989,1,arjan
13:102,Let’s just say my naming conventions have been shaped by diferent infu…,CASSANDRA-1608,"Let’s just say my naming conventions have been shaped by diferent infuences :) I wouldn’t  object to any of the new names you chose however.
",,,12:1181 - 12:1322,1,arjan
13:103,"RE: the order, it does feel like we should do lower levels before high…",CASSANDRA-1608,"RE: the order, it does feel like we should do lower levels before higher levels, however one  thing that we have to do is make sure that level-1 stays at 10 SSTables. The algorithm  dictates that all of the level-0 candidates get compacted with all of the candidates at level-1.
This means that you need to promote out of level-1 so that it is ~10 SSTables before you  schedule a compaction for level-0 promotion.",,Architectural design configuration,12:1323 - 12:1736,1,arjan
13:104,"Right now tuning this so that it is performant  is the biggest hurdle,…",CASSANDRA-1608,"Right now tuning this so that it is performant  is the biggest hurdle, I have made some improvements by watching the CompactionExecutor,  but I have a feeling that making this work is going to require some subtle manipulation of  the way that the CompactionExecutor handles tasks.
",,Run-time quality issues,12:1738 - 12:2019,1,arjan
13:233,jbellis,CASSANDRA-1608,jbellis,,Comment,12:2024 - 12:2030,1,arjan
13:105,"Ah, totally makes sense",CASSANDRA-1608,"Ah, totally makes sense",,Architectural solution benefits and drawbacks,12:2150 - 12:2172,1,arjan
13:106,Wonder if we can refactor some more to avoid so much dupli-  cate code…,CASSANDRA-1608,"Wonder if we can refactor some more to avoid so much dupli-  cate code.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Technical debt",12:2175 - 12:2247,3,arjan
13:107,I think I fxed that by getting rid of the queue. It was basically just…,CASSANDRA-1608,"I think I fxed that by getting rid of the queue. It was basically just L0 anyway.
",,"Architectural design configuration
Assumptions",12:2520 - 12:2602,2,arjan
13:108,"I like ""Manifest.add()"" [to L0] being The Single Path, feels pretty fo…",CASSANDRA-1608,"I like ""Manifest.add()"" [to L0] being The Single Path, feels pretty foolproof to me.
",,Architectural solution benefits and drawbacks,12:2603 - 12:2688,1,arjan
13:109,Also makes sense,CASSANDRA-1608,Also makes sense,,Architectural solution benefits and drawbacks,13:1 - 13:16,1,arjan
13:110,"Well, all the overlapping ones. Which is usually going to be all of th…",CASSANDRA-1608,"Well, all the overlapping ones. Which is usually going to be all of them, but it’s easy  enough to check that we might as well on the of chance that we get to save some i/o.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Architectural tactics",13:307 - 13:481,3,arjan
13:111,I’m not sure that necessarily follows. Compacting lower levels frst me…,CASSANDRA-1608,"I’m not sure that necessarily follows. Compacting lower levels frst means less duplicate  recompaction from L+1 later. L0 is particularly important since lots of sstables in L0 means  (potentially) lots of merging by readers.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",13:624 - 13:850,2,arjan
13:112,"In any case, the comments in gCC talked about prioritizing L1 but the…",CASSANDRA-1608,"In any case, the comments in gCC talked about prioritizing L1 but the code actually prior-  itized L0 so I went with that. :)",,Other system architectural solutions,13:851 - 13:975,1,arjan
13:234,jbellis,CASSANDRA-1608,jbellis,,Comment,13:982 - 13:988,1,arjan
13:113,I checked what leveldb actually does: http://www.google.com/codesearch…,CASSANDRA-1608,"I checked what leveldb actually does: http://www.google.com/codesearch#mHLldehqYMA/trunk/db/vers  methods Finalize and PickCompaction.
What it does is compute a score for each level, as the ratio of bytes in that level to de-  sired bytes. For level 0, it computes fles / desired fles instead. (Apparently leveldb doesn’t  have row-level bloom flters, so merging on reads is extra painful.*) The level with the high-  est score is compacted.
When compacting L0 the only special casing done by leveldb is that after picking the pri-  mary L0 fle to compact, it will check other L0 fles for overlapping-ness too. ",,Other system architectural solutions,13:991 - 13:1603,1,arjan
13:114,"Again, we  can expect this to usually if not always be ""all L0 fles,""…",CASSANDRA-1608,"Again, we  can expect this to usually if not always be ""all L0 fles,"" but it’s not much more code than a  ""always compact all L0 fles"" special case would be, so why not avoid some i/o if we can.",,"Architectural design configuration
Architectural solution benefits and drawbacks",13:1605 - 13:1798,2,arjan
13:115,*I’m pretty sure that (a) we don’t need to special case for this reaso…,CASSANDRA-1608,"*I’m pretty sure that (a) we don’t need to special case for this reason and (b) we should stan-  dardize on bytes instead of fle count, the latter is too subject to inaccuracy from streamed  fles as mentioned and on later levels the fact that compaction results are not going to be  clean -- if we merge one sstable of size S from L with two of size S from L+1, odds are poor  we’ll end up with merged bytes divisible by S or even very close to it. The overwhelming  likelihood is you end up with 2 of size S and one of size 0 < size < S. Do enough of these  and using sstable count as an approximation for size gets pretty inaccurate.",,"Architectural design configuration
Architectural solution benefits and drawbacks",13:1802 - 13:2436,2,arjan
13:116,Fortunately a  method to sum SSTableReader.length() would be easy enou…,CASSANDRA-1608,Fortunately a  method to sum SSTableReader.length() would be easy enough to write instead.,,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",13:2438 - 13:2527,2,arjan
13:235,bcoverston,CASSANDRA-1608,bcoverston,,Comment,13:2534 - 13:2543,1,arjan
13:117,Attaching the latest version. Levels are scored according to size rath…,CASSANDRA-1608,"Attaching the latest version.
Levels are scored according to size rather than number of SSTables.
Performance kind of sucked until I made a few tweaks.
You can modify the LevelDB SSTable size by the following command (example) in the  CLI:  update column family Standard1 with compaction_strategy_options=[{ sstable_size_in_mb  : 10 }];  12
Using a fush size of 64MB and an sstable_size_in_mb of 5 worked pretty well for keeping  compactions moving through the levels and handling new SSTables as they entered the sys-  tem.
I also enabled concurrent compactions which, to my surprise, helped considerably. In testing  I also removed compaction throttling, but in the end I don’t think it mattered too much for  me.
This version also adds a manifest and recovery code to the mix. While running you can  cat the manifest, it’s human readable, and quite beautiful to see the levels interact with  each other as SSTables are fushed and compactions roll through the levels.",,Architectural design configuration,13:2546 - 14:630,1,arjan
13:118,"Right now I’m getting an exception on startup from the keycache, I’m g…",CASSANDRA-1608,"Right now I’m getting an exception on startup from the keycache, I’m going to investi-  gate that, but I think it may have to do with the fact that I am initializing the compaction  manager _after_ the CFS.",,Run-time quality issues,14:633 - 14:838,1,arjan
13:119,Fixed exception on startup.,CASSANDRA-1608,"Fixed exception on startup.
",,,14:857 - 14:885,1,arjan
13:236,bcoverston,CASSANDRA-1608,bcoverston,,Comment,14:890 - 14:899,1,arjan
13:120,Added range flters to reads.,CASSANDRA-1608,"Added range flters to reads.
",,Architectural component behavior and structure,14:902 - 14:931,1,arjan
13:237,bcoverston,CASSANDRA-1608,bcoverston,,Comment,14:936 - 14:945,1,arjan
13:121,Added a patch with fxed range flters.,CASSANDRA-1608,"Added a patch with fxed range flters.
",,Architectural component behavior and structure,14:948 - 14:986,1,arjan
13:122,With ~1100 sstables average latency is substantially increased (~5-10x…,CASSANDRA-1608,With ~1100 sstables average latency is substantially increased (~5-10x).,,Run-time quality issues,14:987 - 14:1058,1,arjan
13:123,I’m pretty sure  that in order to improve on this well need to impleme…,CASSANDRA-1608,I’m pretty sure  that in order to improve on this well need to implement an interval tree to get a non-linear  search time for overlapping sstables in interval queries.,,"Architectural design configuration
Architectural tactics",14:1060 - 14:1227,2,arjan
13:124,The problem here is that there aren’t any really good RBtree or even b…,CASSANDRA-1608,"The problem here is that there aren’t any really good RBtree or even binary tree imple-  mentations that I have found in the dependencies that we currently have, and I really don’t  want to muddy this ticket up with that efort.
",,Motivation of design issue,14:1230 - 14:1458,1,arjan
13:125,There are some potentially useful structures in UIMA that I can use to…,CASSANDRA-1608,"There are some potentially useful structures in UIMA that I can use to base the implemen-  tation of an interval tree of of,",,Other system architectural solutions,14:1459 - 14:1582,1,arjan
13:238,stuhood,CASSANDRA-1608,stuhood,,Comment,14:1656 - 14:1662,1,arjan
13:126,"Would ConcurrentSkipListMap work, or do you need concurrent operations…",CASSANDRA-1608,"Would ConcurrentSkipListMap work, or do you need concurrent operations on multiple  items?
",,"Assumptions
Other system architectural solutions",14:1829 - 14:1920,2,arjan
13:239,bcoverston,CASSANDRA-1608,bcoverston,,Comment,14:1925 - 14:1934,1,arjan
13:127,"It won’t because you can’t do a simple binary search for a range,",CASSANDRA-1608,"It won’t because you can’t do a simple binary search for a range,",,Architectural solution benefits and drawbacks,14:1937 - 14:2001,1,arjan
13:128,"it’s really  a problem of intersection rather than matching, and compa…",CASSANDRA-1608,"it’s really  a problem of intersection rather than matching, and comparators alone don’t solve problem  of: give me all the intersecting ranges for this set without having to compare every range for  intersection.
",,Motivation of design issue,14:2003 - 14:2217,1,arjan
13:129,Nearly every interval intersection algorithm depends on tree traversal…,CASSANDRA-1608,"Nearly every interval intersection algorithm depends on tree traversal, and while many of the  existing collections are based on binary, or red-black trees they don’t expose the methods  13
necessary for traversal, only the comparator is exposed used to build the tree and the models  only expose either ""iterate over everything"" or ""search for the thing I want"".
",,Architectural solution benefits and drawbacks,14:2218 - 15:175,1,arjan
13:240,jbellis,CASSANDRA-1608,jbellis,,Comment,15:180 - 15:186,1,arjan
13:130,Don’t the NavigableMap methods (implemented by CSLM) give you the trav…,CASSANDRA-1608,"Don’t the NavigableMap methods (implemented by CSLM) give you the traversal  api you’d need?
",,"Assumptions
Other system architectural solutions",15:189 - 15:282,2,arjan
13:241,ben.coverston@datastax.com,CASSANDRA-1608,ben.coverston@datastax.com,,Comment,15:287 - 15:312,1,arjan
13:131,"You’re right, I’m thick. I just had to go down to the node  itself, th…",CASSANDRA-1608,"You’re right, I’m thick. I just had to go down to the node  itself, theEntry object gives me the interface I need.
",,Architectural solution benefits and drawbacks,15:315 - 15:430,1,arjan
13:242,bcoverston,CASSANDRA-1608,bcoverston,,Comment,15:435 - 15:444,1,arjan
13:132,Added an interval tree to cull sstables that are not needed for point…,CASSANDRA-1608,"Added an interval tree to cull sstables that are not needed for point and range  queries.
",,Architectural design configuration,15:447 - 15:537,1,arjan
13:243,ben.coverston@datastax.com,CASSANDRA-1608,ben.coverston@datastax.com,,Comment,15:542 - 15:567,1,arjan
13:133,1. Modifed the code s.t. tombstone purge during minor compactions use…,CASSANDRA-1608,"1. Modifed the code s.t. tombstone purge during minor compactions use the interval tree  to prune the list of SSTables speeding up compactions by at least an order of magnitude  where the number of SSTables in a column family exceeds ~500.
2. Tested reads and writes. Write speeds (unsurprisingly) are not afected by this com-  paction strategy. Reads seem to keep up as well. The interval tree does a good job here  making sure that bloom flters are only queried only for those SSTables that fall into the  queried range.
3. Three successive runs of stress inserting 10M keys resulted in ~3GB of data stored in  leveldb. By comparison, the same run using the tiered (default) strategy resulted in ~8GB  of data.
The Meh:  Compactions do back up when setting the fush size to 64MB and the leveled SSTable  size to anywhere between 5-10MB. On the upside, if your load has peaks and quieter times  this compaction strategy will trigger a periodic check to ""catch up"" if all event-scheduled  compactions complete.
Interestingly this extra IO has an upside. For datasets that frequently overwrite old data  that has already been fushed to disk there is the potential for substantial de-duplication of  data. Further, during reads the number of rows that would need to be merged for a single  row is bound by the number of levels + the number of un-leveled sstables.
",,Architectural solution benefits and drawbacks,15:587 - 15:1953,1,arjan
13:134,Updated s.t. manifests are now in the data directory. rebased.,CASSANDRA-1608,"Updated s.t. manifests are now in the data directory. rebased.
",,,15:1970 - 15:2033,1,arjan
13:244,jbellis,CASSANDRA-1608,jbellis,,Comment,15:2038 - 15:2044,1,arjan
13:135,Is it even worth keeping bloom flters around with such a drastic reduc…,CASSANDRA-1608,"Is it even worth keeping bloom flters around with such a drastic reduction in worst-case  number of sstables to check (for read path too)?
",,Architectural solution benefits and drawbacks,15:2196 - 15:2335,1,arjan
13:136,Not a deal breaker for me -- it’s not hard to get old-style compaction…,CASSANDRA-1608,"Not a deal breaker for me -- it’s not hard to get old-style compactions to back up under  sustained writes, either. Given a choice between ""block writes until compactions catch up""  or ""let them back up and let the operater deal with it how he will,"" I’ll take the latter.
",,Architectural solution benefits and drawbacks,15:2364 - 15:2637,1,arjan
13:137,I’d like to have a better understanding of what the tradeof is between…,CASSANDRA-1608,"I’d like to have a better understanding of what the tradeof is between making these settings  larger/smaller. Can we make these one-size-fts-all?
",,,16:80 - 16:226,1,arjan
13:138,"Yes, this is a big win. Even people who will never fll up half their d…",CASSANDRA-1608,"Yes, this is a big win. Even people who will never fll up half their disk, complain about the  worst-case major compaction scenario for old-style compaction.
",,Architectural solution benefits and drawbacks,16:380 - 16:538,1,arjan
13:245,bcoverston,CASSANDRA-1608,bcoverston,,Comment,16:543 - 16:552,1,arjan
13:139,Exposing number of SSTables in L0 as a JMX property probably isn’t a b…,CASSANDRA-1608,"Exposing number of SSTables in L0 as a JMX property probably isn’t a bad idea.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",16:837 - 16:916,3,arjan
13:140,I think they are absolutely worth keeping around for unleveled sstable…,CASSANDRA-1608,"I think they are absolutely worth keeping around for unleveled sstables, but for leveled  sstables the value is certainly questionable.",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",16:1061 - 16:1195,3,arjan
13:141,Perhaps having some kind of LRU cache where  we have an upper bound on…,CASSANDRA-1608,"Perhaps having some kind of LRU cache where  we have an upper bound on the number of bloom flters we keep in memory would be wise.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",16:1197 - 16:1328,2,arjan
13:142,Is it possible that we could move these of-heap?,CASSANDRA-1608,"Is it possible that we could move these of-heap?
",,,16:1329 - 16:1378,1,arjan
13:143,Some pros and cons here. The biggest con is that for a 64MB fushed sst…,CASSANDRA-1608,"Some pros and cons here. The biggest con is that for a 64MB fushed sstable leveling  that fle when we choose a 25MB leveled size will require us to run a compaction on approx-  imately 314MB of data (25MB * 10 + 64MB) to get the data leveled into L1. If we choose  50MB for our leveled size the math is the same, but we end up compacting 564MB of data.
Taking into account level based scoring (to choose the next compaction candidates), these  settings become somewhat dynamic and the interplay between fush size and sstable size is  anything but subtle. A small leveled size in combination with a large fushing memtable  means that each time you merge a fushed SSTable into L1 you could end up with many  cycles of cascading compactions into L2, and potentially into L3 and higher until the scores  for L1, L2, and L3 normalize into a range that again triggers compactions from L0 to L1.
",,Architectural solution benefits and drawbacks,16:1530 - 16:2420,1,arjan
13:144,"I like the idea of having a one-size-fts-all setting for this, but wha…",CASSANDRA-1608,"I like the idea of having a one-size-fts-all setting for this, but whatever I choose I think  that compaction is going force me to revisit it.",,Architectural solution benefits and drawbacks,16:2569 - 16:2710,1,arjan
13:145,"Right now this setting is part of the schema,  and it’s a nested schem…",CASSANDRA-1608,"Right now this setting is part of the schema,  and it’s a nested schema setting at that.",,Existing system architecture description,16:2712 - 16:2799,1,arjan
13:146,"I’m leaning toward ""undocumented-setting"" right  now with a reasonable…",CASSANDRA-1608,"I’m leaning toward ""undocumented-setting"" right  now with a reasonable default.
",,Architectural design configuration,16:2801 - 16:2881,1,arjan
13:246,kingryan,CASSANDRA-1608,kingryan,,Comment,16:2886 - 16:2893,1,arjan
13:147,"I admit that I probably don’t fully understand this change, but we hav…",CASSANDRA-1608,"I admit that I probably don’t fully understand this change, but we have at least one workload  where keeping BFs would probably be necessaryâĂŞ the vast majority of the trafc on that  workload is for keys that don’t exist anywhere. Even small bumps in BF false positive rates  greatly efect the read performance.
",,Architectural solution benefits and drawbacks,17:57 - 17:370,1,arjan
13:247,bcoverston,CASSANDRA-1608,bcoverston,,Comment,17:375 - 17:384,1,arjan
13:148,Added level skipping logic.,CASSANDRA-1608,"Added level skipping logic.
",,Architectural component behavior and structure,17:387 - 17:415,1,arjan
13:149,Where should I look for that? What triggers level-skipping?,CASSANDRA-1608,"Where should I look for that? What triggers level-skipping?
",,,17:429 - 17:489,1,arjan
13:248,bcoverston,CASSANDRA-1608,bcoverston,,Comment,17:494 - 17:503,1,arjan
13:150,It’s a very simplistic trigger. You’ll fnd it in the manifest code:  i…,CASSANDRA-1608,"It’s a very simplistic trigger. You’ll fnd it in the manifest code:  in Manifest.Promote:  {quote}  int newLevel = minimumLevel == maximumLevel ? maximumLevel + 1 : maximumLevel;  newLevel = skipLevels(newLevel, added);  {quote}",,Architectural component behavior and structure,17:506 - 17:733,1,arjan
13:151,This fxes the case where you have one large SSTable and you want to mi…,CASSANDRA-1608,"This fxes the case where you have one large SSTable and you want to migrate that SSTable to  the new format. After a compaction it will fnd an empty level for the new, non-overlapping  set to fall into. Best case scenario for someone migrating a lot of data with this code would  be to do a major compaction (tiered) followed by changing the compaction strategy to leveled.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",17:736 - 17:1110,2,arjan
13:152,"Also, you should know that the synchronization code for this basically…",CASSANDRA-1608,"Also, you should know that the synchronization code for this basically disables concur-  rent compactions. I’m not sure if that’s going to be an issue.",,Architectural solution benefits and drawbacks,17:1111 - 17:1261,1,arjan
13:153,To re-enable concurrency in  a sane manner I would need to introduce q…,CASSANDRA-1608,"To re-enable concurrency in  a sane manner I would need to introduce quite a bit of complexity into the system. It’s my  hope that the work we’re doing to improve the concurrency of single compactions combined  with the shorter duration of each compaction in leveldb will make this a non-issue.
",,Architectural solution benefits and drawbacks,17:1263 - 17:1558,1,arjan
13:154,"Hmm, I didn’t see that coming. Could we allow concurrency between non-…",CASSANDRA-1608,"Hmm, I didn’t see that coming. Could we allow concurrency between non-overlapping com-  pactions? I assume that’s what makes things tricky.
",,,17:1677 - 17:1817,1,arjan
13:249,bcoverston,CASSANDRA-1608,bcoverston,,Comment,17:1822 - 17:1831,1,arjan
13:155,"TL;DR: Yes, but we would have to disable the ability of the DataTracke…",CASSANDRA-1608,"TL;DR: Yes, but we would have to disable the ability of the DataTracker to evict some  sstables from a currently scheduled compaction and instead have it remove all of them ef-  fectively canceling the scheduled compaction.
",,Architectural design configuration,17:1948 - 17:2172,1,arjan
13:156,A compaction from L0 to L1 causes every SSTable in L1 to be turned ove…,CASSANDRA-1608,"A compaction from L0 to L1 causes every SSTable in L1 to be turned over. Because of  that I can’t schedule a concurrent compaction from {L0, L1} and {L1, L2} without running  the risk of having the source SSTable in the {L1, L2} compaction from being evicted by the  data tracker.
After L1 it gets a bit easier. If I can force compactions to complete and enter a serial  mode for {L0, L1} or at least tie L0, L1, and L2 together then concurrently compacting  higher levels is a little easier and falls under a scenario of exclusion.
L2 - 1. . .10  16
L3 - 1 . . . 100",,Motivation of design issue,17:2173 - 18:16,1,arjan
13:157,We start by choosing L2.1 and fnd that it overlaps L3.1-11 so we start…,CASSANDRA-1608,"We start by choosing L2.1 and fnd that it overlaps L3.1-11 so we start a compaction with  12 SSTables. At this point --  We don’t know what the state of the levels will look like after the compaction is com-  plete, but we can guess.
If we think that after removing max_sstable_size from L2 we’ll still need more compactions  we can move on to scheduling a new compaction using L2.2, but L2.2 may still overlap one  of the sstables in L3.1-11. So we could choose a new candidate from that level until we fnd  a non-overlapping candidate for the currently compacting sstables into the next level.
",,Architectural component behavior and structure,18:19 - 18:616,1,arjan
13:250,jbellis,CASSANDRA-1608,jbellis,,Comment,18:621 - 18:627,1,arjan
13:158,"Where I was going is if we are compacting {L2.1, L3.1, L3.2, ..., L3.1…",CASSANDRA-1608,"Where I was going is if we are compacting {L2.1, L3.1, L3.2, ..., L3.11} we can  also compact {L2.9, L3.90, L3.91, ..., L3.99}, for instance. Because if the input keys are  non-overlapping, we know that the output keys will be as well. Right?
",,"Architectural component behavior and structure
Assumptions",18:630 - 18:873,2,arjan
13:251,bcoverston,CASSANDRA-1608,bcoverston,,Comment,18:878 - 18:887,1,arjan
13:159,"We know the input and output keys, yes. If we isolate the problem to c…",CASSANDRA-1608,"We know the input and output keys, yes.
If we isolate the problem to concurrent compactions in the same level, and staggered levels  {L2, L3}, {L4, L5} it is certainly an easier problem.
",,Motivation of design issue,18:890 - 18:1078,1,arjan
13:160,1608 without some of the cruft,CASSANDRA-1608,1608 without some of the cruft,,,18:1095 - 18:1124,1,arjan
13:252,alanliang,CASSANDRA-1608,alanliang,,Comment,18:1131 - 18:1139,1,arjan
13:161,There’s a problem with Interval#intersects:  1 public boolean intersec…,CASSANDRA-1608,There’s a problem with Interval#intersects:  1 public boolean intersects(Interval interval)  2 {  3 return this.contains(interval.min) || this.contains(interval.min);  4 }  I think you wanted:  1 return this.contains(interval.min) || this.contains(interval.max);,,Run-time quality issues,18:1142 - 18:1403,1,arjan
13:162,"However, a more efcient way to do this would be:  1 return this.min.co…",CASSANDRA-1608,"However, a more efcient way to do this would be:  1 return this.min.compareTo(interval.max) <= 0 && this.max.compareTo(interval.min  ) >= 0;",,"Architectural component behavior and structure
Architectural tactics",18:1406 - 18:1545,2,arjan
13:253,bcoverston,CASSANDRA-1608,bcoverston,,Comment,18:1552 - 18:1561,1,arjan
13:163,"Thanks Alan, you’re right. I’m still working on this. I appreciate tha…",CASSANDRA-1608,"Thanks Alan, you’re right. I’m still working on this. I appreciate that you’re  looking at it.
",,Architectural solution benefits and drawbacks,18:1564 - 18:1659,1,arjan
13:164,62. jeromatron: Is this going to make it into the 1.0 release? Seems l…,CASSANDRA-1608,"62. jeromatron: Is this going to make it into the 1.0 release? Seems like it’s awfully close.
63. bcoverston: It should. I’ll have an update patch today.
",,,19:6 - 19:161,1,arjan
13:165,Rebased and updated with some fxes. All tests should now pass.,CASSANDRA-1608,"Rebased and updated with some fxes. All tests should now pass.
",,,19:178 - 19:241,1,arjan
13:254,alanliang,CASSANDRA-1608,alanliang,,Comment,19:246 - 19:254,1,arjan
13:166,"From a high level, it’s looking good.",CASSANDRA-1608,"From a high level, it’s looking good.
",,Architectural solution benefits and drawbacks,19:257 - 19:295,1,arjan
13:167,"In Manifest.java, either ""public void add(SSTableReader reader)"" shoul…",CASSANDRA-1608,"In Manifest.java, either ""public void add(SSTableReader reader)"" should be should be syn-  chronized or use a NonBlockingHashMap to hold generations because multiple threads could  be calling this.
",,Run-time quality issues,19:296 - 19:494,1,arjan
13:255,bcoverston,CASSANDRA-1608,bcoverston,,Comment,19:499 - 19:508,1,arjan
13:168,added synchronization to add,CASSANDRA-1608,added synchronization to add,,Architectural component behavior and structure,19:511 - 19:538,1,arjan
13:256,jbellis,CASSANDRA-1608,jbellis,,Comment,19:545 - 19:551,1,arjan
13:169,I noticed that Manifest.generations and lastCompactedKeys could be sim…,CASSANDRA-1608,I noticed that Manifest.generations and lastCompactedKeys could be simplifed to ar-  rays if we are willing to assume that no node will have more than a PB or so of data in a  single CF. Which feels reasonable to me even with capacity expanding as fast as it is. :),,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",19:590 - 19:854,2,arjan
13:170,What is the 1.25 supposed to be doing here? 1 // skip newlevel if the…,CASSANDRA-1608,"What is the 1.25 supposed to be doing here?
1 // skip newlevel if the resulting sstables exceed newlevel threshold  2 if (maxBytesForLevel(newLevel) < SSTableReader.getTotalBytes(added)  3 && SSTableReader.getTotalBytes(getLevel(newLevel + 1)) == 0 * 1.25)",,,19:859 - 19:1115,1,arjan
13:171,"Why the ""all on the same level"" special case? Is this just saying ""L0…",CASSANDRA-1608,"Why the ""all on the same level"" special case? Is this just saying ""L0 compactions must go  into L1?""  // the level for the added sstables is the max of the removed  ones,  // plus one if the removed were all on the same level",,,19:1120 - 19:1344,1,arjan
13:172,"removed this. if L0 is large, it doesn’t necessarily follow that L1 is…",CASSANDRA-1608," removed this. if L0 is large, it doesn’t necessarily follow that L1 is large too. I don’t  see a good reason to second-guess the scoring here.
1 if (candidates.size() > 32 && bestLevel == 0)  2 {  3 candidates = getCandidatesFor(1);  4 }",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",19:1348 - 19:1586,2,arjan
13:173,redid L0 candidate selection to follow the LevelDB algorithm (pick one…,CASSANDRA-1608,"redid L0 candidate selection to follow the LevelDB algorithm (pick one L0, add other  L0s and L1s that overlap). This means that if we’re doing sequential writes we don’t do  ""extra"" work compacting non-overlapping L0s unnecessarily. (A niche use to be sure given  18
our emphasis on RP but it’s not a lot of code.)",,"Architectural component behavior and structure
Architectural tactics",19:1591 - 20:47,2,arjan
13:174,L0 only gets two sstables before it’s overcapacity? Are we still allow…,CASSANDRA-1608,L0 only gets two sstables before it’s overcapacity? Are we still allowing L0 sstables to  be large? if so it’s not even two,,,20:52 - 20:174,1,arjan
13:175,it’s not correct for the create/load code to assume that the frst data…,CASSANDRA-1608,it’s not correct for the create/load code to assume that the frst data directory stays  constant across restarts -- it should check all directories when loading,,Run-time quality issues,20:263 - 20:422,1,arjan
13:176,CFS  ===  - not immediately clear to me if the TODOs in isKeyInRemaini…,CASSANDRA-1608,"CFS  ===  - not immediately clear to me if the TODOs in isKeyInRemainingSSTables are something i  should be concerned about  - why do we need the reference mark/unmark now but not before? is this a bug fx indepen-  dent of 1608?
- are we losing a lot of cycles to markCurrentViewReferenced on the read path now that this  is 1000s of sstables instead of 10s?
DataTracker  ===========  - followed todo’s suggestion to move incrementallyBackup to another thread  - why do we use a LinkedList in buildIntervalTree when we know the size beforehand?
- suspect that it’s going to be faster to use interval tree to prune the search space for Colla-  tionController.collectTimeOrderedData, then sort that subset by timestamp. Which would  simplify DataTracker by not having to keep a list of sstables around sorted-by-timestamp --  could get rid of that entirely in favor of the tree, I think.
Compaction  ==========  - Did this code get moved somewhere else so manual compaction request against a single  sstable remains a no-op for SizeTiered?
1 if (toCompact.size() < 2)  2 {  3 logger.info(""Nothing to compact in "" + cfs.getColumnFamilyName() +  ""."" +  4 ""Use forceUserDefinedCompaction if you wish to force  compaction of single sstables "" +  5 ""(e.g. for tombstone collection)"");  6 return 0;  7 }",,,20:425 - 20:1724,1,arjan
13:257,bcoverston,CASSANDRA-1608,bcoverston,,Comment,20:1731 - 20:1740,1,arjan
13:177,"dunno what I was thinking, I was screwing around with giving the promo…",CASSANDRA-1608,"dunno what I was thinking, I was screwing around with giving the promoted range a size,  but it looks like that ended up in the wrong place.
",,Run-time quality issues,20:1806 - 20:1947,1,arjan
13:178,"Yes, also when a compaction gets triggered into an empty target level…",CASSANDRA-1608,"Yes, also when a compaction gets triggered into an empty target level the same logic applies",,Architectural component behavior and structure,21:10 - 21:101,1,arjan
13:179,Actually this was there to prevent an OOM exception when too many SSTa…,CASSANDRA-1608,"Actually this was there to prevent an OOM exception when too many SSTables were par-  ticipating in any given compaction. You are, however correct that it doesn’t follow that L1  is large, not in all cases",,Architectural solution benefits and drawbacks,21:267 - 21:471,1,arjan
13:180,I’ll revise this to give an upper bound to the list of L0 candidates…,CASSANDRA-1608,I’ll revise this to give an upper bound to the list of L0 candidates  in a given compaction.,,Architectural component behavior and structure,21:474 - 21:565,1,arjan
13:181,I was screwing around with this threshold. One of the side efects of t…,CASSANDRA-1608,"I was screwing around with this threshold. One of the side efects of the dynamic fush  thresholds was that I could end up with a substantial number of small SSTables ""stuck""  in L0.",,Motivation of design issue,21:711 - 21:891,1,arjan
13:182,One way to fx this is to always give L0 a small positive score when th…,CASSANDRA-1608,One way to fx this is to always give L0 a small positive score when there are any  SSTables in L0 so that the SSTables get cleared out with the rest of the leveling has been  done.,,Architectural component behavior and structure,21:893 - 21:1072,1,arjan
13:183,Previously I was using the memtable fush threshold as the multiplier f…,CASSANDRA-1608,"Previously I was using the memtable fush threshold as the multiplier for L0, but with  dynamic fushing and global memtable thresholds this doesn’t mean much anymore.",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",21:1074 - 21:1238,2,arjan
13:184,I’m  included to leave it and perhaps raise the multiplier for L0 from…,CASSANDRA-1608,"I’m  included to leave it and perhaps raise the multiplier for L0 from 2 to 4.
",,Architectural component behavior and structure,21:1240 - 21:1319,1,arjan
13:185,I assumed that as I was doing operations on these SSTables in the refe…,CASSANDRA-1608,"I assumed that as I was doing operations on these SSTables in the referenced views I would  also need to use these referenced.
",,Architectural component behavior and structure,21:2132 - 21:2259,1,arjan
13:186,Yes this is a potentially serious issue. This code gets called on ever…,CASSANDRA-1608,"Yes this is a potentially serious issue. This code gets called on every read. A pretty heavy  price to pay during each read.
",,Run-time quality issues,22:150 - 22:274,1,arjan
13:258,jbellis,CASSANDRA-1608,jbellis,,Comment,22:280 - 22:286,1,arjan
13:187,"Right, but isn’t that already the case pre-1608?",CASSANDRA-1608,"Right, but isn’t that already the case pre-1608?
",,,22:421 - 22:470,1,arjan
13:188,Feels like DataTracker is the wrong granularity to be doing reference…,CASSANDRA-1608,Feels like DataTracker is the wrong granularity to be doing reference counting at.,,Motivation of design issue,22:659 - 22:740,1,arjan
13:189,I’d like to  see if we can push that into SSTableReader instead,CASSANDRA-1608,I’d like to  see if we can push that into SSTableReader instead,,Architectural component behavior and structure,22:742 - 22:804,1,arjan
13:259,bcoverston,CASSANDRA-1608,bcoverston,,Comment,22:922 - 22:931,1,arjan
13:190,The latest  changes/merge seem to have caused a regression when the #…,CASSANDRA-1608,The latest  changes/merge seem to have caused a regression when the # of SSTables increases beyond  a few hundred. ,,Run-time quality issues,22:992 - 22:1106,1,arjan
13:191,Fixed up the patch according to the comments given. Took a stab a cull…,CASSANDRA-1608,"Fixed up the patch according to the comments given. Took a stab a culling  some of the SSTables from the locking mechanism.
",,,22:1298 - 22:1422,1,arjan
13:260,jbellis,CASSANDRA-1608,jbellis,,Comment,22:1427 - 22:1433,1,arjan
13:192,Switched DataTracker registration to be eager instead of lazy -- other…,CASSANDRA-1608,"Switched DataTracker registration to be eager instead of lazy -- otherwise sstables created  before any compaction happened (during log replay for instance) would not be added to the  manifest. Also added unregistration when a new Strategy is created on schema change.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",22:1468 - 22:1737,2,arjan
13:193,"moved the LevelDB classes from db.leveldb to db.compaction, so that I…",CASSANDRA-1608,"moved the LevelDB classes from db.leveldb to db.compaction, so that I could add a ""un-  qualifed compaction strategy will be looked for in oac.db.compaction"" rule",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",22:1780 - 22:1941,2,arjan
13:194,"added code to make it not attempt to compact empty L0, which caused an…",CASSANDRA-1608," added code to make it not attempt to compact empty L0, which caused an assertion error",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",22:2037 - 22:2123,2,arjan
13:261,jbellis,CASSANDRA-1608,jbellis,,Comment,22:2204 - 22:2210,1,arjan
13:195,Still getting seeing a few failures when I make Leveled the default fo…,CASSANDRA-1608,"Still getting seeing a few failures when I make Leveled the default for the test suite. Most  21
are bogus (e.g. test assuming it can request compaction of arbitrary sstables) but some are  not:  [junit] Testsuite: org.apache.cassandra.db.CleanupTest  [junit] Invalid memory access of location 0x0 rip=0x0  [junit] Test org.apache.cassandra.db.ColumnFamilyStoreTest FAILED (crashed)  [junit] Testsuite: org.apache.cassandra.db.ColumnFamilyTest  Actually, it’s quite likely that these are manifestations of the CASSANDRA-3085 problem,  which is more likely to bite us in practice now that there are many more sstables generated.
So I’ll address that frst before worrying about these.
Additional note: test suite runs about 20% slower for me w/ Leveled compactions. Un-  sure if that should be expected.
",,Run-time quality issues,22:2307 - 23:708,1,arjan
13:196,Also created CASSANDRA-3086.,CASSANDRA-1608,"Also created CASSANDRA-3086.
",,,23:722 - 23:751,1,arjan
13:262,bcoverston,CASSANDRA-1608,bcoverston,,Comment,23:756 - 23:765,1,arjan
13:197,That’s not entirely expected. It’s probably due in part to the amount…,CASSANDRA-1608,"That’s not entirely expected. It’s probably due in part to the amount of fushing that  we force during in the tests. Flushes and compactions both trigger interval tree builds.
Other than that the codepaths are the same.",,Run-time quality issues,23:890 - 23:1109,1,arjan
14:1,CQL 1.0,CASSANDRA-1703,CQL 1.0,,User requirement,3:52 - 3:58,1,arjan
14:2,CQL (Cassandra Query Language) is a proposed language for data managem…,CASSANDRA-1703,"CQL (Cassandra Query Language) is a proposed language for data management in Cassandra.
",,User requirement,3:78 - 3:166,1,arjan
14:3,This issue is meant to encapsulate the goals for CQL in the next stabl…,CASSANDRA-1703,"This issue is meant to encapsulate the goals for CQL in the next stable release (0.8), roughly:  * Completed 1.0 language specifcation.
* Implementation of the language using the Avro interface for transport and serialization.
* Low-level drivers for Java and Python (possibly others).
* The deprecation (or removal, TBD) of (Avro) RPC methods.
",,Architectural design configuration,3:167 - 3:515,1,arjan
14:4,"CQL 1.0 needn’t be entirely complete, but it should be stable. Backwar…",CASSANDRA-1703,"CQL 1.0 needn’t be entirely complete, but it should be stable. Backward incompatible changes  mean a transition to 2.0 (and I hope there is never a 2.0).",,Architectural design configuration,3:753 - 3:905,1,arjan
14:11,kingryan,CASSANDRA-1703,kingryan,,Comment,4:18 - 4:25,1,arjan
14:5,"I generally like this proposal,",CASSANDRA-1703,"I generally like this proposal,",,Architectural solution benefits and drawbacks,4:28 - 4:58,1,arjan
14:6,except I don’t think we should get rid of the rpc  methods.,CASSANDRA-1703,except I don’t think we should get rid of the rpc  methods. ,,"Architectural design configuration
Assumptions",4:60 - 4:119,2,arjan
14:7,Sometimes the performance will be worth it (assuming that the direct r…,CASSANDRA-1703,"Sometimes the performance will be worth it (assuming that the direct rpc will be  faster, which seems to be a safe assumption).
",,Architectural tactics,4:120 - 4:248,1,arjan
14:12,urandom,CASSANDRA-1703,urandom,,Comment,4:252 - 4:258,1,arjan
14:8,"Just to be clear, the RPC methods I’m referring to here are the Avro R…",CASSANDRA-1703,"Just to be clear, the RPC methods I’m referring to here are the Avro RPC methods (not  Thrift).
",,Architectural design configuration,4:358 - 4:454,1,arjan
14:9,The back-of-napkin tests I’ve done so far put CQL and Thrift on even f…,CASSANDRA-1703,"The back-of-napkin tests I’ve done so far put CQL and Thrift on even footing, and there is a  _ton_ of room for improvement on the CQL-side (ditching the HTTP transport for exam-  ple). Proper benchmarks need to be done to be sure, but I’m operating on the assumption  that greater-than or equal-to performance is possible.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",4:588 - 4:912,3,arjan
14:10,The release goals for CQL 1.0 are complete; Closing this issue.,CASSANDRA-1703,"The release goals for CQL 1.0 are complete; Closing this issue.
",,,4:925 - 4:989,1,arjan
15:4,Custom CQL protocol/transport,CASSANDRA-2478,Custom CQL protocol/transport,,Quality Attribute requirement,3:52 - 3:80,1,arjan
15:1,A custom wire protocol would give us the fexibility to optimize for ou…,CASSANDRA-2478,"A custom wire protocol would give us the fexibility to optimize for our specifc use-cases, and  eliminate a troublesome dependency (I’m referring to Thrift, but none of the others would be sig-  nifcantly better).",,Architectural solution benefits and drawbacks,3:100 - 3:312,1,arjan
15:2,"Additionally, RPC is bad ft here, and we’d do better to move in the di…",CASSANDRA-2478,"Additionally, RPC is bad ft here, and we’d do better to move in the direction  of something that natively supports streaming.",,Architectural solution benefits and drawbacks,3:314 - 3:438,1,arjan
15:3,I don’t think this is as daunting as it might seem initially. Utilizin…,CASSANDRA-2478,"I don’t think this is as daunting as it might seem initially. Utilizing an existing server frame-  work like Netty, combined with some copy-and-paste of bits from other FLOSS projects would  probably get us 80% of the way there.
",,"Architectural design configuration
Assumptions",3:441 - 3:670,2,arjan
15:126,kingryan,CASSANDRA-2478,kingryan,,Comment,3:789 - 3:796,1,arjan
15:5,"If you want to use netty, I’d suggest considering using fnagle on top…",CASSANDRA-2478," If you want to use netty, I’d suggest considering using fnagle on top of it:  http://github.com/twitter/fnagle. Its written in scala but its very easy to use from java.
",,Architectural design configuration,3:798 - 3:968,1,arjan
15:127,rbranson,CASSANDRA-2478,rbranson,,Comment,3:972 - 3:979,1,arjan
15:6,"Finagle is nice, but I think the idea is to reduce dependencies and im…",CASSANDRA-2478,"Finagle is nice, but I think the idea is to reduce dependencies and improve sup-  port for non-JVM clients.
",,"Architectural solution benefits and drawbacks
Assumptions",3:982 - 3:1089,2,arjan
15:7,Has anyone proposed anything regarding the wire protocol yet or is it…,CASSANDRA-2478,"Has anyone proposed anything regarding the wire protocol yet or is it still wide open?
",,,3:1091 - 3:1178,1,arjan
15:8,But it’s still just HTTP right?,CASSANDRA-2478,"But it’s still just HTTP right?
",,,4:1 - 4:33,1,arjan
15:128,rbranson,CASSANDRA-2478,rbranson,,Comment,4:110 - 4:117,1,arjan
15:9,"Looks like Finagle supports HTTP, Thrift, Memcached, and some protocol…",CASSANDRA-2478,"Looks like Finagle supports HTTP, Thrift, Memcached, and some protocol called  ""More to come!""",,Architectural solution benefits and drawbacks,4:120 - 4:213,1,arjan
15:129,kingryan,CASSANDRA-2478,kingryan,,Comment,4:219 - 4:226,1,arjan
15:10,Finagle is a library for building protocols that *happens* to come wit…,CASSANDRA-2478," Finagle is a library for building protocols that *happens* to come with a few  built-in implementations (http, memcached, thrift, etc). It solves a lot of problems that  you’d have to re-build on top of netty.
",,Architectural solution benefits and drawbacks,4:228 - 4:439,1,arjan
15:130,rbranson,CASSANDRA-2478,rbranson,,Comment,4:443 - 4:450,1,arjan
15:11,So I’ll start throwing ideas out there. I think we should use a simple…,CASSANDRA-2478," So I’ll start throwing ideas out there.
I think we should use a simple framed binary transport with a 4-byte frame size prefx fol-  lowed by the frame. Inside the frame is the message: a 2-byte integer indicating message  type followed by the message contents, which varies based on the type. The client sends  requests, and the server responds to them.
The Cassandra protocol needs to do the following things, which I would imagine would  equate to a pair of message types (request and response):  - Handshake  - Authentication  - Health Checks (ping/pong)  - CQL Queries (... and a response that encodes rows, columns, and supercolumns)  - CQL Statement Preparation & Execution  Anything I’m missing? It would be nice to make some more complex or problematic func-  tionality, such as compression and streaming, optional for the client.
",,"Architectural design configuration
Assumptions",4:452 - 4:1294,2,arjan
15:131,tux21b,CASSANDRA-2478,tux21b,,Comment,4:1298 - 4:1303,1,arjan
15:12,I would really appreciate a such a custom protocol since I would like…,CASSANDRA-2478,"I would really appreciate a such a custom protocol since I would like to write a Go  client.
",,Architectural solution benefits and drawbacks,4:1306 - 4:1399,1,arjan
15:13,Go seems to be a bad ft for Thrift since the language and API is impro…,CASSANDRA-2478,"Go seems to be a bad ft for Thrift since the language and API is improving steadily (which  isn’t a problem for Go programs, since there is a tool called ""gofx"" which is able to rewrite  existing code), but updating the code-generator for Thrift all the time is not practical. Also,  I do not want to contribute to Thrift at the moment and writing a generator to generate  non-idiomatic code instead of writing a nice API in the frst place (without huge amounts of  duplicated generated code) seems like the better solution for me (but that’s just my personal  preference).
",,Architectural solution benefits and drawbacks,4:1400 - 4:1974,1,arjan
15:14,"I know, this feature was just proposed recently, but is it likely that…",CASSANDRA-2478,"I know, this feature was just proposed recently, but is it likely that it might be implemented  in the near future?
8. rbranson: I believe the focus is on getting CQL up to 100% parity functionality-wise with  Thrift, and then there will be time to work on this. Once CQL becomes the default, it’ll  be transparent to switch out the ’innards’ with a custom protocol. An extremely optimistic  fgure puts this 6 months out.
",,,4:1975 - 4:2398,1,arjan
15:132,pkolaczk,CASSANDRA-2478,pkolaczk,,Comment,4:2402 - 4:2409,1,arjan
15:16,Have you considered Hessian? Or taking some parts of it - because it i…,CASSANDRA-2478,"Have you considered Hessian? Or taking some parts of it - because it is open-  source and quite simple. We used it as the main platform for webservices at our company  (mostly doing MMORPG games). It is very lightweight, it supports streaming, it supports  many programming languages, it would be possible to run using Jetty or Netty (we used  Jetty). However, it doesn’t support versioning, so it would have to be improved.
http://hessian.caucho.com/",,Other system architectural solutions,4:2412 - 4:2863,1,arjan
15:17,because it is open-  source and quite simple.,CASSANDRA-2478,because it is open-  source and quite simple. ,,Architectural solution benefits and drawbacks,4:2470 - 4:2515,1,arjan
15:18,"It is very lightweight, it supports streaming, it supports  many progr…",CASSANDRA-2478,"It is very lightweight, it supports streaming, it supports  many programming languages, it would be possible to run using Jetty or Netty (we used  Jetty). However, it doesn’t support versioning, so it would have to be improved.
",,Architectural solution benefits and drawbacks,4:2609 - 4:2836,1,arjan
15:133,jbellis,CASSANDRA-2478,jbellis,,Comment,5:5 - 5:11,1,arjan
15:19,"The end is in sight (CASSANDRA-2474 is almost done, with CASSANDRA-247…",CASSANDRA-2478,"The end is in sight (CASSANDRA-2474 is almost done, with CASSANDRA-2477 to fol-  low soon), so I agree that it’s time to start thinking harder about this.",,,5:153 - 5:306,1,arjan
15:20,Are there any serious contenders besides HTTP and a simple custom prot…,CASSANDRA-2478,Are there any serious contenders besides HTTP and a simple custom protocol similar to  the one outlined by Rick?,,,5:309 - 5:420,1,arjan
15:21,Hessian looks a lot more like Thrift than like something we’d use  her…,CASSANDRA-2478,"Hessian looks a lot more like Thrift than like something we’d use  here.
",,Architectural solution benefits and drawbacks,5:422 - 5:494,1,arjan
15:134,slebresne,CASSANDRA-2478,slebresne,,Comment,5:500 - 5:508,1,arjan
15:22,but between those two I would have a slight preference  for a custom p…,CASSANDRA-2478,"but between those two I would have a slight preference  for a custom protocol. My (to be honest not so extensive) experience with HTTP is that  it can be slowish and a tad annoying to work with when you use it for something it wasn’t  designed for (typically streaming is not a given). But a custom protocol will clearly be more  work for us. I just have a feeling that it may be worth it in the end.
",,Trade-offs,5:671 - 5:1071,1,arjan
15:23,"And whether it is HTTP or custom, I’ve had good experience with Netty…",CASSANDRA-2478,"And whether it is HTTP or custom, I’ve had good experience with Netty in the past too.
",,Architectural solution benefits and drawbacks,5:1073 - 5:1160,1,arjan
15:135,urandom,CASSANDRA-2478,urandom,,Comment,5:1165 - 5:1171,1,arjan
15:24,+1,CASSANDRA-2478,+1,,Architectural solution benefits and drawbacks,5:1722 - 5:1723,1,arjan
15:25,"If you go with netty I may be able to help (I’m one of the netty ""comm…",CASSANDRA-2478,"If you go with netty I may be able to help (I’m one of the netty ""committers/devs"")  with writting the code for it. Let me know if you are interested..
",,,5:1738 - 5:1890,1,arjan
15:26,Related? HBASE-5355,CASSANDRA-2478,Related? HBASE-5355,,,5:1904 - 5:1922,1,arjan
15:136,liqusha,CASSANDRA-2478,liqusha,,Comment,5:1929 - 5:1935,1,arjan
15:27,+1 for netty,CASSANDRA-2478,+1 for netty,,Architectural solution benefits and drawbacks,5:1938 - 5:1949,1,arjan
15:137,slebresne,CASSANDRA-2478,slebresne,,Comment,5:1956 - 5:1964,1,arjan
15:28,Attaching cql_binary_protocol as a draft for such a custom binary prot…,CASSANDRA-2478," Attaching cql_binary_protocol as a draft for such a custom binary protocol  (CQL3 only). The protocol follows more or less Rick’s outline above. It is frame based, each  frame has a small header indicating amongst other the opcode for the message that defnes  what the body of said message must contain.
A typical communication start by a small handshake/authentication phase, after which  queries (and preparation/execution) can be performed. The protocol support a form of  ’cursor’ api for queries. Given a select query, the client can ask the server to return only a  handful of rows frst, and then the client can fetch more rows at his own rate using a NEXT  message.
Outside of the cursor thing, the protocol as described here pretty much expose the same  things than the thrift transport (as far as CQL is concerned) but not much more (a small  exception is that CASSANDRA-3707 is included). I plan on experimenting next with a few  additional features, like allowing clients to register to events like ’a new node joined’ and be  4
notifed when such event happen, but I’ll leave that to follow up tickets.
I’ve push at https://github.com/pcmanus/cassandra/commits/2478 an initial implementa-  tion of this protocol (using netty). Almost all of the protocol is implemented except for the  NEXT message, but I’ll get to that. There is currently mainly 4 patches:  * the frst one is the bulk of the new server  * the second one is a simple client, along with a small ""debug"" console (whose code is ugly),  that allow to send message to test the server. This does not necessarily have to make it in  the fnal commit, but it is useful for testing.
* the third one replace the use of CqlResult in the CQL3 code to directly build the new  messages. And for the thrift interface, it simply translate those message to CqlResult. I’ve  done it that way (instead of generating CqlResult and convert that to messages of the na-  tive protocol) because I think that is the direction we want to go. However currently that  means that there is a few info that don’t make it anymore in the CqlResult, namely the  timestamp of the columns. Anywa, imo CASSANDRA-4217 is a much better way to access  the timestamp and I’m not sure existing client were exposing the timestamp, but if there is  complaints, that can be fxe is a much better way to access the timestamp and I’m not sure  existing client were exposing the timestamp, but if there is complaints, that can be fxed.
* the last one changes our CassandraDaemon business so that we can run a server with both  the thrift and native protocol server running cleanly.
",,Architectural design configuration,5:1966 - 6:1574,1,arjan
15:29,I think that is the direction we want to go,CASSANDRA-2478,I think that is the direction we want to go,,"Architectural solution benefits and drawbacks
Assumptions",6:911 - 6:953,2,arjan
15:30,However currently that  means that there is a few info that don’t make…,CASSANDRA-2478,"However currently that  means that there is a few info that don’t make it anymore in the CqlResult, namely the  timestamp of the columns",,Architectural solution benefits and drawbacks,6:956 - 6:1091,1,arjan
15:31,"Anywa, imo CASSANDRA-4217 is a much better way to access  the timestam…",CASSANDRA-2478,"Anywa, imo CASSANDRA-4217 is a much better way to access  the timestamp and I’m not sure existing client were exposing the timestamp, but if there is  complaints, that can be fxe is a much better way to access the timestamp and I’m not sure  existing client were exposing the timestamp, but if there is complaints, that can be fxed.
",,Architectural solution benefits and drawbacks,6:1094 - 6:1426,1,arjan
15:32,"Other than that, I have really benchmarked this (but that should be do…",CASSANDRA-2478,"Other than that, I have really benchmarked this (but that should be done). I meant to  update stress to use the new server but realized that stress doesn’t work for CQL3 at all, so  that will be a separate ticket probably.
",,,6:1575 - 6:1798,1,arjan
15:33,[~slebresne] I added some comments to your code.. Hope it helps.,CASSANDRA-2478," [~slebresne] I added some comments to your code.. Hope it helps.
",,,6:1810 - 6:1875,1,arjan
15:34,"Thanks Norman, it does. I’ve pushed a new patch to the branch with mod…",CASSANDRA-2478,"Thanks Norman, it does. I’ve pushed a new patch to the branch with modifca-  tion from your comment and one of Yuki.
",,,6:1892 - 6:2009,2,arjan
15:138,yukim,CASSANDRA-2478,yukim,,Comment,6:2014 - 6:2018,1,arjan
15:35,Support for secure connection(SSL support) - we can implement this lat…,CASSANDRA-2478,"Support for secure connection(SSL support) - we can implement this later, but I think  it is better to mention in protocol. ",,"Assumptions
Quality Attribute requirement",6:2065 - 6:2188,2,arjan
15:36,READY messages body - We may want to reserve some space for server res…,CASSANDRA-2478,"READY messages body - We may want to reserve some space for server response (possibly,  server capabilities), using [option list]",,Architectural component behavior and structure,6:2326 - 6:2454,1,arjan
15:37,"Types in metadata - proposal states it is sent in <string> format, but…",CASSANDRA-2478,"Types in metadata - proposal states it is sent in <string> format, but is it better to use  fags? When custom type is used, we can append FQCN of that type after the fag.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",6:2459 - 6:2630,3,arjan
15:139,slebresne,CASSANDRA-2478,slebresne,,Comment,6:2635 - 6:2643,1,arjan
15:38,"Yes, I completely forgot about that. I meant to mention it. I indeed t…",CASSANDRA-2478,"Yes, I completely forgot about that. I meant to mention it. I indeed think we can do  that in a follow up ticket, through that won’t be too hard (we don’t plan on supporting  StartTLS right?). Anyway, to some extend it’s not really part of the protocol. It’s more  that we can embed the protocol inside SSL. But clearly, that’s planned.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",6:2694 - 6:3031,2,arjan
15:39,I’ve tried to not add stufs where I did not know if that would be usef…,CASSANDRA-2478,"I’ve tried to not add stufs where I did not know if that would be useful or not, other-  wise you never stop. I mean, things like that can be easily added later when they become  useful (and *we* decide when version 1 of the protocol is fnal so we don’t have to have  fgure everything out as soon as this get committed).
",,Architectural solution benefits and drawbacks,6:3113 - 6:3434,1,arjan
15:40,"Why not. I’m not sure we’ll have a huge saving, and I wonder if tying…",CASSANDRA-2478,"Why not. I’m not sure we’ll have a huge saving, and I wonder if tying the supported  native type to the protocol is a good idea. Though as long as we a way to have custom types  we’re good so why not. I’ll update.
",,Architectural solution benefits and drawbacks,7:176 - 7:390,1,arjan
15:140,jbellis,CASSANDRA-2478,jbellis,,Comment,7:395 - 7:401,1,arjan
15:41,Is it worth taking a look at something like the libpq protocol to see…,CASSANDRA-2478,Is it worth taking a look at something like the libpq protocol to see if we’re missing  anything obvious? http://www.postgresql.org/docs/9.2/static/protocol.html,,"Assumptions
Other system architectural solutions",7:404 - 7:564,2,arjan
15:141,slebresne,CASSANDRA-2478,slebresne,,Comment,7:571 - 7:579,1,arjan
15:42,I did look at that as main inspiration :)  But I’ll have a fnal go ove…,CASSANDRA-2478,"I did look at that as main inspiration :)  But I’ll have a fnal go over to make sure I didn’t forget something.
",,"Architectural solution benefits and drawbacks
Other system architectural solutions",7:582 - 7:694,2,arjan
15:142,shsedghi,CASSANDRA-2478,shsedghi,,Comment,7:699 - 7:706,1,arjan
15:43,"Please look at Websocket for the wire protocol, it is way faster than…",CASSANDRA-2478,"Please look at Websocket for the wire protocol, it is way faster than HTTP and  also HTTP friendly",,"Architectural solution benefits and drawbacks
Architectural tactics
Other system architectural solutions",7:709 - 7:806,3,arjan
15:143,ardot,CASSANDRA-2478,ardot,,Comment,7:813 - 7:817,1,arjan
15:44,Please consider returning the KS (schema) and CF (table) in the metada…,CASSANDRA-2478,"Please consider returning the KS (schema) and CF (table) in the metadata returned  with ""rows"" and a ""prepare"". This will facilitate clients reporting this information in metadata  commands from the client side for tools and the like. This information can not really be  known without the fragile method of scanning the CQL because the context is always passed  withing the script itself. And with the addition of ""KS.CF"" notation in CQL for the selected  CF you can’t really use the state of a USE to tell what the applicable KS is within the  currently returned information.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",7:820 - 7:1397,2,arjan
15:144,jbellis,CASSANDRA-2478,jbellis,,Comment,7:1402 - 7:1408,1,arjan
15:45,"How does this matter? As far as JDBC/SQL is concerned, a resultset can…",CASSANDRA-2478,"How does this matter? As far as JDBC/SQL is concerned, a resultset can be from  many tables or even none. Granted, CQL is more limited, but just because we *can* expose  something doesn’t mean we *should*. ISTM if we report what the column names and types  are, that should be all the driver needs to care about.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",7:1411 - 7:1724,2,arjan
15:145,urandom,CASSANDRA-2478,urandom,,Comment,7:1729 - 7:1735,1,arjan
15:46,"I haven’t had a chance to do much more than skim through the code, but…",CASSANDRA-2478," I haven’t had a chance to do much more than skim through the code, but it  looks great so far; Nice work",,Architectural solution benefits and drawbacks,7:1737 - 7:1841,1,arjan
15:47,"One suggestion I’d like to throw out there though, is that we use this…",CASSANDRA-2478,"One suggestion I’d like to throw out there though, is that we use this as an opportunity  to get rid of our custom authentication/authorization, and add hooks for SASL instead.
This isn’t a wheel we should have reinvented ourselves, and SASL would provide a simple  means of integrating with a lot of diferent systems.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",7:1844 - 7:2164,2,arjan
15:146,ardot,CASSANDRA-2478,ardot,,Comment,7:2169 - 7:2173,1,arjan
15:48,"re: KS/CF metadata. As you say, JDBC/SQL can have resultset informatio…",CASSANDRA-2478,"re: KS/CF metadata. As you say, JDBC/SQL can have resultset information from  many tables, which is why you can acquire that metadata information at the column level.
The {{ResultSetMetaData}} interface provides methods for {{getSchemaName(column)}}  and {{getTableName(column)}} on a column-by-column basis. The point is tools use these  interfaces and methods heavily to deliver their functionality and we will improve adoption  of the Server and the Driver if we can make the interface process for these tools deliver as  much information as practical.
",,Architectural design configuration,7:2176 - 7:2733,1,arjan
15:147,slebresne,CASSANDRA-2478,slebresne,,Comment,7:2738 - 7:2746,1,arjan
15:49,Which begs the question: do we want to also allow per-column keyspace/…,CASSANDRA-2478,Which begs the question: do we want to also allow per-column keyspace/table names?,,,7:2883 - 7:2964,1,arjan
15:50,"As  of C* current state this is not needed, one can only query one at…",CASSANDRA-2478,"As  of C* current state this is not needed, one can only query one at a time. But wiring that in  the protocol could be limiting in the future",,Architectural solution benefits and drawbacks,7:2966 - 7:3107,1,arjan
15:51,"On the other side, it will more simple/compact  to only allow 1 keyspa…",CASSANDRA-2478,"On the other side, it will more simple/compact  to only allow 1 keyspace/table name and adding query on multiple table, if we ever do it,  won’t be a small addition, so maybe we’re fne with having it trigger a bump in the protocol  version when that happen.
",,Architectural solution benefits and drawbacks,7:3110 - 7:3368,1,arjan
15:52,I suppose we could support both version through a simple fag that say…,CASSANDRA-2478,"I suppose we could support both version through a simple fag that say whether there is  6
just one keyspace/table pair or one per column, but that complicates the protocol for some-  thing that may well never be useful.",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",7:3369 - 8:129,2,arjan
15:53,I’m not against that in theory. But I’ll admit not knowing all the nut…,CASSANDRA-2478,"I’m not against that in theory. But I’ll admit not knowing all the nuts and bolts of SASL.
From an initial read, it seems the protocol part is fairly simple, it’s a just a couple of simple  message carrying string to support. However what’s less clear to me is how to wire that  in the Cassandra side and in particular how to ensure some form of compatibility with our  current IAuthenticator interface.
",,Architectural solution benefits and drawbacks,8:261 - 8:666,1,arjan
15:148,ardot,CASSANDRA-2478,ardot,,Comment,8:671 - 8:675,1,arjan
15:54,My personal opinion is we will never get to a point where we need mult…,CASSANDRA-2478,"My personal opinion is we will never get to a point where we need multiple KSs. But  Multiple CFs (Tables) yes. The point is now in the current state of the returned meta-data  we do not know _which_ KS or CF, even if there is only one, and I contend we have client  calls that want to know that info. ""bikesheding"" on my part will now end. :)",,"Architectural design configuration
Architectural solution benefits and drawbacks",8:678 - 8:1020,2,arjan
15:55,Rick: do you have specifc tools which would beneft from that metadata?,CASSANDRA-2478,"Rick: do you have specifc tools which would beneft from that metadata?
",,,8:1039 - 8:1110,1,arjan
15:149,ardot,CASSANDRA-2478,ardot,,Comment,8:1115 - 8:1119,1,arjan
15:56,Much of the pressure in the corporate world I live in is from teams th…,CASSANDRA-2478,"Much of the pressure in the corporate world I live in is from teams that are trying to  use JDBC driver for C* in the same fashion and with the same BI, ETL and statistics tools  (Talend, Informatica, Datastage, SPSS, SAS) as they do for relational solutions. Many of  these tools are quite comprehensive in the information they can display and use, so they are  heavy users of the metadata features of the driver. Returning no data for some functions  often causes the tooling to just give up, not to use what they have.
",,Architectural solution benefits and drawbacks,8:1122 - 8:1644,1,arjan
15:150,slebresne,CASSANDRA-2478,slebresne,,Comment,8:1649 - 8:1657,1,arjan
15:57,I’ve pushed at https://github.com/pcmanus/cassandra/commits/2478-2 an…,CASSANDRA-2478,"I’ve pushed at https://github.com/pcmanus/cassandra/commits/2478-2 an up-  dated version of this patch. I’m also attaching the v2 document describing this new version.
",,,8:1660 - 8:1828,1,arjan
15:58,This version adds to the previous one:  * keyspace and table names to…,CASSANDRA-2478,"This version adds to the previous one:  * keyspace and table names to the metadata returned as response to SELECT and prepared  queries. The protocol supports having diferent ks/cf names for each column, but have a  more compact form when all columns are from the same ks/cf (which is always the case for  SELECT, but not for prepared queries).
* it removes (mostly from the document) the few tidbits about the sketched auto-paging. I  turns out this is more complicated than I though and may require a bit more discussion. So  I prefer living that to a follow up ticket.
* a few other cleanups  In this form, this is a ""complete"" frst version in that it is on par with the thrift API.
So imo it’s a good frst step and I’d like trying to get that in and then adds new features/im-  prove it in separate tickets (SSL, auto-paging, consider SASL, etc...). ",,Architectural design configuration,8:1829 - 8:2685,1,arjan
15:59,"I think the sooner we  get a working version in, the sooner we’ll have…",CASSANDRA-2478,"I think the sooner we  get a working version in, the sooner we’ll have people playing with it and get feedback.
",,,8:2686 - 8:2798,1,arjan
15:60,"Norman, would you mind reviewing the updated branch?",CASSANDRA-2478,"Norman, would you mind reviewing the updated branch?
",,,8:2812 - 8:2865,1,arjan
15:151,yukim,CASSANDRA-2478,yukim,,Comment,8:2870 - 8:2874,1,arjan
15:61,"I’m +1 to put Sylvain’s patch into 1.2. It works as described in spec,…",CASSANDRA-2478,"I’m +1 to put Sylvain’s patch into 1.2. It works as described in spec, so client  developers can start developing on this new protocol.
But before commit, I suggest two changes to the patch:  * All of protocol related classes are placed under org.apache.cassandra.cql3.transport, but I  think it’d be better to keep them under org.apache.cassandra.transport.
",,,8:2877 - 8:3237,1,arjan
15:63,* Native transport service starts by default along with thrift service…,CASSANDRA-2478,"* Native transport service starts by default along with thrift service, but isn’t it better to  turn of by default to indicate ""for developing client only""?
",,Architectural design configuration,8:3238 - 8:3395,1,arjan
15:62,"And not necessary at this time, but it is nice to have unit test like…",CASSANDRA-2478,"And not necessary at this time, but it is nice to have unit test like CliTest, based on debug  client.
35. norman: @Jonathan sorry I was so busy that I was not able to review yet... I will do today  and give feedback!
36. slebresne: bq. All of protocol related classes are placed under org.apache.cassandra.cql3.transport,  but I think it’d be better to keep them under org.apache.cassandra.transport.
Make sense.
",,,9:1 - 9:418,1,arjan
15:152,slebresne,CASSANDRA-2478,slebresne,,Comment,9:225 - 9:233,1,arjan
15:64,"I agree. And in any case, most people won’t want to run both server at…",CASSANDRA-2478,"I agree. And in any case, most people won’t want to run both server at the same time  anyway, so I’ve added fag for both thrift and the new native server in the confg fle to  choose whether to start those. You can still overwrite those by used startup fags, but I  believe most of the time the confg setting will be more convenient. And the default is to  not start the native transport by default while it’s still beta.
",,Architectural design configuration,9:581 - 9:1002,1,arjan
15:65,I’ve rebased the branch and added the two changes above in https://git…,CASSANDRA-2478,"I’ve rebased the branch and added the two changes above in https://github.com/pcmanus/cassandra/commits/2478-  3. I also made a small modifcation due to a remark made by Norman on github. Taking  about that, @Norman, was that your only remark or are you just not done looking at this?
",,,9:1003 - 9:1288,1,arjan
15:66,"bq. And not necessary at this time, but it is nice to have unit test l…",CASSANDRA-2478,"bq. And not necessary at this time, but it is nice to have unit test like CliTest, based  on debug client.
Not sure what you mean by that.",,,9:1289 - 9:1427,1,arjan
15:67,"Here, I mean automated protocol test using SimpleClient in unit test.…",CASSANDRA-2478,"Here, I mean automated protocol test using SimpleClient in unit test. CliTest runs bunch  of cli commands to test cli functionality, so I thought we might be able to do the same thing  to test native transport.
",,,9:1549 - 9:1760,1,arjan
15:68,"If Norman has nothing more to say, then let’s commit this to trunk.",CASSANDRA-2478,"If Norman has nothing more to say, then let’s commit this to trunk.
",,,9:1761 - 9:1829,1,arjan
15:69,@Yuki I think everything is ok.. Let me do a fnal review cycle today a…,CASSANDRA-2478,"@Yuki I think everything is ok.. Let me do a fnal review cycle today again.
",,,9:1842 - 9:1918,1,arjan
15:153,slebresne,CASSANDRA-2478,slebresne,,Comment,9:1923 - 9:1931,1,arjan
15:70,Oh ok. I was confused because the CliTest itself won’t work (and will…,CASSANDRA-2478,"Oh ok. I was confused because the CliTest itself won’t work (and will never) with the  native protocol since it’s completely thrift related. But yes, having some unit test can never  hurt.",,,9:2009 - 9:2196,1,arjan
15:71,Another avenue for tests will be to update the python cql driver to us…,CASSANDRA-2478,"Another avenue for tests will be to update the python cql driver to use the native  transport, and then we’ll be able to reuse the dtests (which have quite a bunch of CQL  tests).
",,"Architectural design configuration
Architectural solution benefits and drawbacks",9:2198 - 9:2378,2,arjan
15:72,Ok. I will commit to trunk. We can always commit improvements later an…,CASSANDRA-2478,"Ok. I will commit to trunk. We can always commit improvements later anyway (Nor-  man: if you do spot some minor things, do feel free to comment on that ticket directly (or  on github), even if it’s closed, and I’ll commit the changes).
40. slebresne: Alright, committed, thanks (I’ve updated the netty jar to the last version in the  process).
8
41. norman: We released 3.5.2.Final today.. not sure if you used it ;)  42. slebresne: I did.
",,,9:2459 - 10:94,1,arjan
15:154,thepaul,CASSANDRA-2478,thepaul,,Comment,10:100 - 10:106,1,arjan
15:73,"I have some input on this too, if it’s worth anything. When implementi…",CASSANDRA-2478,"I have some input on this too, if it’s worth anything. When implementing servers  and clients with this sort of protocol, the biggest headaches I experience are usually around  cross-version compatibility. This draft spec doesn’t allow much in that respect.
",,Architectural solution benefits and drawbacks,10:109 - 10:367,1,arjan
15:74,"As an initial change, could we divorce the versioning for the framing…",CASSANDRA-2478,"As an initial change, could we divorce the versioning for the framing protocol and the set  of actual communication messages within the protocol? For example, the framing protocol  (referring only to the encapsulation of direction, version, fags, opcode, length, and message  body) currently has version 1, but maybe the rest of the protocol (the exact format and set  of the supported messages) could have something ftting the Semantic Versioning stuf. This  would let the client know whether a diference in the server-side protocol version(s) was/were  compatible with the client’s own supported version(s) or not. Maybe we could even negotiate  a protocol version between the server and client with the OPTIONS/STARTUP pair.
If we don’t do this, and we end up making 127 changes to any part of the protocol over  time (defnitely possible), then we have no backward-compatible way to state a higher ver-  sion number.
",,Architectural design configuration,10:368 - 10:1289,1,arjan
15:75,This  would let the client know whether a diference in the server-side…,CASSANDRA-2478,This  would let the client know whether a diference in the server-side protocol version(s) was/were  compatible with the client’s own supported version(s) or not,,Architectural solution benefits and drawbacks,10:822 - 10:982,1,arjan
15:76,"If we don’t do this, and we end up making 127 changes to any part of t…",CASSANDRA-2478,"If we don’t do this, and we end up making 127 changes to any part of the protocol over  time (defnitely possible), then we have no backward-compatible way to state a higher ver-  sion number",,Architectural solution benefits and drawbacks,10:1097 - 10:1286,1,arjan
15:155,ardot,CASSANDRA-2478,ardot,,Comment,10:1294 - 10:1298,1,arjan
15:77,The client community typically only uses cassandra-thrift and cassandr…,CASSANDRA-2478,The client community typically only uses cassandra-thrift and cassandra-clientutil.jar  as well as some required dependencies like guava.jar. It appears as though there is no addi-  tion to the cassandra-clientutils jar (yet) to allow for client only access to the new transport  libraries. It also appears that there are some thrift exceptions in the new code methods.,,Run-time quality issues,10:1301 - 10:1669,1,arjan
15:78,Is  there a plan to run the new native CQL protocol without the thrift…,CASSANDRA-2478,"Is  there a plan to run the new native CQL protocol without the thrift libraries?
",,,10:1671 - 10:1752,1,arjan
15:156,slebresne,CASSANDRA-2478,slebresne,,Comment,10:1758 - 10:1766,1,arjan
15:79,"First, I think that for dealing with cross-version compatibility, havi…",CASSANDRA-2478,"First, I think that for dealing with cross-version compatibility, having one single version  number is much easier than splitting it in 2 diferent versions. All you care about is ’can I  have a discussion with that server’, and there is no point in adding complexity by having to  check 2 numbers (this would also complicate documentation typically), so I’m fairly strongly  against that idea.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",10:1911 - 10:2305,3,arjan
15:80,Now there is the question of whether we’ll have enough version number…,CASSANDRA-2478,"Now there is the question of whether we’ll have enough version number with the current  format. First, I certainly hope so. I think that the protocol should be something as stable as  we possibly can, and I honestly don’t think things in the protocol will change all the time.
There is really so many thing that a protocol can do and so many things we can add.
",,"Architectural solution benefits and drawbacks
Assumptions",10:2306 - 10:2668,2,arjan
15:81,But let me be clear that I don’t pretend the current committed version…,CASSANDRA-2478,"But let me be clear that I don’t pretend the current committed version to be perfect or  in any way fnal. I wanted it committed so that people can try working with it and give  feedback. I typically don’t think we should call the frst version of the protocol fnal before  there is at least 2 or 3 drivers (in diferent language) that uses it.
",,"Architectural solution benefits and drawbacks
Assumptions",10:2669 - 10:3011,2,arjan
15:82,"But once we get to that frst fnal version, I think that at the very le…",CASSANDRA-2478,"But once we get to that frst fnal version, I think that at the very least we should not  bump the protocol version between minor C* version. And truth is, while I expect burning  a few versions towards the beginning because I’m sure we won’t get everything right, if we  continue burning 1 version of the protocol every major C* version after say version 3 or 4  of the protocol, then I would consider that a big big failure on our part (if only because no  driver implementor in its right mind will want to put up with our shit if we do that). But  9
even if that happens, with one major C* release every 6 months, we’re good for some time.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",10:3012 - 11:91,3,arjan
15:83,"Besides, if I happen to be completely of the mark and we do burn versi…",CASSANDRA-2478,"Besides, if I happen to be completely of the mark and we do burn version like crazy, version  127 of the protocol can very well add a new byte to the header to increase the number of  possible versions. But I estimate the chances of that happening to be 0.
",,Architectural component behavior and structure,11:92 - 11:349,1,arjan
15:84,"That being said, and to make things a bit more fexible, I did put a pa…",CASSANDRA-2478,"That being said, and to make things a bit more fexible, I did put a paragraph to the  spec saying that clients should never expect a message to contain no more data that what  they know about. So it will be possible to add optional info in the server response without  having to burn a protocol version, which might be handy.
Also, the OPTIONS/STARTUP pair is here exactly so that there can be some negotia-  tion, which will allow to support new optional features without necessarily increasing the  protocol version, reducing a bit more the change that do need to increment the protocol  version.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",11:350 - 11:950,2,arjan
15:85,"Overall, I did though about that compatibility issue quite a bit and I…",CASSANDRA-2478,"Overall, I did though about that compatibility issue quite a bit and I do think the pro-  tocol is not too ill equipped already to deal with that. In any case, it will always be possible  to extend the versioning later if we really need to, but I do want to believe that we’ll be able  to have a fairly stable protocol (with optional features negotiated at startup), and I prefer  not designing the frst version of the protocol assuming we will fail at that.
",,"Architectural solution benefits and drawbacks
Assumptions",11:951 - 11:1410,2,arjan
15:157,slebresne,CASSANDRA-2478,slebresne,,Comment,11:1415 - 11:1423,1,arjan
15:86,"No, there is not. But we love contributions :)",CASSANDRA-2478,"No, there is not. But we love contributions :)",,Architectural solution benefits and drawbacks,11:1576 - 11:1621,1,arjan
15:87,Hell yeah. I intend to remove the thrift exceptions as part of CASSAND…,CASSANDRA-2478,"Hell yeah. I intend to remove the thrift exceptions as part of CASSANDRA-3979 (it’s  not explicit from the ticket description but I think it would be a good occasion to do so).
Making thrift needed only for the thrift is defnitively a goal (at least one of mine). It’s just  that we do that incrementally.
",,Architectural solution benefits and drawbacks,11:1710 - 11:2017,1,arjan
15:158,h2o,CASSANDRA-2478,h2o,,Comment,11:2022 - 11:2024,1,arjan
15:88,Hi - just found this and got curious (esp. after our conclusions on Th…,CASSANDRA-2478,"Hi - just found this and got curious (esp. after our conclusions on Thrift in Cologne  :). The protocol looks straightforward enough, though I’m not sure about the general as-  sumption of synchronous behaviour. My understanding so far is that this is a completely  synchronous request/response protocol with no provision for out-of-order or async-oneway  commands (which might also obviate otherwise empty Void RESULTs), and I don’t see  frame or command/reply correlation numbers anywhere. These might become necessary for  incremental server-push as well. Is this assessment correct? Is this omission intentional?
Just asking whether this was a consideration at all since it has coupling implications for the  actual transport layer and client interaction.
",,"Assumptions
Technical debt",11:2027 - 11:2788,2,arjan
15:159,slebresne,CASSANDRA-2478,slebresne,,Comment,11:2793 - 11:2801,1,arjan
15:89,"I did consider a fully asynchronous protocol for a minute, but I felt…",CASSANDRA-2478,"I did consider a fully asynchronous protocol for a minute, but I felt that it  would complicate things quite a bit and I’m unsure of the benefts. That is, I can see  the point for out-of-order frame in things like SPDY where you want to multiplex lots of  diferent streams inside the same connection, but it feels overkill for us. I typically don’t  think having clients maintaining a pool of connections be a big problem, and in fact client  will want that anyway because you want to load balance the connections over multiple nodes.
",,Trade-offs,11:2804 - 11:3339,1,arjan
15:90,"That being said, there is nothing in the spec (or it’s unintentional)…",CASSANDRA-2478,"That being said, there is nothing in the spec (or it’s unintentional) preventing one way  commands nor even incremental server-push. There is no frame sequence, which prevent  10
completely out-of-order frames, but that doesn’t mean client shouldn’t say expect that the  next frame after a query request must necessarily be a result frame. For instance, I intend  to explore adding some form of server event push, where the server could push (at any time)  a event frame saying for instance that a new node joined the cluster.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",11:3340 - 12:349,2,arjan
15:160,h2o,CASSANDRA-2478,h2o,,Comment,12:354 - 12:356,1,arjan
15:91,"Sylvain, thanks for the explanation - makes perfect sense, though I di…",CASSANDRA-2478,"Sylvain, thanks for the explanation - makes perfect sense, though I disagree :-) In  my experiene every protocol that starts with fully-synchronous interactions eventually has  to bite that bullet. I agree though that it’s not the most important thing right now and  other ways of coordinating client<->cluster interactions could be much more benefcial and  efcient.
",,"Architectural solution benefits and drawbacks
Architectural tactics",12:359 - 12:726,2,arjan
15:92,As for response frames I don’t see how you could handle two interleave…,CASSANDRA-2478,"As for response frames I don’t see how you could handle two interleaved queries (frst slow,  second fast but ""blocked from returning"" by the previous one) without command/response  correlation; there can only be a single query to a node in fight at a time.
",,Motivation of design issue,12:727 - 12:984,1,arjan
15:161,h2o,CASSANDRA-2478,h2o,,Comment,12:989 - 12:991,1,arjan
15:93,Another question about implementing the protocol. Thrift’s only saving…,CASSANDRA-2478,"Another question about implementing the protocol. Thrift’s only saving grace is its  capability to generate code for a multitude of languages from a schema (aka protocol DSL).
",,Architectural solution benefits and drawbacks,12:994 - 12:1170,1,arjan
15:94,"Do you expect the spec to be implemented ""by hand""? Even with a BNF or…",CASSANDRA-2478,"Do you expect the spec to be implemented ""by hand""? Even with a BNF or similar I don’t  see too many people writing their own generators (sigh).
",,,12:1171 - 12:1316,1,arjan
15:95,"Either way, it should be possible to verify (not ""test"", *verify*) a d…",CASSANDRA-2478,"Either way, it should be possible to verify (not ""test"", *verify*) a driver for compliance,  otherwise I’d expect the same drama as with AMQP where non-vendor supplied drivers  were (and often still are) in constantly diverging states of brokenness. Just a suggestion.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",12:1317 - 12:1586,2,arjan
15:162,slebresne,CASSANDRA-2478,slebresne,,Comment,12:1591 - 12:1599,1,arjan
15:96,That’s what I would do but everybody is free to do whatever he prefers…,CASSANDRA-2478,That’s what I would do but everybody is free to do whatever he prefers :),,Architectural design configuration,12:1659 - 12:1731,1,arjan
15:97,That’s likely true but I personally don’t see that as a show stopper.…,CASSANDRA-2478,"That’s likely true but I personally don’t see that as a show stopper. In my ideal world,  what I would like to see is 1 good implementation (of the protocol) per language that ev-  eryone reuse. Now, yeah it’s unlikely COBOL will get such good implementation soon, but  I can live with that.
",,Architectural solution benefits and drawbacks,12:1796 - 12:2087,1,arjan
15:98,"Sure, it would be nice. I’d lie if I said this is a priority on my tod…",CASSANDRA-2478,"Sure, it would be nice. I’d lie if I said this is a priority on my todo list at this stage,  but I would certainly welcome such a contribution.
",,Architectural solution benefits and drawbacks,12:2171 - 12:2315,1,arjan
15:163,thepaul,CASSANDRA-2478,thepaul,,Comment,12:2320 - 12:2326,1,arjan
15:99,It doesn’t need to add much complexity; it’s just a separation of laye…,CASSANDRA-2478,"It doesn’t need to add much complexity; it’s just a separation of layers, both of which  would be more simple afterward. Any good implementation of this protocol will already be  handling the framing at a diferent level than the messaging.",,Architectural solution benefits and drawbacks,12:2728 - 12:2966,1,arjan
15:100,"But if you’re that much against  it, that’s fne, I’d be ok with just a…",CASSANDRA-2478,"But if you’re that much against  it, that’s fne, I’d be ok with just a single, wider version space.
",,Architectural component behavior and structure,12:2968 - 12:3068,1,arjan
15:101,I wholeheartedly agree we want the protocol to be as stable as possibl…,CASSANDRA-2478,"I wholeheartedly agree we want the protocol to be as stable as possible, while still evolving  toward additional needs (I’m very much with the other commenters suggesting that async  messaging will be important soon, and also challenge/response auth). I also hope that we  won’t need more than a few dozen revisions total. But I fnd it unlikely; the very nature of  network protocols is that the more specifc in intention they are, the more they will need to  grow over time.
",,Architectural solution benefits and drawbacks,13:190 - 13:666,1,arjan
15:102,"Another consideration is letting servers and clients know, if their pr…",CASSANDRA-2478,"Another consideration is letting servers and clients know, if their protocol versions difer,  whether they’re still compatible with each other. This is vital information to haveâĂŤit  *will* be necessary in practical situations for clients to speak with multiple server versions  and for servers to speak with multiple client versions. Think rolling upgrades or multiple  client libs in use simultaneously.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",13:667 - 13:1074,2,arjan
15:103,"Finally, what’s the rationale for *not* having a three-part semantic v…",CASSANDRA-2478,"Finally, what’s the rationale for *not* having a three-part semantic version for the pro-  tocol? It’s an extra *two bytes* used per connection. There’s practically no downside, and  a massive potential upside.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",13:1075 - 13:1286,2,arjan
15:104,It’s not an assumption that we will fail; it’s (a) a signal to clients…,CASSANDRA-2478,"It’s not an assumption that we will fail; it’s (a) a signal to clients of compatibility and  (b) an acknowledgement of a possibly-remote chance of failure; a safety net. It’s just like  having exception handlers around complex code, even if you don’t expect to need them. It’s  just good design.",,Architectural solution benefits and drawbacks,13:1379 - 13:1673,1,arjan
15:164,slebresne,CASSANDRA-2478,slebresne,,Comment,13:1680 - 13:1688,1,arjan
15:105,"The current versioning is per-frame, so widening it would be a per-fra…",CASSANDRA-2478,"The current versioning is per-frame, so widening it would be a per-frame extra cost. Fur-  thermore, I like that the header is just 8 bytes, because that’s 1) small and 2) easy to decode  (even for debuging with tcpdump or other).
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",13:1727 - 13:1958,2,arjan
15:106,And the idea of the current implementation was to say:  # there is jus…,CASSANDRA-2478,"And the idea of the current implementation was to say:  # there is just one version for the whole protocol.
# two diferent protocol versions are incompatible, period (though we should make the guar-  antee that a server is always able to understand at least the STARTUP message of every old  versions to be able to return an error with what versions are supported).
# we will be nice and have server understand old protocol version for at least 1 or 2 major  C* version after we’ve changed them.
As far as I can tell, this does cover what we need, i.e. clients can always tell whether  they can talk to a server or not and we have a clear compatibility story (not the same ver-  sion == not compatible). I’ll note that this is how we version our internal protocol (not  trying to imply it’s the exact same problem but ...).
",,"Architectural design configuration
Architectural solution benefits and drawbacks",13:1959 - 13:2786,2,arjan
15:107,"That being said, I would agree there is at least 2 missing pieces in t…",CASSANDRA-2478,"That being said, I would agree there is at least 2 missing pieces in the implementation  currently:  * The server should respond with an error to the STARTUP message if the version is not  understood (with a list of supported version) which is not implementated yet.
* The OPTIONS/SUPPORTED pair of message could return the support protocol version  too.",,Run-time quality issues,13:2787 - 13:3141,1,arjan
15:108,But I plan to modify the SUPPORTED message in a separate ticket to mak…,CASSANDRA-2478,"But I plan to modify the SUPPORTED message in a separate ticket to make it more  versatile anyway, so I’ll do that then.
",,"Architectural component behavior and structure
Architectural tactics",13:3143 - 13:3264,2,arjan
15:109,There is the argument that a 7 bits version number might not be enough…,CASSANDRA-2478,"There is the argument that a 7 bits version number might not be enough. On that, my  personal belief is that we don’t have a choice: we have to make it enough if we want the  protocol to be used. You can have a network protocol that change every two weeks. If it  changes all the time, it’s *not* a ""protocol"". And it happens that I think it’s very possible  to achieve a stable protocol, because imho there is not infnitely many things that the pro-  tocol can do (which again doesn’t mean there isn’t tons of stuf the current implementation  doesn’t handle correctl, but that’s ok, it’s *not* the fnal version and the goal *is* to add  those missing stuf for the fnal version). This especially true imho because we have CQL.
New queries capabalities will not imply a change in the protocol for instance. Typically, I  don’t know that libpq changes all the time or lacks hundreds of features.
",,"Architectural solution benefits and drawbacks
Assumptions",14:1 - 14:896,2,arjan
15:110,I’m warming up to the idea of allowing async query handling too actual…,CASSANDRA-2478,"I’m warming up to the idea of allowing async query handling too actually, especially be-  cause I think we can make it option for the client. But I’ll open a separate ticket.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",14:918 - 14:1093,3,arjan
15:111,"As said above, I’m all for having SASL and I certainly intend to have…",CASSANDRA-2478,"As said above, I’m all for having SASL and I certainly intend to have that for version  1, I just prefer handling that in it’s own ticket. Again, the committed version is not version  1.
",,Architectural solution benefits and drawbacks,14:1123 - 14:1310,1,arjan
15:112,"Now, separating the versioning into a simple frame version and another…",CASSANDRA-2478,"Now, separating the versioning into a simple frame version and another per-connection mes-  sage version is a possibily, but I’m afraid of the following downsides:  * It complicates things. You know have to care about case like the server handle the frame  version but not the messaging one or the contrary. You also need to document the versions  separatly, so you need a versionned document for the frame protocol and one for the mes-  sage protocol. Again, feels like a single version where diferent version == incompatible is  simpler.
* I really do believe that having the protocol stable (as in, one version per C* major version  as a worst case) is not an option. Adding a more complex versioning doesn’t convey that  intention and will make it easier for us to make excuses to break the protocol often. I don’t  want that.
* I’m not sure the 3-part semantic versioning makes complete sense for a protocol. A least  the last part (the ’patch’ version) does not make sense because this info will be carried by  the C* version (you don’t ""patch"" a protocol, you patch an implementation of that protocol).
For the minor version, it’s more debatable I suppose, but I would make the argument that  it doesn’t make sense either. Again because a protocol is diferent from it’s implementation.
Any change to a protocol will break either the server or the client so there isn’t really minor  changes. Again, on simple major version seems much simpler.
",,Architectural solution benefits and drawbacks,14:1311 - 14:2765,1,arjan
15:113,My argument below is that this signal exists since we do have a versio…,CASSANDRA-2478,My argument below is that this signal exists since we do have a version,,Architectural solution benefits and drawbacks,14:2812 - 14:2882,1,arjan
15:114,We have a safety net since we have a version. With the ’only major ver…,CASSANDRA-2478,"We have a safety net since we have a version. With the ’only major version’ versioning  I’m advocating, in the remote change we’ve fail at keeping things stable, one version pur-  pose can be to introduce fner grained versioning. Introducing fner grained versioning right  away is not a safety net, it’s saying that you expect to fail.
",,Architectural solution benefits and drawbacks,14:2966 - 14:3302,1,arjan
15:165,thepaul,CASSANDRA-2478,thepaul,,Comment,14:3307 - 14:3313,1,arjan
15:115,"Ok, a guarantee like this, plus the reporting of supported protocol ve…",CASSANDRA-2478,"Ok, a guarantee like this, plus the reporting of supported protocol versions in OPTIONS,  alleviates most of my concern.
",,Architectural solution benefits and drawbacks,15:52 - 15:173,1,arjan
15:116,"It’s interesting that you bring that up, because libpq uses 32 bits fo…",CASSANDRA-2478,"It’s interesting that you bring that up, because libpq uses 32 bits for its versioning. 16  bits for a major version, and 16 for a minor. And no, it doesn’t change much. :)",,Architectural solution benefits and drawbacks,15:348 - 15:519,1,arjan
15:117,"I see your point, though, that limiting the space to 7 bits should be…",CASSANDRA-2478,"I see your point, though, that limiting the space to 7 bits should be a strong discouragement  against making changes, which ought to result in a more stable protocol. I don’t quite share  the optimism of how well it will serve us, but I do at least understand, and I guess having the  option of ""version==127 -> use additional bytes for version"" in the future is good enough.
",,Architectural solution benefits and drawbacks,15:522 - 15:899,1,arjan
15:166,slebresne,CASSANDRA-2478,slebresne,,Comment,15:904 - 15:912,1,arjan
15:118,’ve changed my mind to: CASSANDRA-4473 :D,CASSANDRA-2478,’ve changed my mind to: CASSANDRA-4473 :D,,Architectural solution benefits and drawbacks,15:1017 - 15:1057,1,arjan
15:119,Has a default port been decided for the binary protocol yet? I would l…,CASSANDRA-2478," Has a default port been decided for the binary protocol yet? I would love to get  a jump on implementing this for my .NET library, FluentCassandra.
",,,15:1073 - 15:1222,1,arjan
15:167,slebresne,CASSANDRA-2478,slebresne,,Comment,15:1227 - 15:1235,1,arjan
15:120,The currently committed implementation uses port 8000 for the binary p…,CASSANDRA-2478," The currently committed implementation uses port 8000 for the binary protocol.
Honestly that was kind of a random choice and I don’t care about changing that to any other  random choice. Not sure why that choice would stop anyone from starting implementing the  binary protocol in any client library though.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",15:1237 - 15:1547,2,arjan
15:168,nberardi,CASSANDRA-2478,nberardi,,Comment,15:1552 - 15:1559,1,arjan
15:122,"I didn’t see a reference to any port, so 8000 is good enough for me.",CASSANDRA-2478," I didn’t see a reference to any port, so 8000 is good enough for me.",,Architectural solution benefits and drawbacks,15:1561 - 15:1629,1,arjan
15:121,"It wasn’t  actually stopping me from doing anything, I just didn’t kno…",CASSANDRA-2478,"It wasn’t  actually stopping me from doing anything, I just didn’t know what endpoint to connect my  build up to.
",,,15:1631 - 15:1745,1,arjan
15:169,nberardi,CASSANDRA-2478,nberardi,,Comment,15:1750 - 15:1757,1,arjan
15:123,Apparently a lot of other software also choose 8000 at random too. htt…,CASSANDRA-2478,"Apparently a lot of other software also choose 8000 at random too. http://www.speedguide.net/port.php?
Everything from internet radio to trojans to VoIP also use it. It might be wise to choose  one that is less random, so that communication over the internet isn’t hampered by other  rogue programs getting blocked for using the same port.",,Architectural solution benefits and drawbacks,15:1760 - 15:2099,1,arjan
15:124,Port 8160 seems pretty clean:  http://www.speedguide.net/port.php?port…,CASSANDRA-2478,Port 8160 seems pretty clean:  http://www.speedguide.net/port.php?port=8160,,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",15:2102 - 15:2176,2,arjan
15:125,"I don’t care either way, 8000 just seems crowded to me.",CASSANDRA-2478,"I don’t care either way, 8000 just seems crowded to me.
",,Architectural solution benefits and drawbacks,15:2179 - 15:2235,1,arjan
16:1,I have replaced all my super column families with regular column famil…,CASSANDRA-2710,"I have replaced all my super column families with regular column families using composite columns.
I have easily been able to support all previous functionality (I don’t need range delete) except  for one thing: getting multiple super columns with a single access. For this, I would need to get  multiple ranges. (I can get multiple columns, or a single range, but not multiple ranges.)  For example, I used to have  [<superColumnName1>,<subColumnName1..N>],[<superColumnName2>,<subColumnName1..N>]  and I could get superColumnName1, superColumnName2  Now I have  [<len><superColumnName1>0<len><subColumnName1>..<len><superColumnName1>0<len><subColumnNameN  and I need to get superColumnName1..superColumnName1+, superColumnName2..superColumnName2+  to get the same functionality  I would like the clients to support this functionality, e.g. Hector to have .setRages parallel to  .setColumnNames  and for CQL to support a syntax like  SELECT [FIRST N] [REVERSED] name1..nameN1, name2..nameN2... FROM ...
",,User requirement,3:97 - 3:1102,1,arjan
16:2,part of CASSANDRA-3237,CASSANDRA-2710,part of CASSANDRA-3237,,,4:60 - 4:81,1,arjan
16:16,vijay2win@yahoo.com,CASSANDRA-2710,vijay2win@yahoo.com,,Comment,4:87 - 4:105,1,arjan
16:3,This patch will expose the multiget via thrift layer (Working on  CQL3…,CASSANDRA-2710," This patch will expose the multiget via thrift layer (Working on  CQL3).
",,Architectural design configuration,4:107 - 4:181,1,arjan
16:17,vijay2win@yahoo.com,CASSANDRA-2710,vijay2win@yahoo.com,,Comment,4:185 - 4:203,1,arjan
16:4,"CQL part. cqlsh:Keyspace1> select 0 .. 2,3 from Standard1 where key =…",CASSANDRA-2710,"CQL part.
cqlsh:Keyspace1> select 0 .. 2,3 from Standard1 where key = 100;  Bad Request: line 1:16 mismatched input ’from’ expecting RANGEOP  cqlsh:Keyspace1> select 0 .. 2,3 .. 0 from Standard1 where key = 100;  Bad Request: Slice fnish must come after start in traversal order  cqlsh:Keyspace1> select 0 .. 2,3 .. ” from Standard1 where key = 100;  0 | 1 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 2 | 3 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 |  38 | 39 | 4 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 5 | 50 ...
",,Run-time quality issues,4:206 - 4:740,1,arjan
16:18,jbellis,CASSANDRA-2710,jbellis,,Comment,4:744 - 4:750,1,arjan
16:5,. We can express this in CQL3 but allowing the parser to recognize the…,CASSANDRA-2710,".
We can express this in CQL3 but allowing the parser to recognize the construction of such  a query seems fragile to me: {{SELECT * FROM Standard1 WHERE key = 100 AND  ((column1 >= 0 AND column1 <= 2) OR (column1 >= 3))}}  Leaning towards the position that we don’t want to actually expose this directly, we just want  to support it internally (so we can use it to provide compatibility w/ the old supercolumn  APIs).
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",4:810 - 4:1230,3,arjan
16:19,vijay2win@yahoo.com,CASSANDRA-2710,vijay2win@yahoo.com,,Comment,4:1234 - 4:1252,1,arjan
16:6,"Hi Jonathan, It has a lot of potential (Provides fexibility) while  mo…",CASSANDRA-2710,"Hi Jonathan, It has a lot of potential (Provides fexibility) while  modeling wide rows with composite columns.",,Architectural solution benefits and drawbacks,4:1255 - 4:1364,1,arjan
16:7,Should we at-least support it via thrift?,CASSANDRA-2710,"Should we at-least support it via thrift?
",,,4:1366 - 4:1408,1,arjan
16:20,jbellis,CASSANDRA-2710,jbellis,,Comment,4:1412 - 4:1418,1,arjan
16:8,"What is the use case? TBH this seems like a misfeature to me, that we…",CASSANDRA-2710,"What is the use case? TBH this seems like a misfeature to me, that we only support  for backwards compatibility.",,Architectural solution benefits and drawbacks,4:1421 - 4:1532,1,arjan
16:21,vijay2win@yahoo.com,CASSANDRA-2710,vijay2win@yahoo.com,,Comment,4:1538 - 4:1556,1,arjan
16:9,"Hi Jonathan, Consider a Use case where we have a hierarchical  data, t…",CASSANDRA-2710,"Hi Jonathan, Consider a Use case where we have a hierarchical  data, type:latest:1:2, type:v1:1:2, type:v2:1,2 etc the user might want to query all the data  most of the time, sometimes only the latest and sometimes a specifc versions of a given  type.
1) if we model the type to be part of the Row Key then the problem is for 80% or so use case  i will be doing a multi-get (we dont advice OPP so sometimes you might need a index).2) if  i have all of them in one row then i will be doing multiple calls to get the data out.
I am not arguing the need for it, there are other ways you can get it done (by adding the  type and v1 in the super column name or something like that)... but it will be little more  fexible. I am fne closing the ticket too :) Let me know Thanks!
",,Architectural solution benefits and drawbacks,4:1559 - 4:2334,1,arjan
16:22,jbellis,CASSANDRA-2710,jbellis,,Comment,4:2338 - 4:2344,1,arjan
16:10,What’s the objection here? multiget-within-a-single-row still has all…,CASSANDRA-2710,"What’s the objection here? multiget-within-a-single-row still has all the problems of multiget-  across-rows, with the added problem that it doesn’t parallelize across machines.
",,Architectural solution benefits and drawbacks,4:2471 - 4:2649,1,arjan
16:23,vijay2win@yahoo.com,CASSANDRA-2710,vijay2win@yahoo.com,,Comment,4:2653 - 4:2671,1,arjan
16:11,Well multiget-within-a-single-row is suppose to be one sequential IO (…,CASSANDRA-2710,"Well multiget-within-a-single-row is suppose to be one sequential IO (hence more through-  put at-least for the best case), and the co-ordinator doesn’t need to wait for the slowest  responding node (more transient memory in the co-ordinator) etc.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Architectural tactics",5:1 - 5:249,3,arjan
16:24,jbellis,CASSANDRA-2710,jbellis,,Comment,5:254 - 5:260,1,arjan
16:12,"only if the row is small enough, in which case, is there that much ben…",CASSANDRA-2710,"only if the row is small enough, in which case, is there that much beneft over just grabbing  the whole row?
",,"Architectural solution benefits and drawbacks
Assumptions",5:332 - 5:441,2,arjan
16:25,vijay2win@yahoo.com,CASSANDRA-2710,vijay2win@yahoo.com,,Comment,5:446 - 5:464,1,arjan
16:13,Sure but then we have to stream all the columns into the client which…,CASSANDRA-2710,"Sure but then we have to stream all the columns into the client which can be wasteful too...
I am fne either ways, nice to have.",,Architectural solution benefits and drawbacks,5:531 - 5:659,1,arjan
16:26,jbellis,CASSANDRA-2710,jbellis,,Comment,5:666 - 5:672,1,arjan
16:14,I’d rather not expose additional functionality to Thrift when we’re tr…,CASSANDRA-2710," I’d rather not expose additional functionality to Thrift when we’re trying to start  people moving to CQL3. Let’s leave this out.
",,Architectural solution benefits and drawbacks,5:674 - 5:805,1,arjan
16:27,vijay2win@yahoo.com,CASSANDRA-2710,vijay2win@yahoo.com,,Comment,5:810 - 5:828,1,arjan
16:15,"Closing this as wont fx, Plz see above comments for more details.",CASSANDRA-2710,"Closing this as wont fx, Plz see above comments for more details.
",,Architectural solution benefits and drawbacks,5:831 - 5:897,1,arjan
17:1,Global caches (key/row),CASSANDRA-3143,Global caches (key/row),,Architectural design configuration,3:52 - 3:74,1,arjan
17:2,"Caches are difcult to confgure well as ColumnFamilies are added, simil…",CASSANDRA-3143,"Caches are difcult to confgure well as ColumnFamilies are added, similar to how memtables were  difcult pre-CASSANDRA-2006.
",,Run-time quality issues,3:94 - 3:218,1,arjan
17:182,xedin,CASSANDRA-3143,xedin,,Comment,3:370 - 3:374,1,arjan
17:3,I think following steps are going to be appropriate to archive the goa…,CASSANDRA-3143," I think following steps are going to be appropriate to archive the goal:  - row_cache_provider should be moved to global confg  - {key/row}_cache_save_period parameters should be moved to global confg  - {keys/rows}_cached should be moved to the global confg  - new o.a.c.service.CacheService instance to hold key and row caches as static members ini-  tialized at startup  that service will be also responsible for cache save to disk operations.
- new CacheSegment class should be issued from global cache for each of the ColumnFam-  ilyStores registered in the system to be responsible for put/get operations, fush/read from  disk.
- cache sizes should be converted to memory units to support precise weighting of the cache  using Weigher backed by Jamm",,Architectural design configuration,3:376 - 3:1133,1,arjan
17:183,jbellis,CASSANDRA-3143,jbellis,,Comment,4:4 - 4:10,1,arjan
17:5,All of this is straightforward with the exception of CacheSegment,CASSANDRA-3143,All of this is straightforward with the exception of CacheSegment,,Architectural solution benefits and drawbacks,4:13 - 4:77,1,arjan
17:4,can you elaborate  on that part?,CASSANDRA-3143,"can you elaborate  on that part?
",,,4:80 - 4:113,1,arjan
17:184,xedin,CASSANDRA-3143,xedin,,Comment,4:117 - 4:121,1,arjan
17:6,"So yes, CacheSegment is a segment of the cache which is allocated per…",CASSANDRA-3143,"So yes, CacheSegment is a segment of the cache which is allocated per ColumnFam-  ilyStore. It is going to be used to put/get to global cache and to hold CFS specifc properties  of the cache such as current cache capacity and size (modifcation of those properties will be  refected on the global cache level so we don’t need to worry about eviction policies). Also  segment will be responsible to save/read cache to/from disk.
",,Architectural design configuration,4:124 - 4:551,1,arjan
17:7,so we don’t need to worry about eviction policies,CASSANDRA-3143,so we don’t need to worry about eviction policies,,Architectural solution benefits and drawbacks,4:432 - 4:480,1,arjan
17:8,I don’t understand why we would have CFS-specifc cache properties in a…,CASSANDRA-3143,"I don’t understand why we would have CFS-specifc cache properties in a global  cache.
",,,4:564 - 4:650,1,arjan
17:185,xedin,CASSANDRA-3143,xedin,,Comment,4:654 - 4:658,1,arjan
17:9,The point is that we won’t have any CFS-specifc cache properties Cache…,CASSANDRA-3143,"The point is that we won’t have any CFS-specifc cache properties CacheSegment is  going to hold everything - that will be useful in pair with JMX to modifcate capacity and  get cache statistics per CFS.
",,Architectural component behavior and structure,4:661 - 4:864,1,arjan
17:10,that will be useful in pair with JMX to modifcate capacity and  get ca…,CASSANDRA-3143,that will be useful in pair with JMX to modifcate capacity and  get cache statistics per CFS.,,Architectural solution benefits and drawbacks,4:770 - 4:862,1,arjan
17:11,But if it’s One Big Cache how does modifying capacity per CF make sens…,CASSANDRA-3143," But if it’s One Big Cache how does modifying capacity per CF make sense?
",,,4:876 - 4:950,1,arjan
17:186,xedin,CASSANDRA-3143,xedin,,Comment,4:954 - 4:958,1,arjan
17:12,If you will modify capacity for segment it is going to store the value…,CASSANDRA-3143," If you will modify capacity for segment it is going to store the value and signal global  cache to change it’s capacity appropriately. Useful when you want to play with row cache  sizes for individual CFs.
",,Architectural design configuration,4:960 - 4:1167,1,arjan
17:13,Useful when you want to play with row cache  sizes for individual CFs.,CASSANDRA-3143,Useful when you want to play with row cache  sizes for individual CFs.,,Architectural solution benefits and drawbacks,4:1096 - 4:1165,1,arjan
17:187,jbellis,CASSANDRA-3143,jbellis,,Comment,4:1171 - 4:1177,1,arjan
17:14,But the point of making it a global cache is that per-CF cache sizes g…,CASSANDRA-3143,"But the point of making it a global cache is that per-CF cache sizes go away. Instead  you rely on global LRU + weight to do the right thing (presumably, a better job than trying  to manually size, anyway).
",,Architectural solution benefits and drawbacks,4:1180 - 4:1387,1,arjan
17:188,xedin,CASSANDRA-3143,xedin,,Comment,4:1391 - 4:1395,1,arjan
17:15,"updated my frst comment, so CacheSegment will be designed to support g…",CASSANDRA-3143,"updated my frst comment, so CacheSegment will be designed to support get/put  operations and fush/read from disk.
",,Architectural component behavior and structure,4:1398 - 4:1512,1,arjan
17:189,xedin,CASSANDRA-3143,xedin,,Comment,4:1517 - 4:1521,1,arjan
17:16,Also: we should size the global cache in bytes.,CASSANDRA-3143,Also: we should size the global cache in bytes.,,Architectural design configuration,4:1548 - 4:1594,1,arjan
17:17,"Do it ""manually"" by estimating bytes from Key length plus CLHM overhea…",CASSANDRA-3143,"Do it ""manually"" by estimating bytes from Key length plus CLHM overhead",,"Architectural design configuration
Architectural solution benefits and drawbacks",4:1632 - 4:1702,2,arjan
17:18,Use JAMM as we do for memtables,CASSANDRA-3143,Use JAMM as we do for memtables,,Architectural design configuration,4:1705 - 4:1735,1,arjan
17:19,"Since the key cache is simpler than a memtable, the frst approach migh…",CASSANDRA-3143,"Since the key cache is simpler than a memtable, the frst approach might be workable here.
But we know JAMM works reasonably well, so that’s fne too.
",,Trade-offs,4:1738 - 4:1888,1,arjan
17:20,Hmm. I guess we could have the cache provider include a sizeInMemory m…,CASSANDRA-3143,"Hmm. I guess we could have the cache provider include a sizeInMemory method?
",,"Architectural component behavior and structure
Assumptions",4:1889 - 4:1966,2,arjan
17:21,For serialized of-heap cache we can just use the FreeableMemory size()…,CASSANDRA-3143,"For serialized of-heap cache we can just use the FreeableMemory size(). For on-heap cache  we can use the serializedSize * liveRatio from the CF’s memtable.
",,Architectural component behavior and structure,4:1967 - 4:2124,1,arjan
17:22,rebased with latest trunk (last commit b9944399520c839f75725ec0f43e23f…,CASSANDRA-3143,rebased with latest trunk (last commit b9944399520c839f75725ec0f43e23fae5487f4),,,4:2136 - 4:2214,1,arjan
17:23,Please run ‘ant gen-thrift-java‘ and ‘ant avro-generate‘ right after y…,CASSANDRA-3143,"Please run ‘ant gen-thrift-java‘ and ‘ant avro-generate‘ right after you apply the set  of patches.
",,,4:2228 - 4:2328,1,arjan
17:24,rebased with latest trunk,CASSANDRA-3143,rebased with latest trunk,,,4:2340 - 4:2364,1,arjan
17:190,slebresne,CASSANDRA-3143,slebresne,,Comment,4:2371 - 4:2379,1,arjan
17:25,I did a few pass over the patch. I haven’t applied the patches yet (th…,CASSANDRA-3143,"I did a few pass over the patch. I haven’t applied the patches yet (they need  rebase anyway) and a few stufs from the frst patches is fxed in the later ones, which I  realize only when reading those later patches, so even if I’ve tried to update my comments,  there may be a few outdated ones, sorry about that.
",,,4:2382 - 4:2695,1,arjan
17:26,"* At least for the row cache, I fear this may sometimes be less efcien…",CASSANDRA-3143,"* At least for the row cache, I fear this may sometimes be less efcient than what we have  now, because some cf with less than good hit rate may evict rows of cf with very good hit  3
rate, which wouldn’t happen in the current implementation with reasonably tuned cache  sizes. Aren’t we screwing people that are doing fne tuning in the name of simplicity?
",,"Architectural solution benefits and drawbacks
Assumptions",4:2739 - 5:174,2,arjan
17:27,"Preceding point apart, we would at least need a way to deactivate row…",CASSANDRA-3143,"Preceding point apart, we would at least need a way to deactivate row caching on a per-cf  basis. We may also want that for key cache, though this seems less critical. ",,User requirement,5:177 - 5:344,1,arjan
17:28,My initial idea  would be to either have a boolean fag if we only want…,CASSANDRA-3143,"My initial idea  would be to either have a boolean fag if we only want to allow disabling row cache, or some  multi-value caches option that could be ""none"", ""key_only"", ""row_only"" or ""all"".
",,Architectural component behavior and structure,5:345 - 5:536,1,arjan
17:29,We probably need to have a story as far as upgrading to this patch is…,CASSANDRA-3143,"We probably need to have a story as far as upgrading to this patch is concerned (cleaning  old saved caches, migrating to the new global options, ...). It’s probably fne just leaving  instructions in the NEWS fle as a start, but I’d rather do it with the patch to avoid forget-  ting.
",,,5:539 - 5:823,1,arjan
17:30,I think it’d be better to size the key cache by it’s size in bytes rat…,CASSANDRA-3143,"I think it’d be better to size the key cache by it’s size in bytes rather than by number of  entries, like for the row cache, since ’size alloted to the cache’ is really the only measure that  make sense for a user.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:827 - 5:1043,2,arjan
17:31,"For the Row cache key, we should really use the cfId instead of table…",CASSANDRA-3143," For the Row cache key, we should really use the cfId instead of table and cfname.
",,Architectural component behavior and structure,5:1101 - 5:1184,1,arjan
17:32,I think it would be worth factoring what can be of readSaved. In parti…,CASSANDRA-3143,"I think it would be worth factoring what can be of readSaved. In particular, we could  create a KeyCacheKey (like RowCacheKey and that would really just be the usual pair of  (Descriptor, DecoratedKey), have it share an interface with RowCacheKey (serialize and  deserialize basically) and use that.
",,"Architectural design configuration
Assumptions",5:1187 - 5:1487,2,arjan
17:33,Putting the clone of the key into the constructor of RowCacheKey is in…,CASSANDRA-3143,"Putting the clone of the key into the constructor of RowCacheKey is inefcient, we don’t  care about cloning when we invalidate or query the cache (nor when we deserialize Row-  CacheKeys).
",,Run-time quality issues,5:1490 - 5:1679,1,arjan
17:34,"nit: not fond of declaration like public abstract Set<?> readSaved(),…",CASSANDRA-3143,"nit: not fond of declaration like public abstract Set<?> readSaved(), making it harder to  know what the method returns just to save a few characters.
",,Architectural solution benefits and drawbacks,5:1682 - 5:1833,1,arjan
17:35,In DatabaseDescriptor:  if (CacheService.instance == null)  logger.err…,CASSANDRA-3143,"In DatabaseDescriptor:  if (CacheService.instance == null)  logger.error(""Could not initialize Cache Service."");  I believe the CacheService.instance will load the CacheService that will trigger an exception  if there is a problem, not set the instance to null. So in particular, this message will never  be written. That code is moved by the 4th patch but the problem remains I think (note  that we do want to make sure CacheService get loaded quickly to throw an exception if we  have an  initialization problem, it’s just not the right way I believe).
",,Run-time quality issues,5:1846 - 5:2401,1,arjan
17:36,I’m not super fond of that key cache preloading. If the key cache save…,CASSANDRA-3143,"I’m not super fond of that key cache preloading. If the key cache save is outdated, we’ll  have a bunch of uselessly preloaded stuf (not a huge deal but...).",,Run-time quality issues,5:2404 - 5:2560,1,arjan
17:37,Maybe we could keep  doing as before and just save the set of keys for…,CASSANDRA-3143,"Maybe we could keep  doing as before and just save the set of keys for each column family instead. That would  needs bufering of the keys during the cache save though, but not sure it’s such a huge deal  and it would reduce the size of the saved cache quite a bit.
",,Architectural design configuration,5:2562 - 5:2827,1,arjan
17:38,"That would  needs bufering of the keys during the cache save though, b…",CASSANDRA-3143,"That would  needs bufering of the keys during the cache save though, but not sure it’s such a huge deal  and it would reduce the size of the saved cache quite a bit.",,Architectural solution benefits and drawbacks,5:2661 - 5:2825,1,arjan
17:39,"In CacheService, setRowCacheSavePeriodInSecond directly schedule the s…",CASSANDRA-3143," In CacheService, setRowCacheSavePeriodInSecond directly schedule the saving to the new  value, but the get method grabs the value from DatabaseDescriptor, so it will always return  the initially set value, which is not what we want. ",,Run-time quality issues,5:2829 - 5:3062,1,arjan
17:40,I think we should keep the Integer that  were previously in CFS (but I…,CASSANDRA-3143,"I think we should keep the Integer that  were previously in CFS (but I’m fne moving them to CacheService).
",,"Architectural component behavior and structure
Assumptions",5:3063 - 5:3170,2,arjan
17:41,Why does the getRowCacheKeysToSave() option disappeared?,CASSANDRA-3143,"Why does the getRowCacheKeysToSave() option disappeared?
",,,5:3173 - 5:3230,1,arjan
17:42,The patch does the following change:  4- int newCapacity = (int) (Data…,CASSANDRA-3143,"The patch does the following change:  4
- int newCapacity = (int) (DatabaseDescriptor.getReduceCacheCapacityTo(  * size());  + int newCapacity = (int) (DatabaseDescriptor.getReduceCacheCapacityTo(  * getCapacity());  but that’s not the semantic of the operation. The initial was the right one.
",,Run-time quality issues,5:3243 - 6:255,1,arjan
17:43,I really think that making DecoratedKey equals method deal with RowCac…,CASSANDRA-3143,"I really think that making DecoratedKey equals method deal with RowCacheKey is asking  for trouble. Not sure why it would be useful either?
",,Run-time quality issues,6:258 - 6:398,1,arjan
17:191,xedin,CASSANDRA-3143,xedin,,Comment,6:403 - 6:407,1,arjan
17:44,This is going to be moved to the separate task.,CASSANDRA-3143,"This is going to be moved to the separate task.
",,Architectural design configuration,6:775 - 6:823,1,arjan
17:45,Secondary index cfs do not register with Schema.load so they don’t hav…,CASSANDRA-3143,"Secondary index cfs do not register with Schema.load so they don’t have a cfId.
",,Architectural solution benefits and drawbacks,6:911 - 6:991,1,arjan
17:46,Done,CASSANDRA-3143,Done,,Architectural solution benefits and drawbacks,6:1297 - 6:1300,1,arjan
17:47,Fixed,CASSANDRA-3143,Fixed,,Architectural solution benefits and drawbacks,6:1496 - 6:1500,1,arjan
17:48,Changed to Set<? extends CacheKey> as both key and row cache key now s…,CASSANDRA-3143,"Changed to Set<? extends CacheKey> as both key and row cache key now share the  same interface - CacheKey.
",,Architectural component behavior and structure,6:1660 - 6:1767,1,arjan
17:49,as both key and row cache key now share the  same interface - CacheKey,CASSANDRA-3143,as both key and row cache key now share the  same interface - CacheKey,,Architectural solution benefits and drawbacks,6:1695 - 6:1764,1,arjan
17:50,This is the same as done in the StorageService constructor to make sur…,CASSANDRA-3143,"This is the same as done in the StorageService constructor to make sure that StreamingSer-  vice.instance is available when needed, because static felds are initialized on the frst demand.
",,Architectural solution benefits and drawbacks,6:2213 - 6:2402,1,arjan
17:51,The idea was to rely on cache LRU policy and save an actual global sta…,CASSANDRA-3143,"The idea was to rely on cache LRU policy and save an actual global state of the cache  to minimize cache’s specifc confguration per cf...
",,Architectural solution benefits and drawbacks,7:63 - 7:201,1,arjan
17:52,Fixed,CASSANDRA-3143,Fixed,,Architectural solution benefits and drawbacks,7:547 - 7:551,1,arjan
17:53,"Because we don’t control that anymore, rely on cache LRU policy instea…",CASSANDRA-3143,"Because we don’t control that anymore, rely on cache LRU policy instead.
",,Existing system architecture description,7:617 - 7:690,1,arjan
17:54,"This was unclear at frst but fxed to use ""weightedSize()"" instead of ""…",CASSANDRA-3143,"This was unclear at frst but fxed to use ""weightedSize()"" instead of ""getCapacity()"" now.
",,Existing system architecture description,7:835 - 7:925,1,arjan
17:55,Fixed,CASSANDRA-3143,Fixed,,Architectural solution benefits and drawbacks,7:1071 - 7:1075,1,arjan
17:56,Rebased with the latest trunk (last commit f76e9aeaed3e73bcfaf6bccd62f…,CASSANDRA-3143,Rebased with the latest trunk (last commit f76e9aeaed3e73bcfaf6bccd62f9f02f31b09960),,,7:1079 - 7:1162,1,arjan
17:192,xedin,CASSANDRA-3143,xedin,,Comment,7:1169 - 7:1173,1,arjan
17:57,Information was added to NEWS.txt,CASSANDRA-3143,Information was added to NEWS.txt,,,7:1494 - 7:1526,1,arjan
17:58,cassandra.yaml option changed to key_cache_size_in_mb,CASSANDRA-3143,cassandra.yaml option changed to key_cache_size_in_mb,,"Architectural solution benefits and drawbacks
Existing system architecture description",7:1748 - 7:1800,2,arjan
17:193,jbellis,CASSANDRA-3143,jbellis,,Comment,7:1807 - 7:1813,1,arjan
17:59,I don’t think we should be trying to cache 2I CFs.,CASSANDRA-3143,"I don’t think we should be trying to cache 2I CFs.
",,"Architectural solution benefits and drawbacks
Assumptions",7:1901 - 7:1952,2,arjan
17:194,xedin,CASSANDRA-3143,xedin,,Comment,7:1957 - 7:1961,1,arjan
17:60,RowCacheKey to use cfId instead of keyspace/cf pair (added to updated…,CASSANDRA-3143,"RowCacheKey to use cfId instead of keyspace/cf pair (added to updated 0006 patch).
",,Existing system architecture description,7:1964 - 7:2047,1,arjan
17:61,Would you mind rebasing ?,CASSANDRA-3143,"Would you mind rebasing ?
",,,7:2063 - 7:2089,1,arjan
17:62,rebased with the lastest trunk (last commit 58518301472fc99b01cfd4bcf9…,CASSANDRA-3143,rebased with the lastest trunk (last commit 58518301472fc99b01cfd4bcf90bf81b5f0694ee),,,7:2101 - 7:2185,1,arjan
17:195,slebresne,CASSANDRA-3143,slebresne,,Comment,7:2192 - 7:2200,1,arjan
17:63,I’m not a fan of that idea. We just cannot release this without a way…,CASSANDRA-3143,"I’m not a fan of that idea. We just cannot release this without a way to deactivate the  row cache as this would make the row cache unusable for most users. IMHO, that’s a good  defnition of something that should not be moved to a separate task.
",,Architectural solution benefits and drawbacks,8:239 - 8:485,1,arjan
17:64,"I don’t understand how ""relying on cache LRU policy"" has anything to d…",CASSANDRA-3143,"I don’t understand how ""relying on cache LRU policy"" has anything to do with that. The  initial motivation for that option is that people don’t want to reload the full extend of the  row cache on restart because it takes forever, but they don’t want to start with cold caches  either. I don’t see how making the cache global changes anything on that. I agree that the  number of row cache key to save should now be a global option, but I disagree that it should  be removed.
",,Architectural solution benefits and drawbacks,8:640 - 8:1115,1,arjan
17:65,The code around CFS.prepareRowForCaching is weird. First the comment s…,CASSANDRA-3143,The code around CFS.prepareRowForCaching is weird. First the comment seems to sug-  gest that prepareRowForCaching is used exclusively from CacheService while it’s use below  in cacheRow. ,,,8:1130 - 8:1317,1,arjan
17:66,It also adds a copy of the columns which I don’t think is necessary si…,CASSANDRA-3143,It also adds a copy of the columns which I don’t think is necessary since  we already copy in MappedFileDataInput. ,,"Assumptions
Run-time quality issues",8:1318 - 8:1432,2,arjan
17:67,Overall I’m not sure prepareRowForCaching is  useful,CASSANDRA-3143,Overall I’m not sure prepareRowForCaching is  useful ,,"Assumptions
Technical debt",8:1433 - 8:1485,2,arjan
17:68,CacheService.readSavedRowCache could use cacheRow directly,CASSANDRA-3143,CacheService.readSavedRowCache could use cacheRow directly,,Architectural component behavior and structure,8:1490 - 8:1547,1,arjan
17:69,I don’t think CacheService.reloadKeyCache works correctly. It only pop…,CASSANDRA-3143," I don’t think CacheService.reloadKeyCache works correctly. It only populate the cache  with fake values that won’t get updated unless you reload the sstables, which has no reason  to happen. ",,"Assumptions
Run-time quality issues",8:1551 - 8:1742,2,arjan
17:70,"I’m fne removing the key cache reloading altogether, but as an alterna…",CASSANDRA-3143,"I’m fne removing the key cache reloading altogether, but as an alternative, why  not save the value of the key cache too?",,"Architectural design configuration
Assumptions",8:1743 - 8:1863,2,arjan
17:71,"The thing is, I’m not very comfortable with the  current ’two phase’ k…",CASSANDRA-3143,"The thing is, I’m not very comfortable with the  current ’two phase’ key cache loading: if we ever have a bug in the SSTReader.load method,  the actual pre-loading with -1 values will be harmful, which seems unnecessarily fragile.
",,Run-time quality issues,8:1865 - 8:2096,1,arjan
17:72,Saving the values on disk would avoid that.,CASSANDRA-3143,Saving the values on disk would avoid that.,,"Architectural design configuration
Architectural solution benefits and drawbacks",8:2097 - 8:2139,2,arjan
17:73,"Talking of the key cache save, the format used by the patch is really…",CASSANDRA-3143,"Talking of the key cache save, the format used by the patch is really really not compact.
For each key we save the full path to the sstable, which can easily be > 50 bytes. ",,Run-time quality issues,8:2144 - 8:2317,1,arjan
17:74,Maybe  we could associate an int to each descriptor during the save an…,CASSANDRA-3143,Maybe  we could associate an int to each descriptor during the save and save the association of  descriptor -> id separately. * Still worth allowing to chose how may keys to save,,Architectural component behavior and structure,8:2318 - 8:2495,1,arjan
17:75,"The cache sizings don’t take the keys into account. For the row cache,…",CASSANDRA-3143,"The cache sizings don’t take the keys into account. For the row cache, one could make the  argument that the overhead of the keys is negligible compared to the values. For the key  cache however, the key are bigger than the values.
",,Run-time quality issues,8:2500 - 8:2732,1,arjan
17:76,The patch mistakenly remove the help for ’nodetool upgradesstables’ (i…,CASSANDRA-3143,The patch mistakenly remove the help for ’nodetool upgradesstables’ (in NodeCmd.java),,,8:2735 - 8:2819,1,arjan
17:77,Would be worth adding a global cache log line in StatusLogger.,CASSANDRA-3143,"Would be worth adding a global cache log line in StatusLogger.
",,,8:2824 - 8:2887,1,arjan
17:78,Patch wrongly reintroduces memtable_operations and memtable_throughput…,CASSANDRA-3143,"Patch wrongly reintroduces memtable_operations and memtable_throughput to CliHelp.
",,,8:2890 - 8:2973,1,arjan
17:79,"The default row cache provider since 1.0 is the serializing one, this…",CASSANDRA-3143,"The default row cache provider since 1.0 is the serializing one, this patch sets the Concur-  rentLinkedHashCacheProvider instead.
",,Run-time quality issues,8:2976 - 8:3107,1,arjan
17:80,"In CFS, it’s probably faster/simpler to use metadata.cfId rather than…",CASSANDRA-3143,"In CFS, it’s probably faster/simpler to use metadata.cfId rather than Schema.instance.getId(table.name,  this.columnFamily)",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Architectural tactics
Assumptions",8:3133 - 8:3255,4,arjan
17:81,"In CacheService, calling scheduleSaving with -1 as second argument wou…",CASSANDRA-3143,"In CacheService, calling scheduleSaving with -1 as second argument would be slightly faster  than using Integer.MAX_VALUE.
",,"Architectural component behavior and structure
Architectural tactics",8:3260 - 8:3382,2,arjan
17:82,"In SSTableReader.cacheKey, the assert {{key.key == null}} is useless i…",CASSANDRA-3143,"In SSTableReader.cacheKey, the assert {{key.key == null}} is useless in trunk (DK with  key == null can’t be constructed).
",,,9:3 - 9:126,1,arjan
17:83,"In AutosavingCache, I think we could declare AutoSavingCache<K extends…",CASSANDRA-3143,"In AutosavingCache, I think we could declare AutoSavingCache<K extends CacheKey,  V> and get rid of the translateKey() method",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",9:367 - 9:491,3,arjan
17:196,xedin,CASSANDRA-3143,xedin,,Comment,9:498 - 9:502,1,arjan
17:84,Couldn’t we do that the same way we did with compression options? I’m…,CASSANDRA-3143,"Couldn’t we do that the same way we did with compression options? I’m happy to make it  a sub-task, I just want the main code to be settled before starting with that.
",,,9:758 - 9:924,1,arjan
17:85,Is that going to have the same use case as it did per-CF? Meaning we w…,CASSANDRA-3143,"Is that going to have the same use case as it did per-CF? Meaning we would be saving  a top of the cache and it doesn’t guarantee that system doesn’t start almost cold...
",,Architectural solution benefits and drawbacks,9:988 - 9:1159,1,arjan
17:86,Do you think that it worse the efort of maintaining (also persisting)…,CASSANDRA-3143,"Do you think that it worse the efort of maintaining (also persisting) such descriptor ->  id relationship exclusively for key cache? Meaning it’s already very compact cache e.g. even  with descriptor > 50 bytes we would need ~20 mb to store 200000 keys...
",,Trade-offs,9:1532 - 9:1787,1,arjan
17:87,"We do that because CLHM only allows to measure values, to do something…",CASSANDRA-3143,"We do that because CLHM only allows to measure values, to do something about it we  would need to re-write Weighter interface and change core semantics of CLHM...
",,Architectural solution benefits and drawbacks,9:2026 - 9:2189,1,arjan
17:197,xedin,CASSANDRA-3143,xedin,,Comment,9:2194 - 9:2198,1,arjan
17:88,"Agreed, I just thought that it’s valuable to have that key cache reloa…",CASSANDRA-3143,"Agreed, I just thought that it’s valuable to have that key cache reload around, I’m go-  ing to remove it.",,Architectural solution benefits and drawbacks,9:2797 - 9:2902,1,arjan
17:89,But - save values to avoid ’two phrase’ key cache loading - would requ…,CASSANDRA-3143,"But - save values to avoid ’two phrase’ key cache loading - would require to  use a common interface for values in key/row caches with serialize/deserialize functionality  which is not suitable e.g. for ColumnFamily that we store in row cache... That is why we  still rely on SSTableReader.load I think, saving values would limit fexibility of the cache  interface...",,Architectural solution benefits and drawbacks,9:2904 - 9:3270,1,arjan
17:90,"I think, saving values would limit fexibility of the cache  interface.…",CASSANDRA-3143,"I think, saving values would limit fexibility of the cache  interface...
",,Assumptions,9:3199 - 9:3272,1,arjan
17:91,This would mean that we will be caching even secondary index CFs which…,CASSANDRA-3143,"This would mean that we will be caching even secondary index CFs which is, as was said, is  not desired.
",,Architectural solution benefits and drawbacks,10:21 - 10:126,1,arjan
17:92,This could have even worse performance because it will change semantic…,CASSANDRA-3143,"This could have even worse performance because it will change semantics and call hotKeySet  method on the ICache, for CLHM this is _not_ O(1) operation as doc for ""descendingKey-  SetWithLimit(int limit);"" says.
",,Architectural solution benefits and drawbacks,10:255 - 10:467,1,arjan
17:93,I think it does because it also helps to reclaim some memory when syst…,CASSANDRA-3143,"I think it does because it also helps to reclaim some memory when system is starving.
",,"Architectural tactics
Assumptions",10:553 - 10:639,2,arjan
17:198,slebresne,CASSANDRA-3143,slebresne,,Comment,10:644 - 10:652,1,arjan
17:94,ok,CASSANDRA-3143,ok,,,10:827 - 10:828,1,arjan
17:95,"Yes, it should really do exactly the same thing that the old option, e…",CASSANDRA-3143,"Yes, it should really do exactly the same thing that the old option, except being global.
",,Architectural design configuration,10:1007 - 10:1097,1,arjan
17:96,The thing is that 200000 keys is not necessary huge (especially given…,CASSANDRA-3143,"The thing is that 200000 keys is not necessary huge (especially given you can have more  key cache entry than the total number of your keys since there is an entry per-sstable).
And 50 bytes for each flename is also not even a worst case at all, especially when we have  CASSANDRA-2749. And with say 1M keys, if each flename is 100 bytes, add the actual  keys to that, we’re talking > 100MB. Without being huge, it’s a noticeable wast of I/O when  the cache could easily be 10 times smaller. And if we add the values it will be worth.
There is also the fact that I would be ashamed to have to explain to user that we save  those full path to sstable with each entry when they complain that the key cache on disk is  more than 10 times bigger that max size they confgured in the yaml fle.
",,Architectural solution benefits and drawbacks,10:1373 - 10:2163,1,arjan
17:97,"At the very least, one easy win would be to save only the keyspace, co…",CASSANDRA-3143,"At the very least, one easy win would be to save only the keyspace, columnFamily, ver-  sion and generation part of the flename, rather than the whole path to the sstable. ",,Architectural component behavior and structure,10:2164 - 10:2335,1,arjan
17:98,"But  otherwise, when I talked about a descriptor -> id relationship, I…",CASSANDRA-3143,"But  otherwise, when I talked about a descriptor -> id relationship, I was thinking of something  simple. Like saving two fles instead of on, one would be the keys with the descriptor replaced  by compact ids, the other would be the metadata, i.e, the descriptor -> id map. That would  really just be some internal detail of the save function. But that’s really just an idea.
",,Architectural design configuration,10:2336 - 10:2712,1,arjan
17:99,"Yeah, I know :(. But for the key cache, we use a constant weighter, co…",CASSANDRA-3143,"Yeah, I know :(. But for the key cache, we use a constant weighter, counting 8 bytes  for each ""entry"". Figured we could use some higher constant to get closer to the actual  size taken by each entry in-memory, even if we don’t account for the exact size of the key.
Typically, the KeyCacheKey structure will take ""at least"" 32 bytes in memory (it’s more  than that but given there is at least the DK token and a bunch of pointers...), so typically  if we were to consider each entry to be like 40 or 48 bytes, I think we would be closer to the  actual in-memory size. I just want to avoid people confguring 100MB for the key cache (ok,  that would be a huge one) and actually having it being more like 1GB.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",11:1 - 11:710,2,arjan
17:100,I think we would be closer to the  actual in-memory size.,CASSANDRA-3143,I think we would be closer to the  actual in-memory size.,,Assumptions,11:513 - 11:569,1,arjan
17:101,Another option would be to reuse the technique used to measure memtabl…,CASSANDRA-3143,"Another option would be to reuse the technique used to measure memtables, but I’m fne  leaving that to another ticket.
",,Architectural design configuration,11:711 - 11:830,1,arjan
17:102,I fail to see what is so crazy about having the function that saves th…,CASSANDRA-3143,"I fail to see what is so crazy about having the function that saves the cache having ac-  cess to both key and value. It may require a bit of refactoring, but I don’t see that as a  good argument",,Architectural solution benefits and drawbacks,11:1217 - 11:1411,1,arjan
17:103,"Anyway, it’s not a very big deal but I still think that the two phase…",CASSANDRA-3143,"Anyway, it’s not a very big deal but I still think that the two phase loading  is more fragile than it needs, and saving values would allow a proper reload.
",,"Architectural solution benefits and drawbacks
Assumptions",11:1414 - 11:1571,2,arjan
17:104,I don’t understand. I’m just saying that a cfs object already has a re…,CASSANDRA-3143,"I don’t understand. I’m just saying that a cfs object already has a reference to its metadata,  so it’s slightly cleaner to use that rather that do query to Schema.instance using the table  and column family name.
",,Architectural solution benefits and drawbacks,11:1682 - 11:1896,1,arjan
17:105,"Otherwise, forget to say that the patch adds the following useless lin…",CASSANDRA-3143,"Otherwise, forget to say that the patch adds the following useless line in  CFS.java:  /** Lock to allow migrations to block all flushing, so we can be sure  not to write orphaned data files */  public final Lock flushLock = new ReentrantLock();",,,11:1897 - 11:2141,1,arjan
17:199,xedin,CASSANDRA-3143,xedin,,Comment,11:2148 - 11:2152,1,arjan
17:106,"In my previous comment I wrote ""Secondary index cfs do not register wi…",CASSANDRA-3143,"In my previous comment I wrote ""Secondary index cfs do not register with Schema.load  so they don’t have a cfId."" and Jonathan replied ""I don’t think we should be trying to cache  2I CFs."" that is why I’m saying that if we will use metadata.cfId we would cache 2L CFs  without even noticing.
",,Architectural solution benefits and drawbacks,11:2374 - 11:2666,1,arjan
17:107,Jonathan can you please settle this argument?,CASSANDRA-3143,"Jonathan can you please settle this argument?
",,,12:365 - 12:411,1,arjan
17:200,slebresne,CASSANDRA-3143,slebresne,,Comment,12:416 - 12:424,1,arjan
17:108,"Sorry, I was probably not clear. I really just meant replacing the two…",CASSANDRA-3143,"Sorry, I was probably not clear. I really just meant replacing the two calls to {{Schema.instance.getId()}}  by {{metadata.cfId}}. We would still have the next line be {{if (cfId == null) return; }} to  avoid caching 2ndary indexes.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",12:533 - 12:766,2,arjan
17:201,xedin,CASSANDRA-3143,xedin,,Comment,12:771 - 12:775,1,arjan
17:109,What I’m trying to say is that SecondaryIndex CF has a metadata.cfId j…,CASSANDRA-3143,"What I’m trying to say is that SecondaryIndex CF has a metadata.cfId just like a nor-  mal CF so check for cfId == null would be pointless in that case but such CFs don’t register  with the Schema so Schema.instance.getId() will return null for SecondaryIndex CF.
",,Architectural component behavior and structure,12:1008 - 12:1272,1,arjan
17:202,slebresne,CASSANDRA-3143,slebresne,,Comment,12:1277 - 12:1285,1,arjan
17:110,"You’re right, my bad, I looked at the wrong constructor in CFMetada an…",CASSANDRA-3143,"You’re right, my bad, I looked at the wrong constructor in CFMetada and  though they got a null cfId. Nevermind.
",,Architectural solution benefits and drawbacks,12:1288 - 12:1401,1,arjan
17:203,xedin,CASSANDRA-3143,xedin,,Comment,12:1406 - 12:1410,1,arjan
17:111,The problem with using only keyspace/cf/generate is that information i…,CASSANDRA-3143,The problem with using only keyspace/cf/generate is that information is not sufcient to  build descriptor back on readSaved.,,Architectural solution benefits and drawbacks,12:1980 - 12:2103,1,arjan
17:112,"On the other hand, if we will be using descriptor ->  id relationship,…",CASSANDRA-3143,"On the other hand, if we will be using descriptor ->  id relationship, wouldn’t it create the same amount of additional I/O (+ expenses on such  cache maintain) as just having Descriptor as cache key?
",,"Architectural solution benefits and drawbacks
Assumptions",12:2105 - 12:2306,2,arjan
17:113,"Sure, I will just change that to 40 bytes and update doc for key_cache…",CASSANDRA-3143,"Sure, I will just change that to 40 bytes and update doc for key_cache_size_in_mb with  11
something like ""please note that actual number of entries for given amount of space is cal-  culated using following formula: key_cache_size_in_mb * 1024 * 1024 / 48 where 48 = 8  bytes (size of value) + 40 bytes (average size of the key)"".
",,,12:3033 - 13:242,1,arjan
17:204,slebresne,CASSANDRA-3143,slebresne,,Comment,13:247 - 13:255,1,arjan
17:114,I’m not talking of changing KeyCacheKey in any way. I’m talking of mak…,CASSANDRA-3143,"I’m not talking of changing KeyCacheKey in any way. I’m talking of making the key cache  save being 2 fles (keySave and keySaveMetadata) having the key cache save method looking  something like that (in pseudo-code):  Map<Descriptor, Integer> assoc = new HashMap();  int nextId = 0;  for (KeyCacheKey key : keys)  {  Integer id = assoc.get(key.desc);  if (id == null)  {  // descriptor we haven’t seen yet during this save  id = nextId++;  assoc.put(key.desc, id);  keySaveMetadata.write(key.desc => id)  }  keySave.write(id => key.key)  }  And the reading would frst load the map from keySaveMetadata and read keySave.
",,Architectural design configuration,13:464 - 13:1084,1,arjan
17:115,I would be in favor of not documenting this in the yaml as it’ll confu…,CASSANDRA-3143,I would be in favor of not documenting this in the yaml as it’ll confuse more user than  anything else and we don’t want anyone to rely on that formula.,,,13:1172 - 13:1323,1,arjan
17:116,"rebased set of patches, where all the changes from the second Sylvain’…",CASSANDRA-3143,"rebased set of patches, where all the changes from the second Sylvain’s comment are  in patch #7.
",,,13:1337 - 13:1434,1,arjan
17:205,jbellis,CASSANDRA-3143,jbellis,,Comment,13:1440 - 13:1446,1,arjan
17:117,I’m actually okay with just brute-forcing it Pavel’s way for now. We c…,CASSANDRA-3143,I’m actually okay with just brute-forcing it Pavel’s way for now. We can always optimize  later if it’s a problem.,,Architectural solution benefits and drawbacks,13:1602 - 13:1715,1,arjan
17:118,Could we just use a compressed writer for 80% of the beneft?,CASSANDRA-3143,Could we just use a compressed writer for 80% of the beneft?,,,13:1718 - 13:1777,1,arjan
17:206,jbellis,CASSANDRA-3143,jbellis,,Comment,13:1785 - 13:1791,1,arjan
17:119,Why would you want to do a cache reload? That’s just going to be stale…,CASSANDRA-3143,"Why would you want to do a cache reload? That’s just going to be stale... Clearing the  cache I can understand, but reloading a semi-arbitrary older cache state? I don’t see the  value there.
",,Architectural solution benefits and drawbacks,13:2151 - 13:2343,1,arjan
17:120,ISTM we’re talking about trading one kind of ugly code (passing around…,CASSANDRA-3143,"ISTM we’re talking about trading one kind of ugly code (passing around the Set of keys  to load to SSTR) for another (a lot of code duplication between key cache, which wants  to save values, and row cache, which doesn’t).",,Architectural solution benefits and drawbacks,14:1 - 14:222,1,arjan
17:121,It’s also worth pointing out that if we’re  concerned about cache size…,CASSANDRA-3143,"It’s also worth pointing out that if we’re  concerned about cache size, the two-phase approach gives smaller saved caches. So I think  I’d lean towards the existing, two-phase approach.
",,Architectural solution benefits and drawbacks,14:224 - 14:410,1,arjan
17:122,"So I think  I’d lean towards the existing, two-phase approach",CASSANDRA-3143,"So I think  I’d lean towards the existing, two-phase approach",,Assumptions,14:347 - 14:407,1,arjan
17:207,slebresne,CASSANDRA-3143,slebresne,,Comment,14:415 - 14:423,1,arjan
17:123,Alright. I don’t really care about cache reloading either actually. Th…,CASSANDRA-3143,"Alright. I don’t really care about cache reloading either actually. The only thing  I don’t like with the two phase approach is that it populate the cache with -1 positions. If  for any reason, this doesn’t get updated correctly, we’ll end up having the cache wrongly  saying that the key doesn’t exists in the sstable. Of course there is no reason for the two  phase approach to not work, but there is part of me that don’t like that a simple mess up  in the cache loading can make some keys unaccessible. Anyway, let’s just not have bugs in  there :)",,Architectural solution benefits and drawbacks,14:426 - 14:977,1,arjan
17:208,xedin,CASSANDRA-3143,xedin,,Comment,14:984 - 14:988,1,arjan
17:124,How about we just change SSTableReader.getCachedPosition to return nul…,CASSANDRA-3143,"How about we just change SSTableReader.getCachedPosition to return null if value  of the key cache was -1?
",,Architectural component behavior and structure,14:991 - 14:1098,1,arjan
17:209,jbellis,CASSANDRA-3143,jbellis,,Comment,14:1103 - 14:1109,1,arjan
17:125,I’d rather go with the current approach of leaving the cache empty unt…,CASSANDRA-3143,"I’d rather go with the current approach of leaving the cache empty until we have  real values for it, and pass SSTR a Set of keys-to-load.
",,Architectural component behavior and structure,14:1112 - 14:1251,1,arjan
17:210,xedin,CASSANDRA-3143,xedin,,Comment,14:1256 - 14:1260,1,arjan
17:126,I’m not a fan of that because we would need to drag read keys through…,CASSANDRA-3143,I’m not a fan of that because we would need to drag read keys through all of the  CFS and SSTableReaders :(,,Architectural solution benefits and drawbacks,14:1263 - 14:1369,1,arjan
17:211,jbellis,CASSANDRA-3143,jbellis,,Comment,14:1376 - 14:1382,1,arjan
17:127,"Again, that’s what we’re doing now, so I don’t see it as *that* big a…",CASSANDRA-3143,"Again, that’s what we’re doing now, so I don’t see it as *that* big a deal. But I’m  good with either that approach, or save-the-values-also approach. I agree with Sylvain that  keeping invalid values in the cache and replacing them later is a bad idea.
",,Architectural solution benefits and drawbacks,14:1385 - 14:1638,1,arjan
17:212,xedin,CASSANDRA-3143,xedin,,Comment,14:1644 - 14:1648,1,arjan
17:128,We are doing that now because we are able to read caches independently…,CASSANDRA-3143,"We are doing that now because we are able to read caches independently for each of  the CFS, but with a global cache we would need to load that set on cache init and keep it  through Schema.load as I global state, why wouldn’t changing SSTableReader.getCachedPosition  to return null (and delete that key) if value was -1, be a path of least resistance in this case?
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",14:1651 - 14:2018,3,arjan
17:213,jbellis,CASSANDRA-3143,jbellis,,Comment,14:2023 - 14:2029,1,arjan
17:129,It’s unhygenic. :) For the same reason that leaving felds to be initia…,CASSANDRA-3143,"It’s unhygenic. :) For the same reason that leaving felds to be initialized by a  setFoo method later, is less hygenic than an immutable feld that gets set in the constructor.
",,Architectural solution benefits and drawbacks,14:2032 - 14:2208,1,arjan
17:214,jbellis,CASSANDRA-3143,jbellis,,Comment,14:2213 - 14:2219,1,arjan
17:130,"Also note that while we have ""one global cache"" internally, there’s no…",CASSANDRA-3143,"Also note that while we have ""one global cache"" internally, there’s nothing stopping  us from splitting out the diferent CFs to diferent save fles. In fact that would be great  from a backwards compatibility point of view; there’s users out there who would really hate  to blow away their cache on upgrade, and preserving the save format would avoid the need  for a backwards compatibility mode.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",14:2222 - 14:2618,2,arjan
17:215,xedin,CASSANDRA-3143,xedin,,Comment,14:2623 - 14:2627,1,arjan
17:131,"Yeah, I guess this is the best way to go, I will remove #7 patch and r…",CASSANDRA-3143,"Yeah, I guess this is the best way to go, I will remove #7 patch and re-attach with  those changes to avoid pre-loading keys as well as keeping a global state.
",,Architectural solution benefits and drawbacks,14:2630 - 14:2789,1,arjan
17:132,row/key caches are made backwards compatible and save only DecoratedKe…,CASSANDRA-3143,"row/key caches are made backwards compatible and save only DecoratedKey plus  tweaks/fxes from Sylvain’s second comment.
",,,14:2802 - 14:2923,1,arjan
17:216,jbellis,CASSANDRA-3143,jbellis,,Comment,14:2928 - 14:2934,1,arjan
17:133,It’s difcult to review this patchset because a lot of refactoring was…,CASSANDRA-3143,It’s difcult to review this patchset because a lot of refactoring was introduced  orthogonal to the new functionality. I’m specifcally looking at the CacheKey heirarchy;,,,14:2939 - 14:3107,1,arjan
17:134,"the old ""abstract translateKey"" seemed like a reasonable compromise of…",CASSANDRA-3143,"the old ""abstract translateKey"" seemed like a reasonable compromise of fexibility without  complexity to me. Granted that CacheKey may be an improvement,",,Architectural solution benefits and drawbacks,14:3110 - 14:3262,1,arjan
17:135,I’d like to do that kind  of refactor in another ticket to simplify re…,CASSANDRA-3143,"I’d like to do that kind  of refactor in another ticket to simplify review of the new functionality.
",,,14:3264 - 14:3365,1,arjan
17:136,Do we actually beneft from caching DecoratedKey instead of byte[] ? De…,CASSANDRA-3143,Do we actually beneft from caching DecoratedKey instead of byte[] ? DecoratedKey costs  a *lot* of memory for small row keys. Since the cache is unordered I can’t think of any  beneft to using DK instead of byte[]. (Another reason I think CacheKey may be the wrong  way to go.),,Architectural solution benefits and drawbacks,14:3368 - 14:3644,1,arjan
17:217,xedin,CASSANDRA-3143,xedin,,Comment,15:5 - 15:9,1,arjan
17:137,Personally I like CacheKey because it allows to remove AutoSaving{Key/…,CASSANDRA-3143,"Personally I like CacheKey because it allows to remove AutoSaving{Key/Row}Cache classes  and make code better generalized. But I agree that it makes it kind of hard to review...
",,Architectural solution benefits and drawbacks,15:443 - 15:621,1,arjan
17:138,I don’t think we do.,CASSANDRA-3143,I don’t think we do.,,Architectural solution benefits and drawbacks,15:905 - 15:924,1,arjan
17:139,Attaching 0008 which changes {Row/Key}Cache to use raw (Byte-  Bufer)…,CASSANDRA-3143,"Attaching 0008 which changes {Row/Key}Cache to use raw (Byte-  Bufer) key instead of DecoratedKey.
",,,15:926 - 15:1025,1,arjan
17:218,slebresne,CASSANDRA-3143,slebresne,,Comment,15:1030 - 15:1038,1,arjan
17:140,* CacheKey could have a serializeSize() method for use rather needless…,CASSANDRA-3143,"* CacheKey could have a serializeSize() method for use rather needlessly creating ByteBufers  just to get there size in estimateSizeToSave.
* CacheKey.serialize() is unused.
",,,15:1105 - 15:1280,1,arjan
17:141,"Since that for saving each cache, we do n+1 iterations through the who…",CASSANDRA-3143,"Since that for saving each cache, we do n+1 iterations through the whole cache where n  is the number of column families. It seems rather inefcient",,"Architectural solution benefits and drawbacks
Existing system architecture description",15:1283 - 15:1429,2,arjan
17:142,we could probably write all  caches (for all CFs) simultaneously for a…,CASSANDRA-3143,we could probably write all  caches (for all CFs) simultaneously for a more efcient process.,,"Architectural design configuration
Architectural tactics",15:1432 - 15:1523,2,arjan
17:143,"When reading the cache, it seems we decorate each key just to ""validat…",CASSANDRA-3143,"When reading the cache, it seems we decorate each key just to ""validate saved data"" (we  discard the DK object afterwards). But I don’t think decorating a key entails any kind of  validation of the key so this feel useless.
",,"Architectural solution benefits and drawbacks
Assumptions
Existing system architecture description",15:1528 - 15:1751,3,arjan
17:144,Do we care about reloading the row cache? Jonathan was right that relo…,CASSANDRA-3143," Do we care about reloading the row cache? Jonathan was right that reloading a cache is  probably pretty useless.
",,Architectural solution benefits and drawbacks,15:1754 - 15:1868,1,arjan
17:219,xedin,CASSANDRA-3143,xedin,,Comment,15:1873 - 15:1877,1,arjan
17:145,I was thinking about that - it would require to keep all of the fles o…,CASSANDRA-3143,"I was thinking about that - it would require to keep all of the fles open, do we want that?
",,"Architectural design configuration
Architectural solution benefits and drawbacks",15:2127 - 15:2219,2,arjan
17:146,"Ok, lets just drop it completely then.",CASSANDRA-3143,"Ok, lets just drop it completely then.
",,Architectural solution benefits and drawbacks,15:2338 - 15:2377,1,arjan
17:220,slebresne,CASSANDRA-3143,slebresne,,Comment,15:2382 - 15:2390,1,arjan
17:147,Is that a big deal? I suppose if you have 1000 CFs it’s starting to be…,CASSANDRA-3143,"Is that a big deal? I suppose if you have 1000 CFs it’s starting to be a big number of  fds open, but even then it doesn’t sound like such a big deal, especially given it’s for a very  short time. Or did you had other concerns in mind?
",,Architectural solution benefits and drawbacks,15:2491 - 15:2727,1,arjan
17:221,xedin,CASSANDRA-3143,xedin,,Comment,15:2732 - 15:2736,1,arjan
17:148,"If you say so, I was just concerned about additional amount of fds ope…",CASSANDRA-3143," If you say so, I was just concerned about additional amount of fds open",,Architectural solution benefits and drawbacks,15:2738 - 15:2809,1,arjan
17:149,Will change  that in upcoming patch #9.,CASSANDRA-3143,"Will change  that in upcoming patch #9.
",,,15:2812 - 15:2852,1,arjan
17:222,xedin,CASSANDRA-3143,xedin,,Comment,15:2857 - 15:2861,1,arjan
17:150,We need a DecoratedKey there for key cache as SSTableReader operates o…,CASSANDRA-3143,"We need a DecoratedKey there for key cache as SSTableReader operates on the Decorated-  Key instances in load method.
",,Architectural component behavior and structure,15:3093 - 15:3211,1,arjan
17:223,xedin,CASSANDRA-3143,xedin,,Comment,16:5 - 16:9,1,arjan
17:151,added serializedSize() method to CacheKey interface.,CASSANDRA-3143,"added serializedSize() method to CacheKey interface.
",,,16:155 - 16:208,1,arjan
17:152,removed serialize() in favor of serializeForStorage(),CASSANDRA-3143,removed serialize() in favor of serializeForStorage(),,,16:246 - 16:298,1,arjan
17:153,Changed write to O(n) by keeping writers cached.,CASSANDRA-3143,"Changed write to O(n) by keeping writers cached.
",,Architectural solution benefits and drawbacks,16:548 - 16:597,1,arjan
17:154,Fixed,CASSANDRA-3143,Fixed,,Architectural solution benefits and drawbacks,16:827 - 16:831,1,arjan
17:155,Key and Row cache reloading is not dropped. (key cache reloading was d…,CASSANDRA-3143,"Key and Row cache reloading is not dropped. (key cache reloading was dropped by patch 7).
",,Existing system architecture description,16:952 - 16:1042,1,arjan
17:156,52. slebresne: This needs to be rebased. I really wouldn’t mind if you…,CASSANDRA-3143,"52. slebresne: This needs to be rebased. I really wouldn’t mind if you were to squash all  patches into just one btw.
53. xedin: rebased and squashed.
54. xedin: squashed commit properly rebased with trunk.
",,,16:1043 - 16:1252,1,arjan
17:224,slebresne,CASSANDRA-3143,slebresne,,Comment,16:1257 - 16:1265,1,arjan
17:157,"When saving the cache, the ’writeKeyQuietly’ make it possible to write…",CASSANDRA-3143,"When saving the cache, the ’writeKeyQuietly’ make it possible to write a corrupted fle  (maybe only part of a key has been written) and has the risk of fooding the log (if one key  throw an IOException, chances are the next one on this fle will too).",,Run-time quality issues,16:1324 - 16:1573,1,arjan
17:158,I think we’d have less  problem just stop all saving if an IOError occ…,CASSANDRA-3143,"I think we’d have less  problem just stop all saving if an IOError occurs.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",16:1575 - 16:1650,3,arjan
17:159,"In CFS.initRowCache(), the test {{ if (cachedRowsRead++ > rowCache.get…",CASSANDRA-3143,"In CFS.initRowCache(), the test {{ if (cachedRowsRead++ > rowCache.getCapacity())  }} is now not correct since getCapacity is a memory size. ",,Run-time quality issues,16:1653 - 16:1793,1,arjan
17:160,"For now, I’m fne removing the  test and say that ’if you reduce the si…",CASSANDRA-3143,"For now, I’m fne removing the  test and say that ’if you reduce the size, you may not get you hottest keys loaded on startup’.
Though ultimately we’ll probably need to fx that.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",16:1794 - 16:1972,2,arjan
17:161,I think I was preferring the old way of using the InstrumentingCacheMB…,CASSANDRA-3143,"I think I was preferring the old way of using the InstrumentingCacheMBean, rather than  to have lots of {get,set}RowCache, {get,set}KeyCache method that forward to the Instru-  mentingCache ones. Basically I think it’s more clear to have Cache->RowCache->infos and  Cache->KeyCache->infos, rather than CacheServices->allInfos. It’s also more easily exten-  sible if we ever add some new cache.
",,"Architectural solution benefits and drawbacks
Assumptions",16:2009 - 16:2403,2,arjan
17:162,"In any case, we don’t register the InstrumentingCacheMBean anymore and…",CASSANDRA-3143,"In any case, we don’t register the InstrumentingCacheMBean anymore and the CacheSer-  vice one doesn’t expose the hit rate nor the number of requests processed (and we can remove  InstrumentingCacheMBean if we’re not going to use it).
",,,16:2406 - 16:2641,1,arjan
17:163,"Both set{Key,Row}CacheSavePeriodInSeconds and saveCaches disregard the…",CASSANDRA-3143,"Both set{Key,Row}CacheSavePeriodInSeconds and saveCaches disregard the {Key,Row}CacheKeysToSave  setting, while they probably shouldn’t.
",,Run-time quality issues,17:3 - 17:140,1,arjan
17:164,I’d rename getRowCacheCapacity() to getRwoCacheCapacityInMB() to match…,CASSANDRA-3143," I’d rename getRowCacheCapacity() to getRwoCacheCapacityInMB() to match the set  method.
",,,17:142 - 17:231,1,arjan
17:165,"* In AutoSavingCache.saveCache, I’d log the ""Deleting old fles"" messag…",CASSANDRA-3143,"* In AutoSavingCache.saveCache, I’d log the ""Deleting old fles"" message at DEBUG.
* In DatabaseDescriptor, there’s a wrongly placed import  * In CFS, we should probably remove the getKeyCache method, to emphasis it’s now a  global thing. Same in DataTracker.
* The comment from {{ data.addSSTables(sstables); // this will call updateCacheSizes() for  us }} in CFS.loadNewSSTables is outdated  * DK.java uselessly import RowCacheKey (and only have a very gratuitous codeStyle change  btw).
* I would rename the CacheService MBean name to more simply ""org.apache.cassandra.db:type=Caches"".
",,,17:318 - 17:909,1,arjan
17:166,I’ll also note for posterity that by removing the DK from the cache ke…,CASSANDRA-3143,"I’ll also note for posterity that by removing the DK from the cache keys, we’re trading  of memory for cpu (since we have to redecorate for each use). Don’t get me wrong, it’s  likely a good trade-of, just wanted to write it down.
",,Trade-offs,17:910 - 17:1141,1,arjan
17:225,jbellis,CASSANDRA-3143,jbellis,,Comment,17:1146 - 17:1152,1,arjan
17:167,"Why is that? Shouldn’t we be looking up by (cfd, raw key)? We already…",CASSANDRA-3143,"Why is that? Shouldn’t we be looking up by (cfd, raw key)? We already have the DK  in the getPosition / getCachedPosition call tree, we shouldn’t need to store it in the cache  to avoid recomputing it.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",17:1310 - 17:1512,2,arjan
17:226,slebresne,CASSANDRA-3143,slebresne,,Comment,17:1517 - 17:1525,1,arjan
17:168,"Oups, you’re right, I was looking of the case of storing a new row in…",CASSANDRA-3143,"Oups, you’re right, I was looking of the case of storing a new row in the row-  Cache, where the patch does decorate the key, and got a bit carried away. Especially so  since even if the case of storing a row in the cache we can easily avoid the recomputation,  it’s just an inefciency of the patch (that should be fxed).
",,Architectural solution benefits and drawbacks,17:1528 - 17:1850,1,arjan
17:169,separate patch with fxes attached.,CASSANDRA-3143,"separate patch with fxes attached.
",,,17:1862 - 17:1896,1,arjan
17:227,slebresne,CASSANDRA-3143,slebresne,,Comment,17:1902 - 17:1910,1,arjan
17:170,"Alright, patch lgtm, +1. Great work Pavel.",CASSANDRA-3143,"Alright, patch lgtm, +1. Great work Pavel.",,Architectural solution benefits and drawbacks,17:1913 - 17:1954,1,arjan
17:171,"As mentioned in the previous comments, currently when a row need to be…",CASSANDRA-3143,"As mentioned in the previous comments, currently when a row need to be read to be put in  cache, CFS.cacheRow() decorates the key, ",,Run-time quality issues,17:2029 - 17:2159,1,arjan
17:172,which can be avoided just by making cacheRow  take the DK and create t…,CASSANDRA-3143,"which can be avoided just by making cacheRow  take the DK and create the RowCacheKey internally.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",17:2160 - 17:2257,2,arjan
17:173,We should rename setRowCacheCapacity to setRowCacheCapacityMB to match…,CASSANDRA-3143,We should rename setRowCacheCapacity to setRowCacheCapacityMB to match the others,,,17:2260 - 17:2340,1,arjan
17:174,It would be nice to move the cache stats from nodetool cfstats to node…,CASSANDRA-3143," It would be nice to move the cache stats from nodetool cfstats to nodetool info, rather  than purely removing them",,,17:2344 - 17:2458,1,arjan
17:175,The saveCaches method still does not respect the cacheKeysToSave optio…,CASSANDRA-3143,The saveCaches method still does not respect the cacheKeysToSave options,,Run-time quality issues,17:2463 - 17:2534,1,arjan
17:176,And of course there is the question of disabling row caching on per-cf…,CASSANDRA-3143,"And of course there is the question of disabling row caching on per-cf basis which, as said  previously, I think is a must have before we release this (because any user that have at least  one CF with wide rows (or that just happens to be a bad candidate for caching) will need  it). So ok to do that post commit but let’s put it at the top of the todo list then.
",,Run-time quality issues,17:2537 - 17:2901,1,arjan
17:177,rebased 0001 and 0002 + 0003 with fnal fxes,CASSANDRA-3143,rebased 0001 and 0002 + 0003 with fnal fxes,,,17:2913 - 17:2955,1,arjan
17:228,slebresne,CASSANDRA-3143,slebresne,,Comment,17:2962 - 17:2970,1,arjan
17:178,"Last version lgtm, +1 (nit: I don’t think the getCacheCapacityInBytes…",CASSANDRA-3143,"Last version lgtm, +1 (nit: I don’t think the getCacheCapacityInBytes methods  are too necessary when we already have it in MB).
",,Architectural solution benefits and drawbacks,17:2973 - 17:3101,1,arjan
17:179,"Thanks, Sylvain! I have created CASSANDRA-3667, will get to it as soon…",CASSANDRA-3143,"Thanks, Sylvain! I have created CASSANDRA-3667, will get to it as soon as I  commit this one.
",,,18:12 - 18:106,1,arjan
17:229,jbellis,CASSANDRA-3143,jbellis,,Comment,18:111 - 18:117,1,arjan
17:180,+1,CASSANDRA-3143,+1,,Architectural solution benefits and drawbacks,18:120 - 18:121,1,arjan
17:181,Committed.,CASSANDRA-3143,"Committed.
",,,18:135 - 18:146,1,arjan
18:1,super columns are annoying.,CASSANDRA-3237,super columns are annoying.,,Run-time quality issues,3:144 - 3:170,1,arjan
18:2,composite columns ofer a better API and performance. people  should us…,CASSANDRA-3237,"composite columns ofer a better API and performance. people  should use composites over super columns. some people are already using super columns. C*  should implement the super column API in terms of composites to reduce code, complexity and  testing as well as increase performance.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Architectural tactics",3:172 - 3:458,3,arjan
18:38,stuhood,CASSANDRA-3237,stuhood,,Comment,3:560 - 3:566,1,arjan
18:3,In order to continue to support the existing API (delete the children…,CASSANDRA-3237," In order to continue to support the existing API (delete the children of this  parent), we’ll need to add an internal representation of deleted slices. CASSANDRA-674  can persist them, but ColumnFamily would also need a slice tombstones list.
",,Motivation of design issue,3:568 - 3:812,1,arjan
18:39,thobbs,CASSANDRA-3237,thobbs,,Comment,3:816 - 3:821,1,arjan
18:4,We would also need to support fetching multiple non-contiguous slices…,CASSANDRA-3237,"We would also need to support fetching multiple non-contiguous slices from the  same row in order to emulate fetching multiple super columns by name.
",,Motivation of design issue,3:824 - 3:974,1,arjan
18:40,jjordan,CASSANDRA-3237,jjordan,,Comment,3:978 - 3:984,1,arjan
18:5,Multiple Slice Ranges in one query would be nice for the regular API t…,CASSANDRA-3237,"Multiple Slice Ranges in one query would be nice for the regular API to get access  to if that is implemented.
",,Architectural solution benefits and drawbacks,3:987 - 3:1098,1,arjan
18:41,mck,CASSANDRA-3237,mck,,Comment,3:1102 - 3:1104,1,arjan
18:6,"We using supercolumns to provide us ""buckets of counters"". (I’ve attac…",CASSANDRA-3237,"We using supercolumns to provide us ""buckets of counters"". (I’ve attached the irc log  discussing our valid use case for supercolumns).
",,Architectural solution benefits and drawbacks,3:1107 - 3:1243,1,arjan
18:7,Today with supercolumns you can select multiple supercolumns in one qu…,CASSANDRA-3237,"Today with supercolumns you can select multiple supercolumns in one query.
With composite columns you have to do a slice for each bucket. In our use case this explodes  one query into hundreds of queries.
",,Architectural solution benefits and drawbacks,3:1244 - 3:1450,1,arjan
18:8,Will the existing supercoumn API exist so we can continue doing single…,CASSANDRA-3237,"Will the existing supercoumn API exist so we can continue doing single queries,",,Architectural design configuration,4:1 - 4:79,1,arjan
18:9,"will  it become possible to do ""get_multislice"" (get one row with mutl…",CASSANDRA-3237,"will  it become possible to do ""get_multislice"" (get one row with mutliple column slices)",,Architectural design configuration,4:84 - 4:172,1,arjan
18:42,jbellis,CASSANDRA-3237,jbellis,,Comment,4:179 - 4:185,1,arjan
18:10,Yes. The frst subtask here is about selecting multiple ranges so that…,CASSANDRA-3237,"Yes. The frst subtask here is about selecting multiple ranges so that we can emulate the  ""multiple supercolumns in one query"" functionality.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",4:232 - 4:374,2,arjan
18:11,"Oops, helps to read the issue :-(",CASSANDRA-3237,"Oops, helps to read the issue :-(",,,4:383 - 4:415,1,arjan
18:43,rstrickland,CASSANDRA-3237,rstrickland,,Comment,4:421 - 4:431,1,arjan
18:12,Will there be a migration path for the underlying SC data? I have two…,CASSANDRA-3237,"Will there be a migration path for the underlying SC data? I have two years  worth of data in SCs for the same reason as Mck. Having experienced the pain of the 0.6.x  -> 0.7.x migration, I’m not thrilled about the idea of fguring out how to get all my data into  a new format. No matter how much the C* community may despise SCs, a lot of people have  a lot of data stored in them for valid reasons, so there needs to be a well-defned migration  path.
",,User requirement,4:434 - 4:887,1,arjan
18:44,slebresne,CASSANDRA-3237,slebresne,,Comment,4:891 - 4:899,1,arjan
18:13,"@Robbie Don’t worry, there will be a migration path or we won’t do it.…",CASSANDRA-3237,"@Robbie Don’t worry, there will be a migration path or we won’t do it. This has  never been about breaking this for people, only about cleaning the internals of Cassandra.
",,User requirement,4:902 - 4:1074,1,arjan
18:45,vijay2win@yahoo.com,CASSANDRA-3237,vijay2win@yahoo.com,,Comment,4:1078 - 4:1096,1,arjan
18:14,Super columns will internally use composite column for storage but wil…,CASSANDRA-3237,"Super columns will internally use composite column for storage but will communicate be-  tween nodes as Super columns. (for wire compatibility during upgrade)  We should also modify the startup to scrub the SCF and convert internally to Composite  columns.
",,Architectural design configuration,4:1149 - 4:1405,1,arjan
18:15,"Make internode communication to use columns instead, Cleanup supercolu…",CASSANDRA-3237,"Make internode communication to use columns instead, Cleanup supercolumn specifc code  in the next major release.
What this means that the user has to upgrade to 1.3 before upgrading to 1.4 (if he/she  uses SC).
",,Architectural design configuration,4:1418 - 4:1631,1,arjan
18:46,slebresne,CASSANDRA-3237,slebresne,,Comment,4:1636 - 4:1644,1,arjan
18:16,I’m not really sure we need to really have 2 phases,CASSANDRA-3237,I’m not really sure we need to really have 2 phases,,"Architectural solution benefits and drawbacks
Assumptions",4:1647 - 4:1697,2,arjan
18:17,and in any case I’m not  convinced a startup scrub is the right approa…,CASSANDRA-3237,and in any case I’m not  convinced a startup scrub is the right approach.,,Architectural solution benefits and drawbacks,4:1700 - 4:1772,1,arjan
18:18,I think that what we need is to write conversions functions for <CF wi…,CASSANDRA-3237,"I think that what we need is to write conversions functions for <CF with SC> to and  from <CF with equivalent composite> and for requests on both kind of CF. With those,  I think you can directly remove the use of SC internally, you just use those functions for  1) compatibility when sending/receiving to/from older nodes and 2) decode old SC format  when reading old sstables. Of course that’s much more easily said than done.
",,"Architectural design configuration
Assumptions",4:1775 - 4:2204,2,arjan
18:19,Of course that’s much more easily said than done.,CASSANDRA-3237,Of course that’s much more easily said than done.,,Architectural solution benefits and drawbacks,4:2154 - 4:2202,1,arjan
18:20,Is there any page/post describing how exactly SC will be implemented u…,CASSANDRA-3237,"Is there any page/post describing how exactly SC will be implemented using Com-  posite Columns?
",,,4:2216 - 4:2313,1,arjan
18:47,slebresne,CASSANDRA-3237,slebresne,,Comment,4:2318 - 4:2326,1,arjan
18:21,"There isn’t, but it’s not like there is many way to do it. It’ll be a…",CASSANDRA-3237,"There isn’t, but it’s not like there is many way to do it. It’ll be a composite  with 2 components, the frst one being the old SC name, and the second one being the old  column name.",,Architectural design configuration,4:2329 - 4:2510,1,arjan
18:22,Despite there being no startup scrub this still means that a manual ‘n…,CASSANDRA-3237,"Despite there being no startup scrub this still means that a manual ‘nodetool upgradessta-  bles‘ will use these conversions functions to rewrite all sstables to composite columns?
",,,4:2674 - 4:2855,1,arjan
18:48,slebresne,CASSANDRA-3237,slebresne,,Comment,5:5 - 5:13,1,arjan
18:23,Attached patches for this at https://github.com/pcmanus/cassandra/comm…,CASSANDRA-3237,"Attached patches for this at https://github.com/pcmanus/cassandra/commits/3237-  1.
",,,5:16 - 5:100,1,arjan
18:24,"The main idea is that internally, super column families are handled fo…",CASSANDRA-3237,"The main idea is that internally, super column families are handled for almost all intents and  purposes as if their comparator was a simple CompositeType with 2 components: the 1st  one is the old super column name, the 2nd one the old sub-column name. Meaning that they  are largely not a special anymore and all the super column specifc code go away (including  SuperColumn.java).
Now for compatibility sake, the main action is in the new SuperColumns.java class. This  class contains a bunch of static methods that:  * deserialize old super column format directly into new composite based CF.
* serialize new composite based CF to the old super column format  * convert ’super column query flters’ to and from ’composite based query flters’.
Then in ColumnFamilySerializer and the ReadCommand serializer, we use those static meth-  ods when talking to old nodes (and a super column family is involved). We also convert thrift  SC queries into equivalent ones on the new composite format in CassandraServer.java.
The patch also don’t shy away from removing abstractions that are not necessary anymore  once super columns are removed. Most notably:  * QueryPath is removed. It was honestly already kind of useless with super columns but even  more so without them. It was also error-prone imho because some method that were taking  a QueryPath were actually ignoring everything except the columnFamilyName for instance.
I note that the class itself is not removed but kept only to simplify wire compatibility with  old nodes.
* IColumn and IColumnContainer are removed.
We could also merge ColumnFamily and AbstractColumnContainer but I’ve left that to  later.
",,Architectural design configuration,5:162 - 5:1832,1,arjan
18:25,The patch also don’t shy away from removing abstractions that are not…,CASSANDRA-3237,"The patch also don’t shy away from removing abstractions that are not necessary anymore  once super columns are removed. Most notably:  * QueryPath is removed. It was honestly already kind of useless with super columns but even  more so without them. It was also error-prone imho because some method that were taking  a QueryPath were actually ignoring everything except the columnFamilyName for instance.
I note that the class itself is not removed but kept only to simplify wire compatibility with  old nodes.
* IColumn and IColumnContainer are removed.
",,Architectural solution benefits and drawbacks,5:1182 - 5:1740,1,arjan
18:26,As far as testing goes:  * the unit tests pass more or less. There’s C…,CASSANDRA-3237,"As far as testing goes:  * the unit tests pass more or less. There’s CassandraServerTest that timeout on my box,  but it does so on trunk too (seems to be the JVM that don’t exit properly). And there’s  also a few serializationTest failing but it seems to be more related to the fact that the patch  bumps the messaging version up that anything else. I’ll look at that later.
* our old functional tests (in test/system) pass. Again, there is a few failure, but those are  test that are assuming CollatingOrderedPartitioner (apparently nobody ran those tests in a  while). Anyway, those tests test the thrift API for super columns fairly thorougly.
* you can now access super column family from CQL3.
* I’ve also (briefy) tested wire compatibily and that you can do super columns queries in a  mixed version cluster.
",,,5:1833 - 5:2652,1,arjan
18:27,"Regarding the CQL3 support, SCF for which column_metadata has been def…",CASSANDRA-3237,"Regarding the CQL3 support, SCF for which column_metadata has been defned on the  subcolumn are handled almost like sparse CF. The almost is because I’ve made sure we  don’t write row marker as in the case of sparse CF, cause that would break backward com-  patibility (there is no way to have a column with an empty name in a super column). For  the same reason, collection are not supported either.
",,Architectural design configuration,5:2653 - 5:3054,1,arjan
18:28,cause that would break backward com-  patibility (there is no way to h…,CASSANDRA-3237,"cause that would break backward com-  patibility (there is no way to have a column with an empty name in a super column). For  the same reason, collection are not supported either.
",,Architectural solution benefits and drawbacks,5:2873 - 5:3054,1,arjan
18:29,One small downside that I need to note is that during upgrade from 1.2…,CASSANDRA-3237,"One small downside that I need to note is that during upgrade from 1.2 to 2.0, there might  be a noticeable latency increase in super column queries. The reason is that any read query  that mix pre and post SC nodes will have a digest mismatch (and so will re-query with the  4
full data). Indeed, digest are not versioned and cannot really be (not easily at least).
",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:3055 - 6:90,2,arjan
18:30,"15. jbellis: Vijay, can you review? 16. vijay2win@yahoo.com: Will do t…",CASSANDRA-3237,"15. jbellis: Vijay, can you review?
16. vijay2win@yahoo.com: Will do thanks!
17. vijay2win@yahoo.com: Have been staring at the patch for a while now... :)  +1, LGTM (We should fx the test though).
",,,6:91 - 6:290,1,arjan
18:31,"Alright then, committed, thanks.",CASSANDRA-3237,"Alright then, committed, thanks.
",,,6:306 - 6:339,1,arjan
18:32,(I’ve fxed the serialization unit tests too),CASSANDRA-3237,(I’ve fxed the serialization unit tests too),,,6:340 - 6:383,1,arjan
18:33,"As an example, supposing I have an older schema with SuperColumns like…",CASSANDRA-3237,"As an example, supposing I have an older schema with SuperColumns like this:  1 ROWKEY:  2 SC1:  3 C1: val  4 C2: val  5 SC2:  6 C3: val  7 C4: val  With this schema I can query cassandra for ""the frst object in row ROWKEY"", which would  return:  1 SC1: (C1: val, C2: val)  It seems that converting this to CompositeType columns the schema would look like:  1 ROWKEY:  2 SC1:C1: val  3 SC1:C2: val  4 SC2:C3: val  5 SC2:C4: val  So using this converted schema, if I wanted to obtain the frst object of that row, it seems  that I would obtain:  1 SC1:C1: val  How is this converted so that compatibility is preserved?
",,,6:398 - 6:1015,1,arjan
18:49,slebresne,CASSANDRA-3237,slebresne,,Comment,6:1029 - 6:1037,1,arjan
18:34,Exactly the way you’ve described it. But the code also convert queries…,CASSANDRA-3237,"Exactly the way you’ve described it. But the code also convert queries on super columns, so  that the query that select the frst super column of a row still return all the super column,  not just the frst subcolumn.
",,Architectural design configuration,6:1103 - 6:1319,1,arjan
18:35,"Ah, great. But sorry to insist, it’s just that I’m trying to convert m…",CASSANDRA-3237,"Ah, great. But sorry to insist, it’s just that I’m trying to convert my schemas away  from SCF, and so I’m doing manually what this patch does automatically. I would like to  know how can I query this CompositeType model to obtain those SCF compatible results.
Can it be done with just one query?
Say, if I wanted the frst 2 SuperColumns, so I was expecting all SC1 and SC2 data, can I  query Cassandra for the frst 2 distinct values of the frst component of a CompositeType  column?
",,,7:13 - 7:499,1,arjan
18:50,slebresne,CASSANDRA-3237,slebresne,,Comment,7:519 - 7:527,1,arjan
18:36,"I’m afraid you cannot do *exactly* what the patch does, not at the mom…",CASSANDRA-3237,"I’m afraid you cannot do *exactly* what the patch does, not at the moment at least, because  said patch uses a way to count results that CQL3 uses and that is not exposed to thrift (see  CASSANDRA-4989).
",,,7:596 - 7:800,1,arjan
18:37,"I know there is a lot of ""don’t use super columns"" foating out there,…",CASSANDRA-3237,"I know there is a lot of ""don’t use super columns"" foating out there, but honestly on the  thrift side, the super column API is probably going to be more convenient if your use case  do map well to them. And while SC do have limitations like ’they are always deserialized in  their entirety’, this patch fxes a good part of them moving forward. Just saying.
",,Architectural solution benefits and drawbacks,7:868 - 7:1226,1,arjan
19:1,"Support collection (list, set, and map) value types in CQL",CASSANDRA-3647,"Support collection (list, set, and map) value types in CQL",,User requirement,3:52 - 3:109,1,arjan
19:2,Composite columns introduce the ability to have arbitrarily nested dat…,CASSANDRA-3647,Composite columns introduce the ability to have arbitrarily nested data in a Cassandra row. We  should expose this through CQL.,,Architectural design configuration,3:129 - 3:255,1,arjan
19:186,jbellis,CASSANDRA-3647,jbellis,,Comment,3:379 - 3:385,1,arjan
19:3,"Ed’s AnyType is useful here, since you really need ""self describing da…",CASSANDRA-3647,"Ed’s AnyType is useful here, since you really need ""self describing data"" for docu-  ments: CASSANDRA-3281",,Architectural design configuration,3:388 - 3:493,1,arjan
19:6,"since you really need ""self describing data"" for docu-  ments: CASSAND…",CASSANDRA-3647,"since you really need ""self describing data"" for docu-  ments: CASSANDRA-3281",,Architectural solution benefits and drawbacks,3:417 - 3:493,1,arjan
19:187,jbellis,CASSANDRA-3647,jbellis,,Comment,3:499 - 3:505,1,arjan
19:4,"Sylvain suggests we start with (non-nested) lists, maps, and sets. I a…",CASSANDRA-3647,"Sylvain suggests we start with (non-nested) lists, maps, and sets. I agree that this  is a great 80/20 approach to the problem (and does not prevent us from generalizing further  in the future).
",,Architectural design configuration,3:508 - 3:703,1,arjan
19:5,I agree that this  is a great 80/20 approach to the problem (and does…,CASSANDRA-3647,I agree that this  is a great 80/20 approach to the problem (and does not prevent us from generalizing further  in the future),,Architectural solution benefits and drawbacks,3:575 - 3:700,1,arjan
19:188,rbranson,CASSANDRA-3647,rbranson,,Comment,3:707 - 3:714,1,arjan
19:7,"I hate to gold plate here, but this feature is of marginal utility",CASSANDRA-3647," I hate to gold plate here, but this feature is of marginal utility",,Architectural solution benefits and drawbacks,3:716 - 3:782,1,arjan
19:8,"could be  implemented on-top of a UDF facility, similar to how Postgre…",CASSANDRA-3647,"could be  implemented on-top of a UDF facility, similar to how PostgreSQL supports XML and (in  9.2) JSON formats.
",,Other system architectural solutions,3:788 - 3:903,1,arjan
19:189,jbellis,CASSANDRA-3647,jbellis,,Comment,3:907 - 3:913,1,arjan
19:9,"If by ""this feature"" you mean the full document support in the title,…",CASSANDRA-3647," If by ""this feature"" you mean the full document support in the title, you could be  right.
",,Architectural solution benefits and drawbacks,3:915 - 3:1007,1,arjan
19:10,"If you mean the list and map types I propopsed, I disagree on both cou…",CASSANDRA-3647,"If you mean the list and map types I propopsed, I disagree on both counts. It’s very  useful for us to be able to denormalize maps or lists into a feld, instead of doing a client-side  join.",,Architectural solution benefits and drawbacks,3:1008 - 3:1197,1,arjan
19:11,The reason I want this fully supported instead of just a glorifed blob…,CASSANDRA-3647,"The reason I want this fully supported instead of just a glorifed blob is to do efcient  2
updates (appends/pops for lists, insert/deletes for maps).
",,Architectural tactics,3:1199 - 4:60,1,arjan
19:12,My quick googling suggests that postgresql gives you array_to_json and…,CASSANDRA-3647,"My quick googling suggests that postgresql gives you array_to_json and row_to_json,  which is fne as far as it goes but doesn’t accomplish the above. (Note that with their  array type, pg comes close to what I have in mind for the list type here.)",,Architectural solution benefits and drawbacks,4:61 - 4:307,1,arjan
19:13,"If it would be less confusing to move ""add map and list types"" to a se…",CASSANDRA-3647,"If it would be less confusing to move ""add map and list types"" to a separate ticket, that’s  fne.
",,,4:310 - 4:407,1,arjan
19:190,jjordan,CASSANDRA-3647,jjordan,,Comment,4:412 - 4:418,1,arjan
19:14,"For the maps/lists/sets, are you talking about a standard way of using…",CASSANDRA-3647,"For the maps/lists/sets, are you talking about a standard way of using composite  columns to implement them, or, a new column type that has a map/list/set inside one col-  umn, and new operations to work with them? Similar to counters?
",,Architectural component behavior and structure,4:421 - 4:657,1,arjan
19:15,I think this Issue started about having a standard way for CQL to stor…,CASSANDRA-3647,"I think this Issue started about having a standard way for CQL to store document at-  tributes in multiple columns using multiple columns and composites with slices to get/set  them.
",,"Assumptions
User requirement",4:658 - 4:841,2,arjan
19:16,So if you want to make a standard way of setting up composite columns…,CASSANDRA-3647,"So if you want to make a standard way of setting up composite columns for maps/list-  s/sets, I think this issue can be hi-jacked for that. If you want to add a new type of column  that supports redis like map/set/list operations, I would make a new issue.
",,,4:842 - 4:1099,1,arjan
19:191,jbellis,CASSANDRA-3647,jbellis,,Comment,4:1103 - 4:1109,1,arjan
19:17,"Well, it’s both. Because we do want the latter, but implemented as the…",CASSANDRA-3647,"Well, it’s both. Because we do want the latter, but implemented as the former.",,Architectural component behavior and structure,4:1372 - 4:1449,1,arjan
19:18,"So frst, we’re going to need to support heterogeneous comparators some…",CASSANDRA-3647,"So frst, we’re going to need to support heterogeneous comparators somehow. Consider  this table declaration:  1 CREATE TABLE foo (  2 id int PRIMARY KEY,  3 field1 text,  4 field2 map<int, text>,  5 field3 list<text>  6 );  The Cassandra CF containing these rows will contain single-level columns ({{feld1}}),  CT(ascii, int) ({{feld2}}), and CT(ascii, uuid) ({{feld3}}), assuming that we represent  lists with v1 uuid column names, which seems like the best option to me.
",,Architectural component behavior and structure,4:1583 - 4:2056,1,arjan
19:19,CASSANDRA-3657 gets us part of the way there (all CF column names will…,CASSANDRA-3647,"CASSANDRA-3657 gets us part of the way there (all CF column names will have the same  prefx, which is the CQL column name) but not all the way.
",,Architectural solution benefits and drawbacks,4:2057 - 4:2201,1,arjan
19:192,jbellis,CASSANDRA-3647,jbellis,,Comment,4:2205 - 4:2211,1,arjan
19:20,"The alternative is we say ""all maps, lists, and sets will be represent…",CASSANDRA-3647,"The alternative is we say ""all maps, lists, and sets will be represented as CT(ascii,  UTF8)"" and json-encode things",,Architectural component behavior and structure,4:2214 - 4:2329,1,arjan
19:21,"On the one hand, that’s horribly inefcient space-wise for  ints and uu…",CASSANDRA-3647,"On the one hand, that’s horribly inefcient space-wise for  ints and uuids. On the other hand, json support is high on the list of motivations here,  and that would simplify things a lot. ",,Architectural solution benefits and drawbacks,4:2332 - 4:2518,1,arjan
19:22,And if we used a library to represent utf8 as byte[]  3instead of Stri…,CASSANDRA-3647,"And if we used a library to represent utf8 as byte[]  3
instead of String, that would mitigate the overhead of representing as json by roughly 50%  for common usage.",,Architectural tactics,4:2520 - 5:109,1,arjan
19:193,jbellis,CASSANDRA-3647,jbellis,,Comment,5:116 - 5:122,1,arjan
19:23,"e.g., https://github.com/jruby/bytelist/blob/master/src/org/jruby/util…",CASSANDRA-3647,"e.g., https://github.com/jruby/bytelist/blob/master/src/org/jruby/util/ByteList.java",,Other system architectural solutions,5:186 - 5:269,1,arjan
19:194,slebresne,CASSANDRA-3647,slebresne,,Comment,5:275 - 5:283,1,arjan
19:24,"One option would be to write a separate, specifc, comparator that woul…",CASSANDRA-3647,"One option would be to write a separate, specifc, comparator that would basically be ’noth-  ing or map or list or whateverelsewelladd’. So typically the comparator for exemple above  would be: CompositeType(UTF8Type, NewShinyComparator). This avoids to mess with  the composite type itself.
",,Architectural component behavior and structure,5:528 - 5:820,1,arjan
19:25,This avoids to mess with  the composite type itself,CASSANDRA-3647,This avoids to mess with  the composite type itself,,Architectural solution benefits and drawbacks,5:767 - 5:817,1,arjan
19:26,"Going further, we could very well have a UnionType comparator that tak…",CASSANDRA-3647,"Going further, we could very well have a UnionType comparator that takes argument  and allow a component to be one of diferent comparator (it could use the same kind of  idea than DynamicCompositeType to diferenciate between diferent elements). So basi-  cally we would have: CompositeType(UTF8Type, UnionType(MapType(ÃĚsciiType), List-  Type(AsciiType))).
",,Architectural component behavior and structure,5:821 - 5:1178,1,arjan
19:27,I quite like that idea of composition of comparators. Typically Compos…,CASSANDRA-3647,"I quite like that idea of composition of comparators. Typically CompositeType with Union-  Type would be equivalent to DynamicCompositeType but with even more fexibility (as you  would be able to ’fx’ some of the component, which is useful (especially for us in CQL3)).
",,Architectural component behavior and structure,5:1179 - 5:1449,1,arjan
19:28,Typically CompositeType with Union-  Type would be equivalent to Dynam…,CASSANDRA-3647,"Typically CompositeType with Union-  Type would be equivalent to DynamicCompositeType but with even more fexibility (as you  would be able to ’fx’ some of the component, which is useful (especially for us in CQL3))",,Architectural solution benefits and drawbacks,5:1233 - 5:1446,1,arjan
19:195,chengas123,CASSANDRA-3647,chengas123,,Comment,5:1454 - 5:1463,1,arjan
19:29,I started using ElasticSearch to get massively scalable storage of nes…,CASSANDRA-3647,"I started using ElasticSearch to get massively scalable storage of nested JSON  documents. They accept smile (https://github.com/FasterXML/jackson-dataformat-smile)  as well, which I’ve found to be very nice. It’s a binary version of JSON, so it’s much faster  to encode/decode and more space efcient.
",,Other system architectural solutions,5:1466 - 5:1768,1,arjan
19:30,so it’s much faster  to encode/decode and more space efcient,CASSANDRA-3647,so it’s much faster  to encode/decode and more space efcient,,Architectural tactics,5:1706 - 5:1765,1,arjan
19:196,jbellis,CASSANDRA-3647,jbellis,,Comment,5:1773 - 5:1779,1,arjan
19:31,Maybe. Note that we never actually need to *compare* the diferent type…,CASSANDRA-3647,"Maybe. Note that we never actually need to *compare* the diferent types, since sub-  components of types X and Y will always have a diferent parent component. We just need  to *allow* them.
Also, whether the feld is a map/list/set is irrelevant for the purposes of the storage en-  gine. (All the operations I propose can be done as a single CT insert operation, without  read-before-write. Except for pop, which I didn’t think through and I withdraw.) So not  sure whether representing that as part of the Comparator is the right thing to do. That is,  QueryProcessor will need to know that some columns should be bundled together as a Map,  but ColumnFamilyStore and beneath won’t care.
",,Architectural component behavior and structure,5:1910 - 5:2600,1,arjan
19:197,jjordan,CASSANDRA-3647,jjordan,,Comment,5:2605 - 5:2611,1,arjan
19:32,"The list ops I think would be important are, being able to page throug…",CASSANDRA-3647,"The list ops I think would be important are, being able to page through X at a time (starting  from the front or back), push front, push back, and remove.
",,"Assumptions
User requirement",5:2680 - 5:2835,2,arjan
19:198,jbellis,CASSANDRA-3647,jbellis,,Comment,5:2840 - 5:2846,1,arjan
19:33,The crucial idea here is to provide *nested* collections for convenien…,CASSANDRA-3647,"The crucial idea here is to provide *nested* collections for convenience; if it’s so big you  need to page it, it probably belongs in a separate row. So paging is not on my short list to  start with.
",,Architectural component behavior and structure,5:2954 - 5:3154,1,arjan
19:34,"I also chose the word ""list"" over ""deque"" because I cannot think of a…",CASSANDRA-3647,"I also chose the word ""list"" over ""deque"" because I cannot think of a way to provide push-front  efciently (i.e., without read-before-write, and without update-all-existing-list-items). As I  mentioned in passing, we can provide append efciently by using v1 uuids as column names  (and translating to list indexes in QueryProcessor), but that doesn’t give us anything else  for ""free.""",,Architectural component behavior and structure,6:1 - 6:385,1,arjan
19:35,we can provide append efciently,CASSANDRA-3647,we can provide append efciently,,Architectural tactics,6:215 - 6:245,1,arjan
19:199,jjordan,CASSANDRA-3647,jjordan,,Comment,6:460 - 6:466,1,arjan
19:36,Can’t you just use negative timestamps? Or is the comparator doing an…,CASSANDRA-3647,"Can’t you just use negative timestamps? Or is the comparator doing an unsigned  compare?
",,Architectural component behavior and structure,6:469 - 6:558,1,arjan
19:200,jbellis,CASSANDRA-3647,jbellis,,Comment,6:563 - 6:569,1,arjan
19:37,"Well, uuids are better than timestamps since that means you won’t lose…",CASSANDRA-3647,"Well, uuids are better than timestamps since that means you won’t lose data if two  clients update at the same time.",,Architectural solution benefits and drawbacks,6:572 - 6:687,1,arjan
19:38,But we can pretend we’re using timestamps for simplicity  here. Suppos…,CASSANDRA-3647,"But we can pretend we’re using timestamps for simplicity  here. Suppose that we’re implementing feld3.pushbefore(), then. What should the negative  timestamp be?
",,,6:689 - 6:851,1,arjan
19:201,jjordan,CASSANDRA-3647,jjordan,,Comment,6:856 - 6:862,1,arjan
19:39,I meant setting the timestamp portion of the UUID to the negative of t…,CASSANDRA-3647,"I meant setting the timestamp portion of the UUID to the negative of the current  time. The timestamp portion of the UUID is how you are getting append/push back, correct?
feld3.pushback(a) -> feld3:1 : a  feld3.pushback(b) -> feld3:2 : b  feld3.pushfront(c) -> feld3:-3 : c  feld3.pushfront(d) -> feld3:-4 : d  feld3.pushback(e) -> feld3:5 : e  Gives you:  (-4, d), (-3, c), (1, a), (2, b), (5, e)",,Architectural component behavior and structure,6:865 - 6:1263,1,arjan
19:202,jbellis,CASSANDRA-3647,jbellis,,Comment,6:1270 - 6:1276,1,arjan
19:40,"Ah, good idea. That should actually work fne. For UUIDs we’d need to p…",CASSANDRA-3647,"Ah, good idea. That should actually work fne. For UUIDs we’d need to pick some  point in time as ""zero"" and then subtract from that, since there is no such thing as a neg-  ative time in that context, but that’s a minor wrinkle and doesn’t matter for the purposes  of the list, since the uuid contents are an implementation detail as far as the user is concerned.
",,Architectural component behavior and structure,6:1279 - 6:1643,1,arjan
19:203,slebresne,CASSANDRA-3647,slebresne,,Comment,6:1648 - 6:1656,1,arjan
19:41,"True, but I guess that was the UnionType part of it, whose goal is to…",CASSANDRA-3647,"True, but I guess that was the UnionType part of it, whose goal is to allow that. For  MapType and ListType, I agree they don’t add much in term of comparison, but I still  think it *may* be a good idea to declare them, even if they are just alias (like ListType  would be an alias for UUIDType), just so that map-reduce and other external tool know that  we meant a list, not a uuid, by just looking at the comparator (could be handy for debugging  too). But I’m probably getting carried away, those are implementation details and may or  may not be feasible/desireable. My point was that as far as supporting internally whatever  encoding we chose, adding a UnionType would be an option (one I like more than a json  encoding personally), and that’s fairly trivial to write.
",,Architectural component behavior and structure,6:1841 - 6:2618,1,arjan
19:42,"but I still  think it *may* be a good idea to declare them, even if th…",CASSANDRA-3647,"but I still  think it *may* be a good idea to declare them, even if they are just alias (like ListType  would be an alias for UUIDType), just so that map-reduce and other external tool know that  we meant a list, not a uuid, by just looking at the comparator (could be handy for debugging  too).",,"Architectural solution benefits and drawbacks
Assumptions",6:2001 - 6:2295,2,arjan
19:43,"Of course  there is the approach of returning a json string, which I’l…",CASSANDRA-3647,"Of course  there is the approach of returning a json string, which I’ll admit I’m not a super fan because  1) it’s only convenient for those that wants json and 2) it feels at odd with our current API  that is not json at all.
",,Architectural component behavior and structure,6:2796 - 6:3023,1,arjan
19:44,1) it’s only convenient for those that wants json and 2) it feels at o…,CASSANDRA-3647,1) it’s only convenient for those that wants json and 2) it feels at odd with our current API  that is not json at all.,,Architectural solution benefits and drawbacks,6:2903 - 6:3021,1,arjan
19:204,jbellis,CASSANDRA-3647,jbellis,,Comment,6:3028 - 6:3034,1,arjan
19:45,"Well, the ResultSet isn’t written in stone itself; it’s always been ki…",CASSANDRA-3647,"Well, the ResultSet isn’t written in stone itself; it’s always been kind of a placeholder  pending CASSANDRA-2478.",,Existing system architecture description,6:3037 - 6:3150,1,arjan
19:46,Our custom transport could represent the entire resultset in  json (or…,CASSANDRA-3647,"Our custom transport could represent the entire resultset in  json (or Smile) if we want, which is the approach unql appears to take: http://www.unqlspec.org/display/UnQL/Exa",,Other system architectural solutions,6:3152 - 6:3325,1,arjan
19:47,"Alternatively, we could use a more compact, custom format leveraging t…",CASSANDRA-3647,"Alternatively, we could use a more compact, custom format leveraging the fact that we  know the types involved (and thus don’t need to implicitly encode those in an inefcient  representation), e.g. for Map number of entries followed by key/value pairs in native binary  format.
",,Architectural component behavior and structure,7:188 - 7:465,1,arjan
19:48,and thus don’t need to implicitly encode those in an inefcient  repres…,CASSANDRA-3647,and thus don’t need to implicitly encode those in an inefcient  representation,,Architectural solution benefits and drawbacks,7:300 - 7:377,1,arjan
19:205,slebresne,CASSANDRA-3647,slebresne,,Comment,7:471 - 7:479,1,arjan
19:49,But handling  lists and maps should feel natural in pretty much any la…,CASSANDRA-3647,But handling  lists and maps should feel natural in pretty much any language,,Architectural solution benefits and drawbacks,7:635 - 7:710,1,arjan
19:206,tjake,CASSANDRA-3647,tjake,,Comment,7:736 - 7:740,1,arjan
19:50,"Also, hive supports complex types we could model this after... https:/…",CASSANDRA-3647,"Also, hive supports complex types we could model this after... https://cwiki.apache.org/confuence/display/H  ComplexTypes",,Other system architectural solutions,7:743 - 7:863,1,arjan
19:207,jbellis,CASSANDRA-3647,jbellis,,Comment,7:870 - 7:876,1,arjan
19:53,Not sure that we can really support lists meaningfully,CASSANDRA-3647,Not sure that we can really support lists meaningfully,,Architectural solution benefits and drawbacks,7:919 - 7:972,1,arjan
19:51,"[Sorted] sets is a much clearer  mapping to C*, i.e., people don’t exp…",CASSANDRA-3647,"[Sorted] sets is a much clearer  mapping to C*, i.e., people don’t expect to be able to write ""set[3] = foo"" and have some  magic index -> column name mapping happen.
",,Architectural component behavior and structure,7:975 - 7:1142,1,arjan
19:52,is a much clearer  mapping to C*,CASSANDRA-3647, is a much clearer  mapping to C*,,Architectural solution benefits and drawbacks,7:988 - 7:1020,1,arjan
19:54,"Also, another source of prior art is http://www.postgresql.org/docs/9.…",CASSANDRA-3647,"Also, another source of prior art is http://www.postgresql.org/docs/9.1/static/hstore.html.
I like the use of the || operator for concatenation, but I’m not sure why they invented this  whacky one-of syntax for maps instead of using json. Is there a good reason I don’t see why  json conficts with SQL? Or did the person who wrote it just like the old Ruby hash syntax  (which, I note that Ruby deprecated because it’s so cumbersome)?
",,Other system architectural solutions,7:1143 - 7:1578,1,arjan
19:208,jbellis,CASSANDRA-3647,jbellis,,Comment,7:1584 - 7:1590,1,arjan
19:55,I think I’m leaning back towards supporting lists again. While we can’…,CASSANDRA-3647,"I think I’m leaning back towards supporting lists again. While we can’t do random-access  against lists, none of the document databases out there do either; fetching L[3] fetches all of  L, and updating L[3] = foo rewrites all of L.
",,"Architectural solution benefits and drawbacks
Assumptions",7:1653 - 7:1886,2,arjan
19:56,And having syntactic sugar for a Map whose keys are timeuuids is just…,CASSANDRA-3647,"And having syntactic sugar for a Map whose keys are timeuuids is just very useful syn-  tactic sugar.
",,Architectural solution benefits and drawbacks,7:1887 - 7:1988,1,arjan
19:57,So if we make this explicit -- that the operations allowed are simply…,CASSANDRA-3647,"So if we make this explicit -- that the operations allowed are simply appending, fetching  the entire list, and overwriting the entire list (which we can do by writing a composite  tombstone, plus the new list items) then I think we’re in good shape.
",,Architectural component behavior and structure,7:1990 - 7:2241,1,arjan
19:58,then I think we’re in good shape,CASSANDRA-3647,then I think we’re in good shape,,"Architectural solution benefits and drawbacks
Assumptions",7:2207 - 7:2238,2,arjan
19:209,jbellis,CASSANDRA-3647,jbellis,,Comment,7:2246 - 7:2252,1,arjan
19:59,"One possible syntax, allowing append/add/put for list/set/map and full…",CASSANDRA-3647,"One possible syntax, allowing append/add/put for list/set/map and full overwrites.
For set and map we can additionally support removal. (I’ve called this operation {{discard}}  after the Python Set method for ""remove an item if it exists, otherwise do not complain,""  but alternatives are reasonable.)  1 CREATE TABLE foo(  2 k uuid PRIMARY KEY,  3 L list<int>,  4 M map<text, int>,  5 S set<int>  6 );  7 8  UPDATE foo SET L = L.append(1) WHERE k = ’b017f48f-ae67-11e1-9096-005056c00008’;  9 UPDATE foo SET L = ’[2, 3]’ WHERE ... ; -- do we need/want to require quoting?
6
10 UPDATE foo SET S = S.add(1) WHERE ... ;  11 UPDATE foo SET S = ’{2, 3}’ WHERE ... ; -- JSON does not define a set type or  syntax. th  12 is is Python’s syntax for set literals  13 UPDATE foo SET S = S.discard(2) WHERE ... ;  14 UPDATE foo SET M = M.put(’ocd’, 1) WHERE ... ;  15 UPDATE foo SET M = ’{""cod"": 2, ""dog"": 3}’ WHERE ... ; -- note double quotes forced  if we require quoting the map literal  16 UPDATE foo SET M = M.discard(’cod’) WHERE ... ;",,Architectural component behavior and structure,7:2255 - 8:456,1,arjan
19:210,jbellis,CASSANDRA-3647,jbellis,,Comment,8:463 - 8:469,1,arjan
19:60,This will allow ripping out the clunky pseudo-map support we have for…,CASSANDRA-3647,"This will allow ripping out the clunky pseudo-map support we have for strat-  egy_options et al.
",,Architectural solution benefits and drawbacks,8:472 - 8:569,1,arjan
19:211,slebresne,CASSANDRA-3647,slebresne,,Comment,8:574 - 8:582,1,arjan
19:61,"I will have a closer look, but I think we can avoid having to quote th…",CASSANDRA-3647," I will have a closer look, but I think we can avoid having to quote the literals  (it doesn’t confict with any of our current literals), which will look cleaner.
",,"Architectural component behavior and structure
Assumptions",8:584 - 8:747,2,arjan
19:212,slebresne,CASSANDRA-3647,slebresne,,Comment,8:752 - 8:760,1,arjan
19:62,"This pretty much implement the syntax of Jonathan’s comment above, exc…",CASSANDRA-3647,"This pretty much implement the syntax of Jonathan’s comment above, except that  literals must not be quoted. Supported methods are:  * maps: put and discard.
* sets: add, add_all (takes n arguments) and discard.
* lits: append, append_all, prepend, prepend_all, set (to set the value at a specifc index),  discard (discard an object given its value) and discard_idx (discard given the index).
The implementation for maps and set is rather straighforward. Lists are implemented as  a map of TimeUUID -> value. Prepend is supported by the trick described in the previ-  ous comments of picking a reference time (1 january 2010 as it turns out) and using that  reference minus now as a timestamp. The list method set, discard and discard_idx share  in common that they do a read-before-write (we read the whole list to fnd the TimeUUID  corresponding to the element to update; we then write that element (I don’t think we need  to overwrite the entire list at all)).
Another detail worth mentioning is literals. When setting a literal we must erase the previous  list. To do so, the implementation insert a (range) tombstone at ’timestamp - 1’. This have  the unfortunate consequence that if you do 2 update with a literal in the same millisecond,  you won’t end up with one or the other, but rather as a merge of both literals. I don’t see  a good way how to do otherwise.
As of these patches, collections (lists/maps/sets) are limited to table defnition that use  a composed PRIMARY KEY. The reason is that otherwise the underlying comparator is  not a composite one, and thus there is no way to support the collection. I very strongly  think that we should change this behavior and I’ve opened CASSANDRA-4329 for that. But  besides this limitation, these patches are ready for review and I’ve pushed a few tests those  in dtests (in cql_tests.py).
",,Architectural component behavior and structure,8:842 - 8:2695,1,arjan
19:213,slebresne,CASSANDRA-3647,slebresne,,Comment,8:2700 - 8:2708,1,arjan
19:63,Currently the result to a query is returned to thrift as JSON (so as a…,CASSANDRA-3647,"Currently the result to a query is returned to thrift as JSON (so as a string in JSON  format). For sets, it actually returns a list since json has no support of sets.
Also, the only supported way to query is to query for the full list/map/set.",,Architectural component behavior and structure,8:2743 - 8:2987,1,arjan
19:64,"I suppose  that we could later had more ways to query, like:  SELECT L…",CASSANDRA-3647,"I suppose  that we could later had more ways to query, like:  SELECT L[1] FROM ...; -- select list element by index  SELECT M[""foo""] FROM ...; -- select specific map elements  7
SELECT S[""a"":""z""] FROM ...; -- select a slice of a set (since after  all our sets and maps are sorted)  But none of this is implemented yet (and I’m keen on pushing that to a follow up ticket).",,Architectural component behavior and structure,8:2989 - 9:193,1,arjan
19:214,jbellis,CASSANDRA-3647,jbellis,,Comment,9:200 - 9:206,1,arjan
19:65,Could we do this instead of put/set? (Do we want to?)  UPDATE foo SET…,CASSANDRA-3647,"Could we do this instead of put/set? (Do we want to?)  UPDATE foo SET M[ocd] = 1 WHERE ... ;  UPDATE foo SET L[0] = 1 WHERE ... ;  UNQL uses dot notation ({{SET M.odc = 1}}) but gives no examples of similar sugar  for arrays, which leads me to infer that arrays can only be modifed as an entire literal at  once.
",,Architectural component behavior and structure,9:240 - 9:553,1,arjan
19:66,What if we introduced the convention that using the + operator updates…,CASSANDRA-3647,"What if we introduced the convention that using the + operator updates the list/set/map?
That is,  SET L = L + [2, 3]  SET S = S + {4, 5}  SET M = M + {’asdf’: 6, ’fdsa’: 7}  If we combined this with the [] syntax for setting a single item, that would just leave us  with discard to solve and we wouldn’t need this somewhat clunky ""method call"" syntax.
",,Architectural component behavior and structure,9:567 - 9:921,1,arjan
19:67,"we wouldn’t need this somewhat clunky ""method call"" syntax",CASSANDRA-3647,"we wouldn’t need this somewhat clunky ""method call"" syntax",,Architectural solution benefits and drawbacks,9:861 - 9:918,1,arjan
19:68,Maybe some extension to DELETE?,CASSANDRA-3647,"Maybe some extension to DELETE?
",,"Architectural component behavior and structure
Assumptions",9:922 - 9:954,2,arjan
19:215,jbellis,CASSANDRA-3647,jbellis,,Comment,9:959 - 9:965,1,arjan
19:69,but I guess 1.2 will  still be a net win in that respect if we cut out…,CASSANDRA-3647,but I guess 1.2 will  still be a net win in that respect if we cut out supercolumns. :),,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",9:1183 - 9:1269,3,arjan
19:70,"IMO this is a Good Thing, we don’t want to encourage people stufng the…",CASSANDRA-3647,"IMO this is a Good Thing, we don’t want to encourage people stufng their entire model  into a single row since that breaks our partitioning assumptions.
",,Architectural solution benefits and drawbacks,9:1347 - 9:1500,1,arjan
19:216,jbellis,CASSANDRA-3647,jbellis,,Comment,9:1505 - 9:1511,1,arjan
19:71,DELETE L[0] FROM foo WHERE ... DELETE M[’asdf’] FROM foo WHERE ... 8DE…,CASSANDRA-3647,"DELETE L[0] FROM foo WHERE ...
DELETE M[’asdf’] FROM foo WHERE ...
8
DELETE S[4] FROM foo WHERE ...
",,Architectural component behavior and structure,9:1551 - 10:32,1,arjan
19:217,slebresne,CASSANDRA-3647,slebresne,,Comment,10:40 - 10:48,1,arjan
19:72,That’s defnitively an option. One drawback I can think of is that I do…,CASSANDRA-3647,"That’s defnitively an option. One drawback I can think of is that I don’t see how to support  both the {{discard}} and {{discard_idx}} methods for lists (at least for {{list<int>}}),  while the clunkier ""method call"" syntax has no problem with that",,Architectural solution benefits and drawbacks,10:235 - 10:482,1,arjan
19:73,I would almost agree that  we could ofer only {{discard_idx}} with no…,CASSANDRA-3647,"I would almost agree that  we could ofer only {{discard_idx}} with no special syntax for {{discard}}, if it wasn’t for  the fact that users can’t implement {{discard}} as well as we can (because even if they do  a read, they won’t have access to the underlying TimeUUID, and thus would risk to remove  the wrong element if there is concurrent update/delete).",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",10:485 - 10:842,2,arjan
19:74,"I’m not sure I’m convinced by that syntax for sets, as this reuse a ve…",CASSANDRA-3647,"I’m not sure I’m convinced by that syntax for sets, as this reuse a very standard notation  for something not standard at all (and I know I suggested a similar for slice for sets above,  but upon further refexion I don’t like it). It’s also related to the {{discard/discard_idx}}  problem above since if we fnd a ""better"" syntax for sets, we can reuse it for the discard of  lists.",,"Architectural solution benefits and drawbacks
Assumptions",10:997 - 10:1377,2,arjan
19:75,"That being said, I don’t have a clearly perfect idea. One suggestion w…",CASSANDRA-3647,"That being said, I don’t have a clearly perfect idea. One suggestion would be to use  brackets instead of square brackets, just to make it clear that it selects a value (so DELETE  S{4} FROM ...).
",,Architectural component behavior and structure,10:1379 - 10:1576,1,arjan
19:77,I absolutely agree and I’m certainly not saying it’s not a problem. It…,CASSANDRA-3647,I absolutely agree and I’m certainly not saying it’s not a problem. It’s just that I don’t  have a solution to that problem,,Architectural solution benefits and drawbacks,10:1652 - 10:1774,1,arjan
19:76,"outside of removing the possibility to ""set"" a literal at all  (which…",CASSANDRA-3647,"outside of removing the possibility to ""set"" a literal at all  (which maybe is the right solution).
",,Architectural component behavior and structure,10:1777 - 10:1877,1,arjan
19:218,slebresne,CASSANDRA-3647,slebresne,,Comment,10:1882 - 10:1890,1,arjan
19:78,"During the discussions on CASSANDRA-2474, some syntax that were propos…",CASSANDRA-3647,"During the discussions on CASSANDRA-2474, some syntax that were proposed  seemed to be a problem for hive. Is there some related problem here? (I have no clue and  maybe we don’t care, just remembered those previous discussions and fgured it’s worth  asking).
",,"Architectural solution benefits and drawbacks
Assumptions",10:1893 - 10:2153,2,arjan
19:219,jbellis,CASSANDRA-3647,jbellis,,Comment,10:2158 - 10:2164,1,arjan
19:79,"I’d argue that if you cared more about the value than the ordering, yo…",CASSANDRA-3647,"I’d argue that if you cared more about the value than the ordering, you should be using a Set  instead. And our Sets are inherently ordered (by value), which obviates one of the reasons  to use a List when you really mean a Set in many languages.
",,Architectural solution benefits and drawbacks,10:2220 - 10:2467,1,arjan
19:80,"I’m not sure I follow, what else would S[4] mean? That is: I’m okay wi…",CASSANDRA-3647,"I’m not sure I follow, what else would S[4] mean? That is: I’m okay with being non-  standard, as long as it’s not ambiguous.
",,Architectural solution benefits and drawbacks,11:1 - 11:127,1,arjan
19:220,liorgo2,CASSANDRA-3647,liorgo2,,Comment,11:239 - 11:245,1,arjan
19:81,Talking about Hive - a question about how you envision Lists/Sets/Maps…,CASSANDRA-3647,"Talking about Hive - a question about how you envision Lists/Sets/Maps and Hive  integration: Will it be possible to perform a hive query that ""joins"" against any/all values  in a List/Set/Map?
For example let’s say I have the following column families:  1. Users CF - with row key = user id and a ""groups"" column for the Set of groups the  user belongs to  2. Groups CF - with row key = group id and a ""name"" column for group name  And let’s say I want to have a query for the number of users per group (name). In a  relational database this would be supported by factoring the relationship between users and  groups to a 3rd table (""users_groups""), and performing an inner join between groups and  users_groups, grouping by groups.name.
How will this be supported in Hive (over Cassandra) if the mapping between users and  groups is stored as a single ""Set"" column in the users CF?
",,User requirement,11:248 - 11:1134,1,arjan
19:221,jbellis,CASSANDRA-3647,jbellis,,Comment,11:1139 - 11:1145,1,arjan
19:82,https://cwiki.apache.org/confuence/display/Hive/Tutorial#Tutorial-Arra…,CASSANDRA-3647,"https://cwiki.apache.org/confuence/display/Hive/Tutorial#Tutorial-ArrayOperations  and https://cwiki.apache.org/confuence/display/Hive/Tutorial#Tutorial-ComplexTypes says  that Hive is okay with using the [] operator in SELECT. (Presumably also for UPDATE?
this is not explicitly shown.)",,Existing system architecture description,11:1148 - 11:1435,1,arjan
19:83,"Hive does not appear to have a collection literal syntax, we might nee…",CASSANDRA-3647,"Hive does not appear to have a collection literal syntax, we might need to add quotes to  ours to make it happy with that.
",,Architectural component behavior and structure,11:1438 - 11:1561,1,arjan
19:84,"Hive adds a size(collection) method, which makes sense. Hive does not…",CASSANDRA-3647,"Hive adds a size(collection) method, which makes sense.
Hive does not support Sets.
Hive’s syntax for CREATEing is the same as ours, except that Hive uses ""array"" instead  of ""list.""",,Existing system architecture description,11:1562 - 11:1745,1,arjan
19:85,PostgreSQL’s is diferent (http://www.postgresql.org/docs/9.1/static/ar…,CASSANDRA-3647,"PostgreSQL’s is diferent (http://www.postgresql.org/docs/9.1/static/arrays.html) and closer  to the SQL standard (http://farrago.sourceforge.net/design/CollectionTypes.html) which  however requires specifying an array size up front. There doesn’t seem to be any precedent  here for Maps, and the Multiset [set of tuples] syntax is terrible.
",,Existing system architecture description,11:1748 - 11:2089,1,arjan
19:86,Personally I’d lean towards keeping the <> syntax for all types. Ambiv…,CASSANDRA-3647,Personally I’d lean towards keeping the <> syntax for all types. Ambivalent on renam-  ing list to array for better Hive compatibility,,Architectural solution benefits and drawbacks,11:2090 - 11:2223,1,arjan
19:87,"I think ""list"" is better, but maybe not enough  better to justify the…",CASSANDRA-3647,"I think ""list"" is better, but maybe not enough  better to justify the incompatibility.
",,Trade-offs,11:2226 - 11:2313,1,arjan
19:222,slebresne,CASSANDRA-3647,slebresne,,Comment,11:2318 - 11:2326,1,arjan
19:88,"Ok, but what if you care a little bit of both. Or even if you started…",CASSANDRA-3647,"Ok, but what if you care a little bit of both. Or even if you started with a list because  you though that it was what you wanted but end up using it like a set and don’t want to  10
migrate data. I mean, I’m playing devil’s advocate here and I’m not pretending those are  very common case, but I do have a problem with limiting the supported features ""because  we can’t come up with a nice syntax for it"".",,Architectural solution benefits and drawbacks,11:2438 - 12:223,1,arjan
19:89,"That being, I mentioned that ""problem"" because  it came to mind but we…",CASSANDRA-3647,"That being, I mentioned that ""problem"" because  it came to mind but we can always keep the ""method syntax"" for those methods for which  we don’t have a better alternative.
",,Architectural component behavior and structure,12:225 - 12:397,1,arjan
19:90,"I’m not saying it’s ambiguous, I’m saying there is maybe better.",CASSANDRA-3647,"I’m not saying it’s ambiguous, I’m saying there is maybe better. ",,Architectural solution benefits and drawbacks,12:505 - 12:569,1,arjan
19:91,The square bracket notation  for lists and maps is use to select a val…,CASSANDRA-3647,"The square bracket notation  for lists and maps is use to select a value by key and you can use it to set the value for that  key too. This is not really what this would does for sets, as it would rather select a provided  value in the set. So I submit that maybe not reusing the square bracket notation may end  up being clearer. ",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",12:570 - 12:900,2,arjan
19:92,But this also boils down to the list discard thing. I disagree we shou…,CASSANDRA-3647,"But this also boils down to the list discard thing. I disagree we shouldn’t  have a discard for lists, and as it happens DELETE S[’foo’] would be exactly the equivalent  of L.discard(’foo’) (where S is a set and L a list), so it feels wrong to reuse the syntax that  for list does discard_idx, not discard.
",,Architectural solution benefits and drawbacks,12:901 - 12:1208,1,arjan
19:223,jbellis,CASSANDRA-3647,jbellis,,Comment,12:1530 - 12:1536,1,arjan
19:93,"Fair point, but I feel like a Set is more like a Map with no value, th…",CASSANDRA-3647,"Fair point, but I feel like a Set is more like a Map with no value, than a List with no  indexes. :)",,Architectural solution benefits and drawbacks,12:1610 - 12:1709,1,arjan
19:224,slebresne,CASSANDRA-3647,slebresne,,Comment,12:1716 - 12:1724,1,arjan
19:94,"Ok, let me rephrase a bit my argumentation. # The frst point is that ""…",CASSANDRA-3647,"Ok, let me rephrase a bit my argumentation.
# The frst point is that ""S[4]"" for sets is not a standard notation at all. That doesn’t mean  we cannot use it (there is no standard notation for that kind of operation that I know of  anyway), but that does mean that another notation would be equaly good. And not reusing  a very standard notation for something new could actually be a good point: I’ve learned that  we don’t all have the same intuition when it comes to syntax, and I would halfway expect  some people to think that S[4] actually means ""the 4th elements of the (sorted) set S"".
# Then there is the fact that we don’t have a syntax for List.discard and I do think there is  no good reason not to support it (not having a syntax is defnitely not a good reason as far  as I’m concerned; I prefer supporting it with a slightly ugly syntax than none at all). And  the thing is, List.discard is very much the same operation than Set.discard, or at least it’s  much closer in semantic than List.discard_idx is of Set.discard. So inventing a syntax for  both List.discard and Set.discard would be coherent.
",,Architectural solution benefits and drawbacks,12:1829 - 12:2943,1,arjan
19:95,So the notation I’m suggesting is to use curly brackets instead of squ…,CASSANDRA-3647,"So the notation I’m suggesting is to use curly brackets instead of square ones, so S{4}.
The meaning of such would be to ’select the value 4 in the set S if present’.",,Architectural component behavior and structure,12:2944 - 12:3110,1,arjan
19:96,I will note that supporting such notation with that meaning would for…,CASSANDRA-3647,"I will note that supporting such notation with that meaning would for example allow us, if  we so wish, to support ""SELECT S{4} ..."" as a simple way to test the existence of 4 in S  (I’m not saying we need to support that, but at least I think it is a bit early to say we will  never support such thing). Lastly, not reusing the square bracket notation will make it clear  11
that ""SET S[4] = 3"" would be non-sensical (if S is a set).
",,Architectural solution benefits and drawbacks,12:3113 - 13:60,1,arjan
19:225,ardot,CASSANDRA-3647,ardot,,Comment,13:65 - 13:69,1,arjan
19:97,"Why isn’t the discard syntax as simple as:  1 SET L = L - [2, 3]  2 SE…",CASSANDRA-3647,"Why isn’t the discard syntax as simple as:  1 SET L = L - [2, 3]  2 SET S = S - {4, 5}  3 SET M = M - {’asdf’}  I assume BTW that braces (""["") are signifying a _position_ in an ordered list, and Brackets  (""{"") are signifying a _value_ (or label) and not a position.
",,Architectural component behavior and structure,13:72 - 13:339,1,arjan
19:99,as simple as,CASSANDRA-3647,as simple as,,Architectural solution benefits and drawbacks,13:101 - 13:112,1,arjan
19:226,jbellis,CASSANDRA-3647,jbellis,,Comment,13:344 - 13:350,1,arjan
19:98,I like it!,CASSANDRA-3647,"I like it!
",,Architectural solution benefits and drawbacks,13:406 - 13:417,1,arjan
19:100,"That’s reasonable, but then you still have the problem of Maps that do…",CASSANDRA-3647,"That’s reasonable, but then you still have the problem of Maps that don’t really ft ei-  ther of those. And like I said, a Set feels more like a Map-without-values to me, than like a  List-without-indexes.
",,Architectural solution benefits and drawbacks,13:573 - 13:779,1,arjan
19:227,slebresne,CASSANDRA-3647,slebresne,,Comment,13:784 - 13:792,1,arjan
19:101,"Are you suggesting that  SET L = L - [2, 3]  means removing position 2…",CASSANDRA-3647,"Are you suggesting that  SET L = L - [2, 3]  means removing position 2 and 3?",,"Architectural component behavior and structure
Assumptions",13:950 - 13:1026,2,arjan
19:102,Because intuitively I really expect that syntax to re-  move value 2 a…,CASSANDRA-3647,"Because intuitively I really expect that syntax to re-  move value 2 and 3. And I’m fne with that syntax for List.discard() btw, but I just want  to be clear we agree here.
",,Architectural solution benefits and drawbacks,13:1028 - 13:1201,1,arjan
19:103,But if you mean to use ’-’ for discard (of list and sets) and keep the…,CASSANDRA-3647,"But if you mean to use ’-’ for discard (of list and sets) and keep the ""DELETE L[4]"" for the  discard_idx (for list) and discard_by_key (for map), then I’m good with that.
",,Architectural solution benefits and drawbacks,13:1202 - 13:1373,1,arjan
19:228,jbellis,CASSANDRA-3647,jbellis,,Comment,13:1379 - 13:1385,1,arjan
19:104,"Me, too. [x, y] as ""list of x and y"" is well-established.",CASSANDRA-3647,"Me, too. [x, y] as ""list of x and y"" is well-established.
",,Architectural solution benefits and drawbacks,13:1457 - 13:1515,1,arjan
19:229,ardot,CASSANDRA-3647,ardot,,Comment,13:1520 - 13:1524,1,arjan
19:105,"I think ""DELETE L[4]"" makes sense for removing a list item by position…",CASSANDRA-3647,"I think ""DELETE L[4]"" makes sense for removing a list item by position (in this context).
",,Architectural solution benefits and drawbacks,13:1718 - 13:1808,1,arjan
19:106,"But I think in its Map context,  1 SET M = M - {’asdf’}  2 SET M = M -…",CASSANDRA-3647,"But I think in its Map context,  1 SET M = M - {’asdf’}  2 SET M = M - {’asdf’, ’ghkl’}  seems appropriate to discard a Map entry by label.
I don’t see any reason to remove map entries by position?
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",14:1 - 14:199,2,arjan
19:230,slebresne,CASSANDRA-3647,slebresne,,Comment,14:205 - 14:213,1,arjan
19:107,I’ve rebased and changed the syntax to match what’s above. The new bra…,CASSANDRA-3647,"I’ve rebased and changed the syntax to match what’s above. The new branch  is at https://github.com/pcmanus/cassandra/commits/3647-2.
",,,14:216 - 14:350,1,arjan
19:108,"To sum up the new syntax:  * lists:  UPDATE L = L + [ ’a’ , ’b’ ] WHER…",CASSANDRA-3647,"To sum up the new syntax:  * lists:  UPDATE L = L + [ ’a’ , ’b’ ] WHERE ... // Appends to list  UPDATE L = [ ’a’ , ’b’ ] + L WHERE ... // Prepends to list  UPDATE L[1] = ’c’ WHERE ... // Sets by idx  UPDATE L = L - [ ’a’, ’b’ ] WHERE ... // Remove all occurences of value  ’a’ and ’b’ in list  DELETE L[1] WHERE ... // Deletes by idx  * sets:  UPDATE S = S + { ’a’, ’b’ } WHERE ... // Adds to set  UPDATE S = S - { ’a’, ’b’ } WHERE ... // Remove values ’a’ and ’b’ from  set  * maps:  UPDATE M[’a’] = ’c’ WHERE ... // Put key,value  UPDATE M = M + { ’a’ : ’c’ } WHERE ... // Equivalent to previous  DELETE M[’a’] WHERE ... // Remove value for key ’a’",,Architectural component behavior and structure,14:351 - 14:1000,1,arjan
19:109,* We could rename list -> array. I fgured one reason to keep list coul…,CASSANDRA-3647,* We could rename list -> array. I fgured one reason to keep list could be to emphasize  that there is no predefned size.,,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",14:1019 - 14:1139,2,arjan
19:110,But I’m good with array.,CASSANDRA-3647,"But I’m good with array.
",,Architectural solution benefits and drawbacks,14:1141 - 14:1166,1,arjan
19:111,"There is no support, for maps, of  UPDATE M = M - { ’a’ : ’c’ } WHERE…",CASSANDRA-3647,"There is no support, for maps, of  UPDATE M = M - { ’a’ : ’c’ } WHERE ...
or some other syntax to remove a element of a map by value. The reason is that I don’t  13
think we can implement that correctly due to concurrency.
",,Architectural solution benefits and drawbacks,14:1169 - 15:59,1,arjan
19:231,jbellis,CASSANDRA-3647,jbellis,,Comment,15:64 - 15:70,1,arjan
19:112,"The read-before-write operations on list concern me, since we’ve avoid…",CASSANDRA-3647,"The read-before-write operations on list concern me, since we’ve avoided these op-  erations thus far (e.g., {{UPDATE foo SET x=y WHERE w=z}})",,Architectural solution benefits and drawbacks,15:73 - 15:214,1,arjan
19:113,I’ve been a fan of the  status quo since forcing the client to do the…,CASSANDRA-3647,"I’ve been a fan of the  status quo since forcing the client to do the read explicitly makes it clear that you’re per-  forming a race-prone sequence. Yes, it’s less efcient, but in most cases the cost of doing  random reads dwarfs the round-trip overhead.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",15:217 - 15:473,2,arjan
19:114,I’d also note that to my knowledge no other implementation of document…,CASSANDRA-3647,"I’d also note that to my knowledge no other implementation of documents or containers  allows efcient updates of individual items. If we force the user to fetch the list, then over-  write the entire list with the desired items removed, we’re no worse than the competition. :)",,"Architectural solution benefits and drawbacks
User requirement",15:474 - 15:749,2,arjan
19:115,Am I of base? Is it time to embrace the race and add this kind of serv…,CASSANDRA-3647,"Am I of base? Is it time to embrace the race and add this kind of server-side sugar?
",,,15:752 - 15:837,1,arjan
19:232,slebresne,CASSANDRA-3647,slebresne,,Comment,15:842 - 15:850,1,arjan
19:116,I suppose it might depends on the defnition of race-prone but I would…,CASSANDRA-3647,"I suppose it might depends on the defnition of race-prone but I would say that the list  operation as implemented are not really race-prone (thanks to the use of TimeUUID for  indices instead of plain integers). In particular I’ll not that the implementation don’t ""over-  write the entire list with the desired items removed"".
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",15:1005 - 15:1333,2,arjan
19:117,In particular that means that if 2 clients concurrently set elements i…,CASSANDRA-3647,"In particular that means that if 2 clients concurrently set elements i and j in the list, then:  * either i == j, in which case the usual timestamp resolution rules will apply for element i.
* or i != j, and we guarantee that both update will be taken into account. So in particular  we will *not* potentially lose one of the insert.
I’ll note that this is the reason why I don’t want to implement a discard by value for maps:  I don’t know how to do that without it being clearly race-prone.
",,Architectural component behavior and structure,15:1334 - 15:1828,1,arjan
19:118,Now it is true that if a client reads a list and then tries to set the…,CASSANDRA-3647,"Now it is true that if a client reads a list and then tries to set the value at index i, there is  not guarantee this value will still be the ith value, but I would say that it’s mostly us not  supporting transactions rather that the list being race-prone.
",,Motivation of design issue,15:1830 - 15:2087,1,arjan
19:119,Overall I think having set and discard_idx can be useful and have reas…,CASSANDRA-3647,"Overall I think having set and discard_idx can be useful and have reasonable behavior  in face of concurrency. On the other side, if we ask people to read and overwrite the whole  list, then it will be much more race-prone .
",,Architectural solution benefits and drawbacks,15:2088 - 15:2313,1,arjan
19:233,jbellis,CASSANDRA-3647,jbellis,,Comment,15:2318 - 15:2324,1,arjan
19:120,"Fair enough, I’ll buy that.",CASSANDRA-3647,"Fair enough, I’ll buy that.
",,Architectural solution benefits and drawbacks,15:2425 - 15:2453,1,arjan
19:121,"Nit: not a huge fan of ""int nanos"" parameters whose values are really…",CASSANDRA-3647,"Nit: not a huge fan of ""int nanos"" parameters whose values are really 100s of nanos",,Architectural solution benefits and drawbacks,15:2454 - 15:2536,1,arjan
19:122,"Can we  have callers multiply by 100 instead, or maybe call it somethi…",CASSANDRA-3647,"Can we  have callers multiply by 100 instead, or maybe call it something like ""ticks"" or ""uuidticks""  instead?
",,Architectural component behavior and structure,15:2539 - 15:2650,1,arjan
19:123,How would you avoid a race with Updating a list by idx if there is a p…,CASSANDRA-3647,"How would you avoid a race with Updating a list by idx if there is a prepending  insert happening?
",,,15:2662 - 15:2761,1,arjan
19:234,jbellis,CASSANDRA-3647,jbellis,,Comment,15:2766 - 15:2772,1,arjan
19:124,"You either get the pre-prepend index, or the post-. :)  So no, it does…",CASSANDRA-3647,"You either get the pre-prepend index, or the post-. :)  So no, it doesn’t avoid races (""don’t do that if it hurts""), but it gives you a sane result.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",15:2775 - 15:2924,2,arjan
19:235,xedin,CASSANDRA-3647,xedin,,Comment,16:5 - 16:9,1,arjan
19:125,"*AbstractType* Wouldn’t it be a good idea to add a ""boolean isCollecti…",CASSANDRA-3647,"*AbstractType* Wouldn’t it be a good idea to add a ""boolean isCollectionType()"" method  which by default would return ""false""? That would allow to avoid ""instanceof"" checks which  are done all over the place. It’s probably time to do the same for CompositeType as we get  more and more instanceof checks for it as well.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",16:64 - 16:384,2,arjan
19:126,"*TypeParser* method ""stringifyCollectionsParameters"" - The following i…",CASSANDRA-3647,"*TypeParser* method ""stringifyCollectionsParameters"" - The following is not DRY as the  same actions repeated in all clauses, when to append(’,’) could be distinguished with a con-  dition instead of code duplication.
",,Technical debt,16:387 - 16:605,1,arjan
19:127,*Value* I think we should add a way to distinguish between diferent ty…,CASSANDRA-3647,"*Value* I think we should add a way to distinguish between diferent types of values with-  out using ""instanceof"" all them. In combination with common iteration method (asList()  from the last patch) for all of them that would allow to remove ""instanceof"" checks and  ""cast"" everywhere.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",16:608 - 16:895,3,arjan
19:128,- *UpdateStatement* starting from line _199_ - only diference between…,CASSANDRA-3647,"- *UpdateStatement* starting from line _199_ - only diference between ""instanceof"" cases  is pre-validation which could be added to the separate method in Value for example and  ""addMutation"" call with diferent types this also proves previous point about Value.
- *UpdateStatement* ""mutationForKey"" method - do we need to enforce using ""group"" as a  last parameter all the time, even when we set it to ""null"" ?
- *UpdateStatement* line _407_ ""defnition"" should be ""defnitions""  - *CollectionType* line _89_ *ListType* line _147_ ""argument"" should be ""arguments""",,,16:896 - 16:1458,1,arjan
19:236,slebresne,CASSANDRA-3647,slebresne,,Comment,16:1465 - 16:1473,1,arjan
19:129,I’ve pushed a v3 at https://github.com/pcmanus/cassandra/commits/3647-…,CASSANDRA-3647, I’ve pushed a v3 at https://github.com/pcmanus/cassandra/commits/3647-3  that is rebased and adds one last patch to address some of the remarks. ,,,16:1475 - 16:1620,1,arjan
19:130,I don’t know actually. That’s defnitively an option but on the other s…,CASSANDRA-3647,"I don’t know actually. That’s defnitively an option but on the other side I wonder what  that would really get us. I know instanceof has bad reputation, and I certainly agree that  we shouldn’t overuse it, but I don’t think we should avoid it at all cost either. In most  instanceof usage for CollectionType and CompositeType, a cast follows (and in most case I  don’t see how to refactor to avoid those casts without being uber ugly, though I’m open to  suggestion), and if your going to cast, I think testing with instanceof is actually safer than  using a boolean method.",,Trade-offs,16:1755 - 16:2328,1,arjan
19:141,If I understand correctly those are related. I’ve refactored Value.jav…,CASSANDRA-3647,"If I understand correctly those are related. I’ve refactored Value.java and UpdateState-  ment a bit to merge the code dealing with the diferent literals. It does not eliminate *all*  the instanceof and casts, but I think the remaining one are ok (that is, I don’t see a clearly  better way to do the same thing without the instanceof).
",,Architectural component behavior and structure,17:1 - 17:338,1,arjan
19:131,"bq. *UpdateStatement* ""mutationForKey"" method - do we need to enforce…",CASSANDRA-3647,"bq. *UpdateStatement* ""mutationForKey"" method - do we need to enforce using ""group"" as  a last parameter all the time, even when we set it to ""null"" ?
I don’t understand what you are suggesting.
bq. ""defnition"" should be ""defnitions""  Fixed.
bq. *CollectionType* line 89 *ListType* line 147 ""argument"" should be ""arguments""  I didn’t found any instance of ""argument"" on those line. Maybe they were in the frst  patches but removed by the later ones?
",,,17:339 - 17:792,1,arjan
19:237,xedin,CASSANDRA-3647,xedin,,Comment,17:797 - 17:801,1,arjan
19:132,This is the main problem on my opinion - that we need a casts/instance…,CASSANDRA-3647,"This is the main problem on my opinion - that we need a casts/instanceof checks which  is a chronic problem of type hierarchy of o.a.c.db.marshal package related to Composite  and Collection types,",,Architectural solution benefits and drawbacks,17:1384 - 17:1580,1,arjan
19:133,I think we should refect their most commonly used functionality in  Ab…,CASSANDRA-3647,"I think we should refect their most commonly used functionality in  AbstractType.
",,"Architectural component behavior and structure
Assumptions",17:1582 - 17:1664,2,arjan
19:140,"I like what you did there, how about we go further and move validateTy…",CASSANDRA-3647,"I like what you did there, how about we go further and move validateType(CFDefnition.Name)  and constructionFunction() to Value and remove (or rename Value to) Literal as all of the  classes implement only that one interface, so it would be someting like Literal.{List, Set,  Map} and you would be able to ""assert instance of Literal"" in UpdateStatement?...
",,Architectural component behavior and structure,17:2005 - 17:2363,1,arjan
19:134,"bq. ""defnition"" should be ""defnitions""  There are couple of same typos…",CASSANDRA-3647,"bq. ""defnition"" should be ""defnitions""  There are couple of same typos in the UpdateStatement left - lines _341_, _349_ and  _373_  bq. UpdateStatement ""mutationForKey"" method - do we need to enforce using ""group""  as a last parameter all the time, even when we set it to ""null"" ?
That was fxed in the last commits so no problem.
bq. CollectionType line 89 ListType line 147 ""argument"" should be ""arguments""  16
That seems to be removed too, sorry, I have seen they in a frst commits.
",,,17:2364 - 18:74,1,arjan
19:238,slebresne,CASSANDRA-3647,slebresne,,Comment,18:79 - 18:87,1,arjan
19:135,"We test 6 times for ""instanceof CollectionType"": one time is to call s…",CASSANDRA-3647,"We test 6 times for ""instanceof CollectionType"": one time is to call serializeForThrift()  and 2 other times are to call the execute() methods. Both of those are very specifc to  CollectionType currently and I’m not convainced at all moving these ""functionality"" to Ab-  stractType would make sense/be cleaner. One other time, we cast to CollectionType in order  to construct a ColumnToCollectionType so we’ll have to do that cast anyway. Remains 2  occurences were we could indeed replace the ’instanceof’ by a ’isCollection()’ method (we  don’t cast to CollectionType after the instanceof test), but again I’m not sure there is a  point? It won’t be measurably faster and it won’t even save characters (since we’ll have to  defne the isCollection method).
",,"Architectural solution benefits and drawbacks
Existing system architecture description",18:250 - 18:1008,2,arjan
19:136,"As for CompositeType, there is (only) 4 occurrences of ""instanceof Com…",CASSANDRA-3647,"As for CompositeType, there is (only) 4 occurrences of ""instanceof CompositeType"", all  of which are followed by a cast so that we can access the ’types’ feld of CompositeType. I  don’t see any sane way to move that functionality into AbstractType.
",,Architectural solution benefits and drawbacks,18:1009 - 18:1258,1,arjan
19:137,So honestly I think we actually do a reasonably good job of ’refecting…,CASSANDRA-3647,"So honestly I think we actually do a reasonably good job of ’refecting their most com-  monly used functionality in AbstractType’ and in practice I don’t really see how to do better.
",,"Architectural solution benefits and drawbacks
Assumptions",18:1259 - 18:1442,2,arjan
19:139,We cannot do that because Term implements Value. The point of Value is…,CASSANDRA-3647,"We cannot do that because Term implements Value. The point of Value is to be a Term or  a Literal.
",,Architectural solution benefits and drawbacks,18:1671 - 18:1770,1,arjan
19:138,bq. There are couple of same typos in the UpdateStatement left - lines…,CASSANDRA-3647,"bq. There are couple of same typos in the UpdateStatement left - lines _341_, _349_  and _373_  I’ll update those.
",,,18:1771 - 18:1885,1,arjan
19:239,xedin,CASSANDRA-3647,xedin,,Comment,18:1891 - 18:1895,1,arjan
19:142,I wouldn’t actually judge this by *current* usages of instanceof/casts…,CASSANDRA-3647,"I wouldn’t actually judge this by *current* usages of instanceof/casts because what they  show bad tendency where users are forced to use downcasts to get things which are natural  to the complex types but not refected in the common AbstractType interface. Every time  instanceof is used it indicates that components’ OO design is broken.
",,Architectural solution benefits and drawbacks,18:2051 - 18:2390,1,arjan
19:143,"If the most common thing we do after cast with CompositeType is get ""t…",CASSANDRA-3647,"If the most common thing we do after cast with CompositeType is get ""types"" feld then  we could add Collection<AbstractType<?» getComponentTypes() method. Simple types  would return just one component - themselves (or throw an exception saying that type is not  complex to be sure that method is not misused) and complex ones would be able to return  immutable list of their component types, in combination with isComposite() method that  would eliminate instanceof/downcasts completely.
",,Architectural component behavior and structure,18:2391 - 18:2879,1,arjan
19:144,would eliminate instanceof/downcasts completely.,CASSANDRA-3647,"would eliminate instanceof/downcasts completely.
",,Architectural solution benefits and drawbacks,18:2830 - 18:2879,1,arjan
19:145,"That means that you are confusing semantics of the ""literal"" e.g. http…",CASSANDRA-3647,"That means that you are confusing semantics of the ""literal"" e.g. https://en.wikipedia.org/wiki/Literal_(computer_p  , so Term actually should become {Unary | Single}Literal and implement Literal where {List,  Set, Map} classes would have UnaryLiteral as base element",,Architectural component behavior and structure,19:1 - 19:267,1,arjan
19:146,there is no need to invent hier-  archy like Value.Literal just to mak…,CASSANDRA-3647,"there is no need to invent hier-  archy like Value.Literal just to make it ft with current Term implementation.
",,Architectural solution benefits and drawbacks,19:270 - 19:382,1,arjan
19:240,slebresne,CASSANDRA-3647,slebresne,,Comment,19:387 - 19:395,1,arjan
19:147,Ok fne. I don’t agree (more precisely I don’t think perfect OO design…,CASSANDRA-3647,"Ok fne. I don’t agree (more precisely I don’t think perfect OO design at all cost is neces-  sarily superior) but I’m not interested in that debate, at least not on that ticket. So do you  have concrete proposition for that ticket? If not, I suggest we consider it good enough for  now, and feel free to open a follow up ticket with a clean refactor that follow OO design to  the letter.
",,Architectural solution benefits and drawbacks,19:485 - 19:873,1,arjan
19:148,"Please Pavel, let’s stop with that. I don’t fucking care about wikiped…",CASSANDRA-3647,"Please Pavel, let’s stop with that. I don’t fucking care about wikipedia defnitions and  thanks but I’m not confused by any semantic.
",,Architectural solution benefits and drawbacks,19:940 - 19:1074,1,arjan
19:149,"So yes, when I say Literal it’s a name for the class used to represent…",CASSANDRA-3647,"So yes, when I say Literal it’s a name for the class used to represent the collection lit-  erals. If you fnd the naming confusing, then fne, we can call the class CollectionLiteral  (that’s even a good idea).
",,Architectural component behavior and structure,19:1075 - 19:1285,1,arjan
19:150,Making the literals being of class  Term (or a subclass) would be ugly…,CASSANDRA-3647,Making the literals being of class  Term (or a subclass) would be ugly because none of the method of Term apply to the (col-  lection) literals. ,,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",19:1429 - 19:1573,2,arjan
19:151,But the literals also have methods that make no sense for Term (namely…,CASSANDRA-3647,"But the literals also have methods that make no sense for Term (namely  validateType, isEmpty and constructFunction), so we don’t want to put those methods in  the interface shared with Term either.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",19:1574 - 19:1773,2,arjan
19:152,"So I don’t see a cleaner to having Term, Value and Literal (though aga…",CASSANDRA-3647,"So I don’t see a cleaner to having Term, Value and Literal (though again, I’m fne changing  the naming) and I’m not confused about that.
",,Architectural solution benefits and drawbacks,19:1774 - 19:1911,1,arjan
19:153,"And if we’re being pedantic on naming, Term should not be renamed to U…",CASSANDRA-3647,"And if we’re being pedantic on naming, Term should not be renamed to UnaryLiteral because  it does not only represent literals, but also bind variables.
",,Architectural component behavior and structure,19:1912 - 19:2065,1,arjan
19:154,And why do we need the common ancestor so much if List/Set/Map don’t h…,CASSANDRA-3647,"And why do we need the common ancestor so much if List/Set/Map don’t have anything in  common with Term except those classes are it’s containers?
",,,20:129 - 20:275,1,arjan
19:242,slebresne,CASSANDRA-3647,slebresne,,Comment,20:280 - 20:288,1,arjan
19:155,"So 100% of the time, when we access the ""types"" feld the code is speci…",CASSANDRA-3647,"So 100% of the time, when we access the ""types"" feld the code is specifc to compositeType,  so we would still have to test if the type is composite and we would never call the getCompo-  nentTypes for non-composite type. Hence the only thing that would change is that we would  replace ""if (type instanceof CompositeType)"" by ""if (type.isCompositeType())"" and ""((Com-  positeType)type).types"" by ""type.getComponentTypes()"" which is imho *exactly* the same  thing (allergic reaction to instanceof/casts put aside). Except that in the meantime you’ll  have polluted the interface of AbstractType with 2 new methods. And it is less safe because  if someone writes a custom type that happens to change the implementation of those meth-  ods, it will almost surely be a bug. So I’m not convinced at all by that idea.
",,Architectural component behavior and structure,20:450 - 20:1262,1,arjan
19:156,Except that in the meantime you’ll  have polluted the interface of Abs…,CASSANDRA-3647,"Except that in the meantime you’ll  have polluted the interface of AbstractType with 2 new methods. And it is less safe because  if someone writes a custom type that happens to change the implementation of those meth-  ods, it will almost surely be a bug. So I’m not convinced at all by that idea.",,Architectural solution benefits and drawbacks,20:964 - 20:1260,1,arjan
19:157,"But don’t get me wrong, if I were to redesign C* from the ground up, I…",CASSANDRA-3647,"But don’t get me wrong, if I were to redesign C* from the ground up, I would probably  make composite a more ""native"" notion and everything would be a composite (with poten-  tially only 1 component) and composites wouldn’t be a subclass of AbstractType at all. But  this is not really an option, at least not on the short term.
",,Architectural design configuration,20:1263 - 20:1592,1,arjan
19:158,"But  this is not really an option, at least not on the short term",CASSANDRA-3647,"But  this is not really an option, at least not on the short term",,Contextual constraints,20:1525 - 20:1589,1,arjan
19:159,"On a more general ""design"" level, in the current code, an AbstractType…",CASSANDRA-3647,"On a more general ""design"" level, in the current code, an AbstractType in general don’t  have ""components types""",,Existing system architecture description,20:1593 - 20:1704,1,arjan
19:160,so I don’t think we should add a getComponentTypes() method.,CASSANDRA-3647,"so I don’t think we should add a getComponentTypes() method.
",,"Architectural component behavior and structure
Assumptions",20:1706 - 20:1767,2,arjan
19:161,"But since all that has nothing to do with this ticket, if you think it…",CASSANDRA-3647,"But since all that has nothing to do with this ticket, if you think it would be a good idea,  I can only encourage you to open a separate ticket on which we could have a more focused  discussion.
",,,20:1768 - 20:1964,1,arjan
19:162,Because we want Operation.Set and ’List<Value> columnValues’ in Update…,CASSANDRA-3647,Because we want Operation.Set and ’List<Value> columnValues’ in UpdateStatement to  be able to contain both Term and collection Literal (i.e. Value is a marker interface basi-  cally).,,Architectural solution benefits and drawbacks,20:2009 - 20:2192,1,arjan
19:163,That’s not what I said. And in fact Value defnes the asList() method t…,CASSANDRA-3647,"That’s not what I said. And in fact Value defnes the asList() method that both Term  and List/Set/Map implement. What I said is that List/Set/Map also have most of their  methods that don’t apply to Term and Term have most of his method that don’t apply to  List/Set/Map. Having the intersection non-empty don’t mean one is contain in the other.
",,Architectural component behavior and structure,20:2253 - 20:2599,1,arjan
19:164,Note that I’m not saying it’s the only design. We probably could dupli…,CASSANDRA-3647,"Note that I’m not saying it’s the only design. We probably could duplicate Operation.Set  to have one applying to Term and one applying to collection literals and split UpdateState-  ment.columnValues into two lists,",,Architectural component behavior and structure,20:2600 - 20:2815,1,arjan
19:165,but imho having the Value interface to avoid the code  duplication is…,CASSANDRA-3647,"but imho having the Value interface to avoid the code  duplication is cleaner.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",20:2817 - 20:2895,2,arjan
19:243,xedin,CASSANDRA-3647,xedin,,Comment,20:2901 - 20:2905,1,arjan
19:166,I am not convinced that (at least) approuch taken  for collection repr…,CASSANDRA-3647,"I am not convinced that (at least) approuch taken  for collection representation such as term/value/literal interconnection is a correct way to  go. Code also adds few new types to o.a.c.db.marshal that make AbstractType even worse  interface with new ""execute"" operations added.
",,Architectural solution benefits and drawbacks,20:3028 - 20:3308,1,arjan
19:244,jbellis,CASSANDRA-3647,jbellis,,Comment,20:3313 - 20:3319,1,arjan
19:167,Pushed some tweaks to https://github.com/jbellis/cassandra/commits/364…,CASSANDRA-3647,Pushed some tweaks to https://github.com/jbellis/cassandra/commits/3647-4.,,,20:3322 - 20:3395,1,arjan
19:168,"In  particular, renamed the position compare/validate overloads to be…",CASSANDRA-3647,"In  particular, renamed the position compare/validate overloads to be more clear what they are  19
for",,,20:3397 - 21:3,1,arjan
19:169,"With that clarifed, I think it’s worth letting polymorphism do the bra…",CASSANDRA-3647,"With that clarifed, I think it’s worth letting polymorphism do the branch here, so  having them in AbstractType is a good thing.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",21:6 - 21:135,2,arjan
19:170,I agree that superfcially isComposite() would be a good addition to Ab…,CASSANDRA-3647,"I agree that superfcially isComposite() would be a good addition to AbstractType... but  the way we use instanceof here, I think DCT would have to return false, which would be  pretty confusing. So instanceof looks like the lesser evil.
",,Trade-offs,21:136 - 21:373,1,arjan
19:171,I think the current approach for collection representation at the Antl…,CASSANDRA-3647,I think the current approach for collection representation at the Antlr level is reasonable. It  may be that Pavel’s idea is better but I don’t think we’re going to make more progress on  that w/o actually coding it up.,,Trade-offs,21:374 - 21:592,1,arjan
19:172,Overall +1 from me.,CASSANDRA-3647,"Overall +1 from me.
",,Architectural solution benefits and drawbacks,21:710 - 21:730,1,arjan
19:245,xedin,CASSANDRA-3647,xedin,,Comment,21:735 - 21:739,1,arjan
19:173,I believe we should block this and even more - I think we should make…,CASSANDRA-3647,"I believe we should block this and even more - I think we should make fne-grained sub-  issues to cover changes, like:  - ""Prepare marshal package for collection type support"", which would add collection types  and make AbstractType happy with them;  - ""CQL3 grammar support for ’collection’ operations on list/set/map"", which would add  a ANTLR code to support required operations on the grammar level without using shaky  combinations like term/value/literal;  - and this one would a glue for the two described above.
because as in the current state marshal is broken in a way that it requires instanceof checks,  this one pushes it to the whole new level by introducing functionality that ""type"" should not  have by it’s nature e.g. ""execute"". I’m not fond of signing this up until we do something  about it or we are building a house without proper fundament.
",,Architectural solution benefits and drawbacks,21:1082 - 21:1947,1,arjan
19:246,slebresne,CASSANDRA-3647,slebresne,,Comment,21:1952 - 21:1960,1,arjan
19:174,This is completely ridiculous. I don’t pretend that this patch is perf…,CASSANDRA-3647,"This is completely ridiculous.
I don’t pretend that this patch is perfect (I never pretend such a thing) but suggesting  that the style of this patch is *so bad* that we should *block* this and redo it is wrong and  frankly insulting.
And thruth being told, considering that almost all tickets are some form of compromise  (as they should be) between getting things done and refactoring too much code to achieve  some notion of code beauty, I’m actually reasonably happy with this patch.
Besides, this is a feature that people are excited about for CQL3 (and some ticket like  CASSANDRA-4351 could make a good use of it), so we defnitively don’t want to delay that  unless we have a very good reason.
",,Architectural solution benefits and drawbacks,21:1999 - 21:2703,1,arjan
19:175,"Anyway, I’ve committed this (based on Jonathan’s review). But I’m impa…",CASSANDRA-3647,"Anyway, I’ve committed this (based on Jonathan’s review). But I’m impatiently waiting  for Pavel’s patch that will refactor the hell out of this to give us solid foundation.
",,,21:2704 - 21:2878,1,arjan
19:247,xedin,CASSANDRA-3647,xedin,,Comment,21:2883 - 21:2887,1,arjan
19:176,When I try to do SET operation on any collection type I get following…,CASSANDRA-3647,"When I try to do SET operation on any collection type I get following exception:  java.lang.IllegalStateException: Composite column is already fully constructed  at org.apache.cassandra.db.marshal.CompositeType$Builder.buildAsEndOfRange  at org.apache.cassandra.cql3.statements.UpdateStatement.addToMutation(Upda  at org.apache.cassandra.cql3.statements.UpdateStatement.mutationForKey(Upd  at org.apache.cassandra.cql3.statements.UpdateStatement.getMutations(Updat  at org.apache.cassandra.cql3.statements.ModificationStatement.execute(Modi  at org.apache.cassandra.cql3.QueryProcessor.processStatement(QueryProcesso  at org.apache.cassandra.cql3.QueryProcessor.process(QueryProcessor.java:11  at org.apache.cassandra.thrift.CassandraServer.execute_cql_query(Cassandra  at org.apache.cassandra.thrift.Cassandra$Processor$execute_cql_query.getRe  at org.apache.cassandra.thrift.Cassandra$Processor$execute_cql_query.getRe  at org.apache.thrift.ProcessFunction.process(ProcessFunction.java:32)  at org.apache.thrift.TBaseProcessor.process(TBaseProcessor.java:34)  at org.apache.cassandra.thrift.CustomTThreadPoolServer$WorkerProcess.run(C  at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecut  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.j  at java.lang.Thread.run(Thread.java:680)  Following exceptions observed on List.Append:  java.lang.IllegalStateException: Composite column is already fully constructed  at org.apache.cassandra.db.marshal.CompositeType$Builder.add(CompositeType  at org.apache.cassandra.db.marshal.CompositeType$Builder.add(CompositeType  at org.apache.cassandra.db.marshal.ListType.doAppend(ListType.java:197)  at org.apache.cassandra.db.marshal.ListType.executeFunction(ListType.java:  at org.apache.cassandra.db.marshal.CollectionType.execute(CollectionType.j  at org.apache.cassandra.cql3.statements.UpdateStatement.addToMutation(Upda  at org.apache.cassandra.cql3.statements.UpdateStatement.mutationForKey(Upd  at org.apache.cassandra.cql3.statements.UpdateStatement.getMutations(Updat  at org.apache.cassandra.cql3.statements.ModificationStatement.execute(Modi  at org.apache.cassandra.cql3.QueryProcessor.processStatement(QueryProcesso  at org.apache.cassandra.cql3.QueryProcessor.process(QueryProcessor.java:11  at org.apache.cassandra.thrift.CassandraServer.execute_cql_query(Cassandra  at org.apache.cassandra.thrift.Cassandra$Processor$execute_cql_query.getRe  at org.apache.cassandra.thrift.Cassandra$Processor$execute_cql_query.getRe  at org.apache.thrift.ProcessFunction.process(ProcessFunction.java:32)  at org.apache.thrift.TBaseProcessor.process(TBaseProcessor.java:34)  at org.apache.cassandra.thrift.CustomTThreadPoolServer$WorkerProcess.run(C  at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecut  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.j  at java.lang.Thread.run(Thread.java:680)  And Set.Add  21
ava.lang.IllegalStateException: Composite column is already fully constructed  at org.apache.cassandra.db.marshal.CompositeType$Builder.add(CompositeType  at org.apache.cassandra.db.marshal.CompositeType$Builder.add(CompositeType  at org.apache.cassandra.db.marshal.SetType.doAdd(SetType.java:111)  at org.apache.cassandra.db.marshal.SetType.executeFunction(SetType.java:96  at org.apache.cassandra.db.marshal.CollectionType.execute(CollectionType.j  at org.apache.cassandra.cql3.statements.UpdateStatement.addToMutation(Upda  at org.apache.cassandra.cql3.statements.UpdateStatement.mutationForKey(Upd  at org.apache.cassandra.cql3.statements.UpdateStatement.getMutations(Updat  at org.apache.cassandra.cql3.statements.ModificationStatement.execute(Modi  at org.apache.cassandra.cql3.QueryProcessor.processStatement(QueryProcesso  at org.apache.cassandra.cql3.QueryProcessor.process(QueryProcessor.java:11  at org.apache.cassandra.thrift.CassandraServer.execute_cql_query(Cassandra  at org.apache.cassandra.thrift.Cassandra$Processor$execute_cql_query.getRe  at org.apache.cassandra.thrift.Cassandra$Processor$execute_cql_query.getRe  at org.apache.thrift.ProcessFunction.process(ProcessFunction.java:32)  at org.apache.thrift.TBaseProcessor.process(TBaseProcessor.java:34)  at org.apache.cassandra.thrift.CustomTThreadPoolServer$WorkerProcess.run(C  at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecut  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.j  at java.lang.Thread.run(Thread.java:680)  Map.Put has the exact same problem but I won’t add stacktrace here for brevity.
",,Run-time quality issues,22:79 - 23:1626,1,arjan
19:177,"My patch, if accepted, could be taken as a ground to fx previously men…",CASSANDRA-3647,"My patch, if accepted, could be taken as a ground to fx previously mentioned issues.
",,Architectural solution benefits and drawbacks,23:1627 - 23:1712,1,arjan
19:248,slebresne,CASSANDRA-3647,slebresne,,Comment,23:1801 - 23:1809,1,arjan
19:178,"For lists, ListOperation.SET is used for both ’set a column to a liter…",CASSANDRA-3647,"For lists, ListOperation.SET is used for both ’set a column to a literal’ and ’set a list  element by index’, so setting a literal is broken. ",,Motivation of design issue,23:2343 - 23:2484,1,arjan
19:179,"In UpdateStatement.prepare(), you replaced the check !(value instanceo…",CASSANDRA-3647,"In UpdateStatement.prepare(), you replaced the check !(value instanceof Term) by opera-  tion.getType() == Operation.Type.COLUMN, which is reversed.
",,,23:2668 - 23:2817,1,arjan
19:180,"Attaching updated alternative patch with all problems fxed, cql_tests…",CASSANDRA-3647,"Attaching updated alternative patch with all problems fxed, cql_tests are now  passing.
",,,23:2829 - 23:2917,1,arjan
19:249,xedin,CASSANDRA-3647,xedin,,Comment,23:2922 - 23:2926,1,arjan
19:181,I probably did something extraordinary (schema borrowed from Jonathan’…,CASSANDRA-3647,"I probably did something extraordinary (schema borrowed from Jonathan’s comment from  04/Jun/12)  CREATE TABLE foo(  k uuid PRIMARY KEY,  L list<int>,  M map<text, int>,  S set<int>  );  UPDATE ks.foo SET L = [1, 3, 5] WHERE k = ’b017f48f-ae67-11e1-9096-005056c00008’;  UPDATE ks.foo SET L = L + [7, 11, 13] WHERE k = ’b017f48f-ae67-11e1-9096-005056c0000  UPDATE ks.foo SET S = {1, 3, 5} WHERE k = ’b017f48f-ae67-11e1-9096-005056c00009’;  UPDATE ks.foo SET S = S + {7, 11, 13} WHERE k = ’b017f48f-ae67-11e1-9096-005056c0000",,Run-time quality issues,24:1 - 24:523,1,arjan
19:182,"lgtm, committed.",CASSANDRA-3647,"lgtm, committed.
",,,24:605 - 24:622,1,arjan
19:183,That was due to the fact that the patch hadn’t be updated post CASSAND…,CASSANDRA-3647,"That was due to the fact that the patch hadn’t be updated post CASSANDRA-4329. I’ve  added the trivial fx for that with the commit of the refactor (and added the relevant test  to dtests).
",,,24:683 - 24:871,1,arjan
19:250,thepaul,CASSANDRA-3647,thepaul,,Comment,24:877 - 24:883,1,arjan
19:184,Just a small thing that would make cqlsh’s life a little easier in try…,CASSANDRA-3647,"Just a small thing that would make cqlsh’s life a little easier in trying to make  sense of the ’comparator’ feld in system.schema_columnfamilies. The formatting in Type-  Parser.stringifyCollectionParameters is a bit backwards.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",24:886 - 24:1114,2,arjan
19:185,"Thanks, committed as 22fbc4e413da1c61f6d0381be8cfa99.",CASSANDRA-3647,"Thanks, committed as 22fbc4e413da1c61f6d0381be8cfa99.
",,,24:1168 - 24:1222,1,arjan
20:3,CQL 3.0,CASSANDRA-3761,CQL 3.0,,Architectural design configuration,3:52 - 3:58,1,arjan
20:1,The core change of CQL 3.0  is to introduce the new syntaxes that were…,CASSANDRA-3761,"The core change of CQL 3.0  is to introduce the new syntaxes that were discussed in CASSANDRA-2474 that allow to:  # Provide a better/more native support for wide rows, using the idea of transposed vie.
# The generalization to composite columns.
",,Architectural design configuration,3:143 - 3:390,1,arjan
20:2,The changes proposed above allow (and strongly suggest in some cases)…,CASSANDRA-3761,"The changes proposed above allow (and strongly suggest in some cases) a number of other changes  to the language that this ticket proposes to explore/implement (more details coming in the com-  ments).
",,Motivation of design issue,3:473 - 3:675,1,arjan
20:71,slebresne,CASSANDRA-3761,slebresne,,Comment,4:51 - 4:59,1,arjan
20:4,"First, on the backward compatibility issue: the changes proposed are b…",CASSANDRA-3761,"First, on the backward compatibility issue: the changes proposed are breaking changes  (as indicated by the major version bump). The patch creates a new java package cql3 that  is completely separate from the cql package. So for a time both cql 2.0 and 3.0 will be  supported. To make that work, the patch adds a new thrift method set_cql_version(String)  to allow setting the version during the client session (in the second patch). The default  version in the patch is 3.0 *but* it’s only because it makes testing easier until drivers adds  support for this new method. Based on the discussion we had on CASSANDRA-2474, what  I propose is that for C* 1.1 we add only 3.0 as a beta/demonstration version with 2.0 still  being the default. If everything goes well, in C* 1.2, cql 3.0 will become the default and 2.0  will be supported by deprecated.
One change the patches does is to make static CF (i.e, the ones that don’t use COMPACT  STORAGE) really static, i.e. adding non defned columns is not supported. The reasons  are numerous (I’ll probably even forget some):  * If we were to allow non defned columns in static CF, we would pretty much allow to use  a static CF as a wide row. So we would have to support doing a slice on those static CF.
But that is kind of contradictory with the introduction of the transposed idea. And if we  don’t allow slices on static CF, what is the point of allowing random columns?
* It makes the code simpler. In particular it avoids complication with sparse composites.
* It’s helpful to users. If you use a static CF, we tell you when you do a typo inserting a  column (I do think it’s a very useful thing).
* It’s not a limitation. If you need a new column, you can do an ALTER ADD, it’s cheap.
And if your columns names are really ""random"", then what you really want is a transposed/-  compact CF anyway.
* It means it makes sense to limit prepared markers to the right side of a relation. That in  turns allows to do a bit more work during preparation and make stuf like CASSANDRA-  3753 possible/easy.
* It make the language much closer to SQL. Don’t get me wrong, I don’t like SQL all that  much, but CQL does reuses SQL syntax and core concepts. Making it easier on all the  people that know SQL is a good thing provided there is no downside to do it. And in that  case I don’t think there is one, outside of breaking compatibility with CQL 2.0, which will  be broken anyway.
Another thing the patch does is to add consistency to our handling of case-sensitivity for  column names. ",,Architectural design configuration,4:401 - 4:2939,1,arjan
20:5,"One change the patches does is to make static CF (i.e, the ones that d…",CASSANDRA-3761,"One change the patches does is to make static CF (i.e, the ones that don’t use COMPACT  STORAGE) really static, i.e. adding non defned columns is not supported. The reasons  are numerous (I’ll probably even forget some):  * If we were to allow non defned columns in static CF, we would pretty much allow to use  a static CF as a wide row. So we would have to support doing a slice on those static CF.
But that is kind of contradictory with the introduction of the transposed idea. And if we  don’t allow slices on static CF, what is the point of allowing random columns?
* It makes the code simpler. In particular it avoids complication with sparse composites.
* It’s helpful to users. If you use a static CF, we tell you when you do a typo inserting a  column (I do think it’s a very useful thing).
* It’s not a limitation. If you need a new column, you can do an ALTER ADD, it’s cheap.
And if your columns names are really ""random"", then what you really want is a transposed/-  compact CF anyway.
* It means it makes sense to limit prepared markers to the right side of a relation. That in  turns allows to do a bit more work during preparation and make stuf like CASSANDRA-  3753 possible/easy.
* It make the language much closer to SQL. Don’t get me wrong, I don’t like SQL all that  much, but CQL does reuses SQL syntax and core concepts. Making it easier on all the  people that know SQL is a good thing provided there is no downside to do it. And in that  case I don’t think there is one, outside of breaking compatibility with CQL 2.0, which will  be broken anyway.
",,Architectural solution benefits and drawbacks,4:1252 - 4:2833,1,arjan
20:6,"What I mean here is that currently, when you declare:  CREATE TABLE (…",CASSANDRA-3761,"What I mean here is that currently, when you declare:  CREATE TABLE (  MyKey text PRIMARY KEY,  Column1 int,  Column2 int,  )  3
then MyKey is case-insensitive and Column1 and Column2 are case-sensitive. We should fx  that inconsistency. ",,Run-time quality issues,4:2940 - 5:109,1,arjan
20:7,The patch makes the choice to reuse the way SQL (at least PostgreSQL)…,CASSANDRA-3761,"The patch makes the choice to reuse the way SQL (at least PostgreSQL)  deal with this: all defnition names (MyKey, Column1 and Column2 in my example) are case  insensitive by default (they are lowercased basically) but you can specify a case sensitive one  using double-quotes. The rational is that with the static is static idea above, we are in a case  very similar to SQL and so I didn’t see a very good reason to do things diferently (again,  except for the issue of backward compatibility). Note that in the wide row (transposed) case,  the C* column name is *not* a ’defnition name’, so that rule won’t apply. For consistency  sake, keyspace and column family names also follow the same rule.",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:110 - 5:807,2,arjan
20:8,"We could alternatively make everything case-sensitive, but at least th…",CASSANDRA-3761,"We could alternatively make everything case-sensitive, but at least the rule should be the  same for all defnitions, whether it is a PRIMARY KEY or not.
",,Architectural component behavior and structure,5:810 - 5:963,1,arjan
20:9,On the code itself: the changes described above are extensive in that…,CASSANDRA-3761,"On the code itself: the changes described above are extensive in that they involve an al-  most complete rewrite of the select, createCF, update, delete and alterTable statements, as  well as a non-trivial amount of changes to the grammar. While doing that, I saw a number  of things that could be improved/generalized to make the code more readable (typically  sometimes the code of a statement was entirely in QueryProcessor, sometimes it was in the  statement class, sometimes it was split between both, etc..) and to fx a number of (minor)  issues. And because we have decided that cql 3 is a ’fork’ of cql 2, I decided it would be  a good occasion to improve the code. One thing leading to another, the patch refactors a  good chunk of the cql code. I know that it’s not the way we usually do things but I think  the circumstance are a bit diference this time in that the patch is (almost) only new code,  and we’ve agreed cql3 will be beta to start with. I’m also willing to devote a fair chunk of  my time to the testing of that new cql version. I hope you guys won’t be pissed of by this.
In any case, the patches fx the following issues with cql (in the new cql3 that is, it does not  backport the fxes to cql 2.0):",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:964 - 5:2188,2,arjan
20:10,* Handles correctly the case where an update inside a batch override t…,CASSANDRA-3761,"* Handles correctly the case where an update inside a batch override the current keyspace  * Support overriding the current keyspace in all statements that apply to a CF. I.e, add the  optional override to CreateCF, CreateIndex, atlterTable and dropCF.
* make counters work with prepared statements (the grammar don’t allow markers like ’X  = X - ?’, and even if it was, the code had to be updated to handle it correctly).
* Delete’s consistency level isn’t validated  * Correctly batch batches. I.e, create only one RowMutation for a given (keyspace, key) for  the whole batch statement. That fx is in a separated patch.",,Run-time quality issues,5:2191 - 5:2813,1,arjan
20:11,Last note: the patch does not make any attempt to support transparentl…,CASSANDRA-3761,Last note: the patch does not make any attempt to support transparently super columns with  the new notations.,,Architectural design configuration,5:2816 - 5:2925,1,arjan
20:12,"I think trying to do so would be messy, so I think it will be a better…",CASSANDRA-3761,"I think trying to do so would be messy, so I think it will be a better use  of our time to internally transform super columns into composites (aka CASSANDRA-3237).
",,"Architectural solution benefits and drawbacks
Assumptions",5:2927 - 5:3091,2,arjan
20:13,Also attaching the tests that I wrote so far to test that issue. They…,CASSANDRA-3761,"Also attaching the tests that I wrote so far to test that issue. They are for  https://github.com/riptano/cassandra-dtest because I did not bother yet to move them some  place else. It’s far for covering everything but it’s a start.
",,,5:3106 - 5:3339,1,arjan
20:72,jawahar_prasad,CASSANDRA-3761,jawahar_prasad,,Comment,5:3343 - 5:3356,1,arjan
20:14,This makes sense.,CASSANDRA-3761,This makes sense.,,Architectural solution benefits and drawbacks,5:3359 - 5:3375,1,arjan
20:15,But can you please point out the diference between  these two? (maybe…,CASSANDRA-3761,"But can you please point out the diference between  these two? (maybe in terms of performance, etc.,)  1)  CREATE TABLE timeline (  userid uuid,  posted_at date,  body text,  4
posted_by text,  PRIMARY KEY (user_id, posted_at),  );  SELECT body, posted_by FROM timeline WHERE userid = ’...’ and posted_at = ’2  janvier 2010’  SELECT posted_ad, body, posted_by FROM timeline WHERE userid = ’...’ and posted_at  > ’2 janvier 2010’  2)  CREATE TABLE timeline (  userid uuid PRIMARY KEY,  posted_at date,  body text,  posted_by text  );  CREATE INDEX ON timeline(posted_at);  SELECT body, posted_by FROM timeline WHERE userid = ’...’ and posted_at = ’2  janvier 2010’  SELECT posted_ad, body, posted_by FROM timeline WHERE userid = ’...’ and posted_at  > ’2 janvier 2010’  And also(a dumb question),  If I set PRIMARY KEY (user_id, posted_at) , I MUST ALWAYS flter by userid and  posted_at ?(WHERE userid = ’...’ and posted_at > ’2 janvier 2010’)",,,5:3378 - 6:765,1,arjan
20:16,"@jawahar In you 2), userid is the only key, and hence each user can on…",CASSANDRA-3761,"@jawahar In you 2), userid is the only key, and hence each user can only have  one posted_at (which is unlikely what you want in that example). Creating an index on  posted_at doesn’t change that, it just make it possible to search for the users based on their  unique posted_at value (in particular, the 2nd query or the 2nd example doesn’t make a  whole lot of sense). And in the frst example, if you only specify ’WHERE userid = ’..” for  instance, it’ll return all the records for that userid.
",,,6:782 - 6:1280,1,arjan
20:17,Ok. I got it. Another question:  1. For example: I have columnfamily t…,CASSANDRA-3761,"Ok. I got it. Another question:  1. For example: I have columnfamily to store the broken links :  broken_link_id uuid PRIMARY KEY,  site_id uuid,  site_url text,  page_url text,  broken_link text,  anchor_text text,  tstamp timestamp  I want something like this:  site_id, site_url, page_url, {broken_link_id,broken_link,anchor_text,tstamp}  I came up with this WRONG version:  CREATE COLUMNFAMILY broken_links (  5
broken_link_id uuid,  site_id uuid,  site_url text,  page_url text,  broken_link text,  anchor_text text,  tstamp timestamp,  PRIMARY KEY(site_id, site_url, page_url)  );  Can you let me know how do I write this correctly please ? Or is there any doc to take a  look at this(for CQL) ?
2. How do you know what columns to be considered as composite based on PRIMARY  KEY?
",,,6:1300 - 7:373,1,arjan
20:18,"The PK(X, Y) syntax tells Cassandra to use composite columns internall…",CASSANDRA-3761,"The PK(X, Y) syntax tells Cassandra to use composite columns internally for that  row. This has two efects. First, as Sylvain mentioned above, if you just have the userid as  PK then (just as in SQL) you may only have one row with that key, which is not what you  want here. Second, it gives you some sorting guarantees for range queries like your posted_at  > Z example. See http://www.datastax.com/dev/blog/introduction-to-composite-columns-  part-1 for more background on composites.
That said, this really isn’t the right place to discuss the basics of querying composites.
Let’s keep that on the user mailing list, please.
",,,7:386 - 7:1016,1,arjan
20:73,xedin,CASSANDRA-3761,xedin,,Comment,7:1020 - 7:1024,1,arjan
20:19,Cql.g looks good.,CASSANDRA-3761,"Cql.g looks good.
",,Architectural solution benefits and drawbacks,7:1027 - 7:1045,1,arjan
20:74,jbellis,CASSANDRA-3761,jbellis,,Comment,7:1049 - 7:1055,1,arjan
20:20,Looking at SS.multiRangeSlice: I think we should address the key/token…,CASSANDRA-3761," Looking at SS.multiRangeSlice: I think we should address the key/token problem  as well: CQL < 3 silently turns a ""key >= X"" into ""token(key) >= token(X)"". This is not  what users will expect, since many of the rows returned will not in fact satisfy the requested  key inequality. I’ve opened CASSANDRA-3771 for this -",,Architectural solution benefits and drawbacks,7:1057 - 7:1375,1,arjan
20:21,"I don’t think we’ll get consensus  in time to incorporate that here, s…",CASSANDRA-3761,"I don’t think we’ll get consensus  in time to incorporate that here, so I suggest instead just disallowing range queries on row  keys for non-OPP for now. We can add one in later without breaking anything, and in the  meantime, Hadoop can continue to page via Thrift. (See discussion on CASSANDRA-2878.)",,Architectural design configuration,7:1378 - 7:1680,1,arjan
20:22,I don’t understand the comment here:  1 sliceRange.count = 1; // We us…,CASSANDRA-3761,"I don’t understand the comment here:  1 sliceRange.count = 1; // We use this for range slices, where the count  is ignored in favor of the global column count  My inclination would be if we’re going to ignore it, let’s set it to something obviously bogus,  like -1.
I have to admit I’m not a huge fan of the Restriction class. Some additional encapsula-  tion might help there since ""r == null || !r.isEquality()"" checks seem scattered around right  now.
What is CFDefnition.Name trying to encapsulate? ""Name value"" declaration confuses me. :)",,,7:1683 - 7:2227,1,arjan
20:23,"In my mind a classic, dynamic CF is the simplest possible dense, not a…",CASSANDRA-3761,"In my mind a classic, dynamic CF is the simplest possible dense, not a separate type.
So I’m not sure the distinction of Kind.dynamic is useful. (I note that you already have  these as the same case in SS.process.)",,Architectural solution benefits and drawbacks,7:2230 - 7:2444,1,arjan
20:24,"Nit: it’s more clear to avoid double-negatives, as in the if/else in {…",CASSANDRA-3761,"Nit: it’s more clear to avoid double-negatives, as in the if/else in {{if (!isKeyRange()) ...
else ...}}. Similar nit in ... lots of places. :)",,,8:1 - 8:144,1,arjan
20:75,slebresne,CASSANDRA-3761,slebresne,,Comment,8:150 - 8:158,1,arjan
20:25,"I don’t disagree, but I’ll note that the problem is the same for index…",CASSANDRA-3761,"I don’t disagree, but I’ll note that the problem is the same for indexed queries",,Architectural solution benefits and drawbacks,8:252 - 8:331,1,arjan
20:26,We can  only allow full-ring range slices however (maybe that’s what y…,CASSANDRA-3761,"We can  only allow full-ring range slices however (maybe that’s what you meant); i.e. disallow hav-  ing a non-equal restriction on the row key, but allow to have no restrictions at all. As a side  I’ll note that imho that’s yet one more reason to spit PK in two (the argument being that  when you start having too many diferent restrictions on the frst component of the PK and  the others, maybe it’s worth acknowledging it in the syntax).
",,Architectural design configuration,8:334 - 8:775,1,arjan
20:27,Sure. For some reason I cannot really explain I wanted to avoid 0 and…,CASSANDRA-3761,"Sure. For some reason I cannot really explain I wanted to avoid 0 and went with 1, but  -1 is better.
",,,8:888 - 8:990,1,arjan
20:28,"As the comments in the code says, I’m not an absolute fan either, but…",CASSANDRA-3761,"As the comments in the code says, I’m not an absolute fan either, but it was still the  best I could come up at the time. The goal being to make validation and querying as fast  as possible. I’m open to suggestions for a better encapsulation though.
",,"Architectural solution benefits and drawbacks
Architectural tactics",8:1056 - 8:1306,2,arjan
20:29,It’s representing what I could call for lack of a better name a ’CQL c…,CASSANDRA-3761,"It’s representing what I could call for lack of a better name a ’CQL column name’. I.e,  the name of one of the defnition in the CREATE TABLE defnition. And in the case of  Compact Storage, one of those ’CQL column name’ happens to be the name for the C* value  the record represent. So yes, there is some clash of terminology: a CQL column can be, in  C*, one of: the row key, the columm name, a component of the colum name or the column  value. Again, I’m open to suggestions to better names that avoid the confusion.
",,,8:1360 - 8:1880,1,arjan
20:30,"So to complete my comment above, you can see CFDefnition as the corres…",CASSANDRA-3761,"So to complete my comment above, you can see CFDefnition as the correspondence be-  tween the CQL names defned in the CREATE TABLE and what they represent internally.
’Name value’ is the name used to represent the C* value in the COMPACT STORAGE case.
Maybe calling it value_alias would avoid the confusion? (I avoided calling them ’alias’ at  frst, because from the CQL standpoing, they are not mere aliases but actual (CQL) column  names).
",,,8:1923 - 8:2367,1,arjan
20:31,"Yes but internally a dynamic CF don’t use a composite, so it is bound…",CASSANDRA-3761,"Yes but internally a dynamic CF don’t use a composite, so it is bound to have some dif-  ferences internally. ",,Architectural design configuration,8:2519 - 8:2628,1,arjan
20:32,"That being said, now that I think about it, I should be able to make…",CASSANDRA-3761,"That being said, now that I think about it, I should be able to make  those diferences even smaller by pushing them inside the CompositeType.Builder. That’ll  probably also merge a few diferences between sparse and static.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",8:2629 - 8:2852,3,arjan
20:33,Now that remind me of a detail that is worth mentioning. In the curren…,CASSANDRA-3761,"Now that remind me of a detail that is worth mentioning. In the current patch, if you  7
declare the following:  CREATE TABLE foo (key text, col text, value text, PRIMARY KEY (key,  col)) WITH COMPACT STORAGE;  and you do a {{SELECT * FROM foo WHERE key = ’k’}}, then it’ll return all the record  for key ’k’. But if now you declare:  CREATE TABLE foo (key text, col1 text, col2 text, value text, PRIMARY  KEY (key, col1, col2)) WITH COMPACT STORAGE;  and do {{SELECT * FROM foo WHERE key = ’k’ AND col1 = ’c’}}, then you will only  get one record back, the one where col1 is ’c’ and col2 is not defned, if it exists, not all the  record that have as prefx col1 == ’c’. The reason being that for dense, we allow to have  only a prefx of the key to be defned, and so you can do:  INSERT INTO foo (key, col1) VALUES (’k’, ’c’)",,Architectural component behavior and structure,8:2853 - 9:735,1,arjan
20:34,"One option would be to disallow doing this, but it would add an actual…",CASSANDRA-3761,"One option would be to disallow doing this, but it would add an actual limitation to what  is possible.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",9:738 - 9:842,2,arjan
20:76,jbellis,CASSANDRA-3761,jbellis,,Comment,9:847 - 9:853,1,arjan
20:35,"Right, ""pagination"" client-side is broken there as well.",CASSANDRA-3761,"Right, ""pagination"" client-side is broken there as well.",,Run-time quality issues,9:920 - 9:975,1,arjan
20:36,"Again, I think we should disallow  it for now and add it in when we ha…",CASSANDRA-3761,"Again, I think we should disallow  it for now and add it in when we have a solution we’re happy with. (Maybe that even means  the existing syntax, but I’m not convinced of that.)",,"Architectural design configuration
Architectural solution benefits and drawbacks",9:977 - 9:1154,2,arjan
20:38,Maybe.,CASSANDRA-3761,Maybe.,,Architectural solution benefits and drawbacks,9:1262 - 9:1267,1,arjan
20:37,"In my mind I’d rather make that distinction at the ""Okay we have Kind.…",CASSANDRA-3761,"In my mind I’d rather make that distinction at the ""Okay we have Kind.DENSE,  now do I have to treat this code diferently based on cf.comparator instanceof composite-  type?""",,Architectural component behavior and structure,9:1269 - 9:1442,1,arjan
20:39,But I’m happy to see what it looks like with your Builder approach.,CASSANDRA-3761,"But I’m happy to see what it looks like with your Builder approach.
",,Architectural solution benefits and drawbacks,9:1444 - 9:1512,1,arjan
20:40,That reminds me -- we should probably go with COMPACT instead of DENSE…,CASSANDRA-3761,"That reminds me -- we should probably go with COMPACT instead of DENSE, to match  the CQL syntax.",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",9:1514 - 9:1610,2,arjan
20:41,That sounds like a bug to me. If I wanted to restrict it to col2 not d…,CASSANDRA-3761,"That sounds like a bug to me. If I wanted to restrict it to col2 not defned, I should  have to write {{SELECT * FROM foo WHERE key = ’k’ AND col1 = ’c’ AND col2 =  null}}. Which I am fne with leaving out for now, since we’ve ignored {{null}} so far in  CQL, but the behavior of {{SELECT * FROM foo WHERE key = ’k’ AND col1 = ’c’}}  should defnitely be ""all columns with prefx c.""",,Run-time quality issues,9:1769 - 9:2147,1,arjan
20:42,"So maybe we need to disallow that too  temporarily, until we’ve done s…",CASSANDRA-3761,"So maybe we need to disallow that too  temporarily, until we’ve done some of the work for CASSANDRA-3237",,Architectural component behavior and structure,9:2150 - 9:2253,1,arjan
20:43,"I’m still looking over this, but I thought I’d mention that I’m unable…",CASSANDRA-3761," I’m still looking over this, but I thought I’d mention that I’m unable to get the  tests to pass (most of them produce errors). For example:  8
$ nosetests -sxv cql_tests.pycql_tests.TestCQL.counters_test ... ERROR  ======================================================================  ERROR: cql_tests.TestCQL.counters_test  ----------------------------------------------------------------------  Traceback (most recent call last):  File ""/usr/lib/pymodules/python2.7/nose/case.py"", line 187, in runTest  self.test(*self.arg)  File ""/home/eevans/dev/src/git/cassandra/cql_tests.py"", line 339,  in counters_test  cursor.execute(""UPDATE clicks SET total = total + 1 WHERE userid  = 1 AND url = ’http://foo.com’"")  File ""/usr/local/lib/python2.7/dist-packages/cql/cursor.py"", line  89, in execute  raise cql.ProgrammingError(""Bad Request: %s"" % ire.why)  ProgrammingError: Bad Request: line 1:79 mismatched character ’<EOF>’  expecting ’’’  ----------------------------------------------------------------------  Ran 1 test in 1.871s  FAILED (errors=1)  In this case, the error actually seems to make sense. Since {{//}} is recognized as a com-  ment. Did the wrong version of the tests get attached maybe?
Another example is:  NameError: global name ’assert_invalid’ is not defined  Where is {{assert_invalid}} meant to come from?
",,,9:2270 - 10:1190,1,arjan
20:44,"Also, I think the patches needs to be rebased in the wake of #3689 (al…",CASSANDRA-3761,"Also, I think the patches needs to be rebased in the wake of #3689 (although I think the  conficts are minor).
",,,10:1191 - 10:1302,1,arjan
20:45,"Question: in your Standard ""dynamic"" CF example from create_cf_syntaxe…",CASSANDRA-3761,"Question: in your Standard ""dynamic"" CF example from create_cf_syntaxes.txt:  CREATE TABLE clicks (  userid uuid,  url text,  timestamp date  PRIMARY KEY (userid, url)  ) WITH COMPACT STORAGE  I assume I can do a column slice using something like:  9
SELECT timestamp FROM clicks WHERE userid = ’...’ and url >= ’...’ and  url <= ’...’;  Correct?
",,,10:1328 - 11:97,1,arjan
20:77,tvoneicken,CASSANDRA-3761,tvoneicken,,Comment,11:102 - 11:111,1,arjan
20:46,"The answer is ""yes"". Why? I’m fnding it very useful to abuse the wide-…",CASSANDRA-3761,"The answer is ""yes"". Why? I’m fnding it very useful to abuse the wide-row column names  a little bit to be able to group rows and be able to operate on them in bulk. It’s typically  not in the frequent query path but required for management operations.
One example: a system that stores snippets from web server logs. Each snippet is a row,  each line a column, the column names simple line numbers 1, 2, 3, ... The row key is a  snippet id. Data is entered in real time and I need to purge old data after a certain retention  period measured in days. To do that, I abuse column 0 to store the date and put an index  on that. To remove data for a day I traverse this secondary index.
Second example: a multi-tenant system where the data has some wide rows. We need  to extract a user’s data for a variety of purposes, for example to migrate the data to a  diferent cluster. We again abuse the column names a bit and add a user_id column with a  secondary index.
",,User requirement,11:357 - 11:1321,1,arjan
20:47,Unless I completely misunderstood your statement above and these secon…,CASSANDRA-3761,"Unless I completely misunderstood your statement above and these secondary indexes are  possible in cql3, I suspect your answer will be to use a separate CF, but that does put a lot  more burden on the app, the avoidance of which is one the big benefts of secondary indexes.
",,Architectural solution benefits and drawbacks,11:1322 - 11:1597,1,arjan
20:78,slebresne,CASSANDRA-3761,slebresne,,Comment,11:1602 - 11:1610,1,arjan
20:48,Attached rebased and update patch set.,CASSANDRA-3761,Attached rebased and update patch set.,,,11:1613 - 11:1650,1,arjan
20:49,* Refactored a bit using the ’builder approach’ I talked earlier on. I…,CASSANDRA-3761,"* Refactored a bit using the ’builder approach’ I talked earlier on. It does simplify a bunch  of case. I’ve removed the CFDefnition.Kind enum and instead keep just two isComposite  and isCompact fags. It’s equivalent to the previous enum but maybe more clear and in any  case we now have the code for dense and dynamic that are always shared, and the one for  static and sparse almost always too.
",,,11:1666 - 11:2064,1,arjan
20:50,* Removed support for adding non-EQ clause on the row keys with RP (we…,CASSANDRA-3761,"* Removed support for adding non-EQ clause on the row keys with RP (we’ll deal with it  in CASSANDRA-3771).
",,,11:2065 - 11:2173,1,arjan
20:51,* Change the behavior of selecting on composite without giving all the…,CASSANDRA-3761,* Change the behavior of selecting on composite without giving all the components. It’ll  now select all the record having the given prefx (for which we don’t really need CASSAN-  DRA_3237).,,Architectural component behavior and structure,11:2174 - 11:2363,1,arjan
20:52,Ok for adding null support later,CASSANDRA-3761,Ok for adding null support later,,Architectural solution benefits and drawbacks,11:2365 - 11:2396,1,arjan
20:53,To avoid rebase problem I’ve also pushed the branch on https://github.…,CASSANDRA-3761,"To avoid rebase problem I’ve also pushed the branch on https://github.com/pcmanus/cassandra/tree/cql3  (6fdf3447b29f36050).
",,,11:2399 - 11:2523,1,arjan
20:54,"For the tests, I have them all passing here, but for the ’assert_inval…",CASSANDRA-3761,"For the tests, I have them all passing here, but for the ’assert_invalid’, I added it to  dtests but forgot to push it publicly. I’ve created https://github.com/riptano/cassandra-  dtest/tree/cql3_tests with an updated version of the tests (I only tested cql_test.py on this  branch so far).
",,,11:2524 - 11:2816,1,arjan
20:79,slebresne,CASSANDRA-3761,slebresne,,Comment,11:2821 - 11:2829,1,arjan
20:55,You assume well.,CASSANDRA-3761,"You assume well.
",,,11:2903 - 11:2920,1,arjan
20:56,"I note your objection and use case. But to be clear, I only meant that…",CASSANDRA-3761,"I note your objection and use case. But to be clear, I only meant that the current patch  don’t support secondary indexes on wide rows, not that CQL 3 wouldn’t ultimately support  them. I just meant that I’d prefer pushing support to a following ticket.
",,Architectural component behavior and structure,12:13 - 12:267,1,arjan
20:57,What is the new equivalent of Kind.static then? !composite && !compact…,CASSANDRA-3761,"What is the new equivalent of Kind.static then? !composite && !compact?
",,,12:385 - 12:457,1,arjan
20:80,slebresne,CASSANDRA-3761,slebresne,,Comment,12:462 - 12:470,1,arjan
20:58,"Yes. But static is just the simplest possible sparse, so we almost nev…",CASSANDRA-3761,"Yes. But static is just the simplest possible sparse, so we almost never test for that, we  just have 2 cases: compact or !compact (the only place were static does difer of sparse is  when transforming a query result into a resultSet, where we have to ""group"" columns for the  sparse case).
",,Architectural component behavior and structure,12:550 - 12:841,1,arjan
20:81,jbellis,CASSANDRA-3761,jbellis,,Comment,12:846 - 12:852,1,arjan
20:59,"+1 from me, assuming we get the python driver kinks worked out, and pe…",CASSANDRA-3761,"+1 from me, assuming we get the python driver kinks worked out, and pending  Eric’s review",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",12:855 - 12:944,2,arjan
20:82,urandom,CASSANDRA-3761,urandom,,Comment,12:951 - 12:957,1,arjan
20:60,"I’m still poking at it, but I was just about to suggest that we go ahe…",CASSANDRA-3761,"I’m still poking at it, but I was just about to suggest that we go ahead and commit it  now.
",,Architectural solution benefits and drawbacks,12:1056 - 12:1149,1,arjan
20:61,"Also, IMO, since this is an explicitly experimental feature, and becau…",CASSANDRA-3761,"Also, IMO, since this is an explicitly experimental feature, and because it could beneft  from rapid iteration, I don’t think we should subject it to the usual rules for a freeze. In  fact, we should also relax the ticket/review requirement, particular for simple issues that  have no bearing on any of the discussed semantics.
",,,12:1150 - 12:1478,1,arjan
20:62,"Ok, I’ll commit it",CASSANDRA-3761,"Ok, I’ll commit it",,,12:1592 - 12:1609,1,arjan
20:63,Agreed on both count. Let’s still be careful not to break stufs too mu…,CASSANDRA-3761,"Agreed on both count. Let’s still be careful not to break stufs too much though: it wouldn’t  look too nice if this was broken because of a stupid typo or something in the fnal 1.1, even  if that’s just a ’developer preview’.",,,12:1732 - 12:1956,1,arjan
20:64,"I’m good with committing directly obvious bug fx, but I think I’d pref…",CASSANDRA-3761,"I’m good with committing directly obvious bug fx, but I think I’d prefer we stick with  tickets and review for anything bigger. If only because it facilitates synchronization between  us. But also because I think reviews help keeping the code cleaner and more bug-free imho,  even if that slows slightly the process (and it allows better tracing of the changes).
",,,12:2102 - 12:2465,1,arjan
20:65,What would be nice would be to make every ticket targeting cql 3 sub-t…,CASSANDRA-3761,"What would be nice would be to make every ticket targeting cql 3 sub-task of this ticket.
Or at least that we tag them with cql3.
",,,12:2466 - 12:2597,1,arjan
20:66,Of course.,CASSANDRA-3761,"Of course.
",,,13:245 - 13:256,1,arjan
20:67,"Right, my thinking was that as of right now, it could beneft more from…",CASSANDRA-3761,"Right, my thinking was that as of right now, it could beneft more from rapid iteration  than from exhaustive review. Obviously, that picture changes as things become more solid  and there is less low-hanging fruit.
Anyway, I think what I’m advocating for is common-sense, and it doesn’t sound like we  disagree.
",,,13:626 - 13:939,1,arjan
20:68,Agreed (to both).,CASSANDRA-3761,"Agreed (to both).
",,,13:1076 - 13:1094,1,arjan
20:69,We don’t. I’ve committed the patches above. I had to rebase following…,CASSANDRA-3761,"We don’t.
I’ve committed the patches above. I had to rebase following CASSANDRA-1391 which  involved a few changes. I’m attaching those changes as patch 0005 here for reference.
I’me leaving this ticket open on purpose, so that it stays the main ticket for all the sub-tasks  to get this to a 3.0 fnal.
",,,13:1212 - 13:1517,1,arjan
20:70,We’re about to ship this in 1.2 so let’s close this now.,CASSANDRA-3761,"We’re about to ship this in 1.2 so let’s close this now.
",,,13:1533 - 13:1590,1,arjan
21:3,Support multiple ranges in SliceQueryFilter,CASSANDRA-3885,Support multiple ranges in SliceQueryFilter,,User requirement,3:52 - 3:94,1,arjan
21:1,"This is logically a subtask of CASSANDRA-2710, but Jira doesn’t allow…",CASSANDRA-3885,"This is logically a subtask of CASSANDRA-2710, but Jira doesn’t allow sub-sub-tasks.
",,,3:114 - 3:199,1,arjan
21:2,"We need to support multiple ranges in a SliceQueryFilter, and we want…",CASSANDRA-3885,"We need to support multiple ranges in a SliceQueryFilter, and we want querying them to be  efcient, i.e., one pass through the row to get all of the ranges, rather than one pass per range.
",,"Quality Attribute requirement
User requirement",3:200 - 3:389,2,arjan
21:4,Supercolumns are irrelevant since the goal is to replace them anyway.…,CASSANDRA-3885,"Supercolumns are irrelevant since the goal is to replace them anyway. Ignore supercolumn-related  code or rip it out, whichever is easier.
",,Architectural design configuration,3:390 - 3:529,1,arjan
21:5,"This is ONLY dealing with the storage engine part, not the StorageProx…",CASSANDRA-3885,"This is ONLY dealing with the storage engine part, not the StorageProxy and Command intra-node  messages or the Thrift or CQL client APIs.",,Architectural design configuration,3:530 - 3:667,1,arjan
21:6,"Thus, a unit test should be added to ColumnFamily-  StoreTest to demon…",CASSANDRA-3885,"Thus, a unit test should be added to ColumnFamily-  StoreTest to demonstrate that it works.
",,,3:669 - 3:761,1,arjan
21:7,(Most of the work will be pushed down into Memtable.getSliceIterator a…,CASSANDRA-3885,(Most of the work will be pushed down into Memtable.getSliceIterator and SSTa-  bleSliceIterator.),,,4:27 - 4:124,1,arjan
21:85,dr-alves,CASSANDRA-3885,dr-alves,,Comment,4:130 - 4:137,1,arjan
21:8,"Here’s a patch that implements multi-slice in ISR, it behaves pretty m…",CASSANDRA-3885,"Here’s a patch that implements multi-slice in ISR, it behaves pretty much as  expected/suggested, additionally it implements re-read prevention. to clarify:  - for forward scans it checks whether the next slice is within the current index segment and  continues the scan there if it is.
- for reverse scans it stores the columns before the current range, in cache. if the next range  (which in reverse is before) starts/uses the same index segment the it uses the cache instead  of re-reading the columns.
",,Architectural component behavior and structure,4:140 - 4:647,1,arjan
21:9,The test also reduces the number of bytebufer comparisons in computeNe…,CASSANDRA-3885,"The test also reduces the number of bytebufer comparisons in computeNext() as all the  columns added to blockColumns are within the argument ranges and may be read so there  is no need to make range checks.
",,"Architectural component behavior and structure
Architectural tactics",4:648 - 4:855,2,arjan
21:10,The patch slightly changes SliceQueryFilter to use range sets but main…,CASSANDRA-3885,"The patch slightly changes SliceQueryFilter to use range sets but maintains backwards com-  patibility. Public access to start and fnish is changed to be done through accessors.
",,Architectural component behavior and structure,4:856 - 4:1034,1,arjan
21:11,The patch includes a somewhat (maybe too) verbose test of the new and…,CASSANDRA-3885,"The patch includes a somewhat (maybe too) verbose test of the new and old behavior.
",,,4:1035 - 4:1119,1,arjan
21:12,The slice reader assumes that either the whole ranges are read reverse…,CASSANDRA-3885,"The slice reader assumes that either the whole ranges are read reversed or not (there are no  forward+reversed range mix).
The slice reader assumes that ranges are sorted correctly, e.g. that for forward lookup  ranges are in lexicographic order of start elements and that for reverse lookup they are in  reverse lexicographic order of fnish (reverse start) elements. i.e. forward: [a,b],[d,e],[g,h] re-  verse: [h,g],[e,d],[b,a]. The reader also assumes that validation has been performed in terms  of intervals (no overlapping intervals).
",,Architectural component behavior and structure,4:1120 - 4:1662,1,arjan
21:13,Tests are *mostly* green with the following exception:  [junit] Testsu…,CASSANDRA-3885,"Tests are *mostly* green with the following exception:  [junit] Testsuite: org.apache.cassandra.db.CommitLogTest  [junit] Tests run: 1, Failures: 0, Errors: 1, Time elapsed: 0 sec  [junit] [junit] Testcase: org.apache.cassandra.db.CommitLogTest:terminated successfully: Caused  an ERROR  [junit] Timeout occurred. Please note the time in the report does not refect the time until  the timeout.
[junit] junit.framework.AssertionFailedError: Timeout occurred. Please note the time in the  report does not refect the time until the timeout.
[junit] [junit] [junit] Test org.apache.cassandra.db.CommitLogTest FAILED (timeout)",,,4:1663 - 4:2285,1,arjan
21:86,vijay2win@yahoo.com,CASSANDRA-3885,vijay2win@yahoo.com,,Comment,4:2291 - 4:2309,1,arjan
21:14,Thanks for the patch,CASSANDRA-3885,Thanks for the patch,,Architectural solution benefits and drawbacks,4:2321 - 4:2340,1,arjan
21:18,1) We should not be hand editing generated code/ SliceRange.,CASSANDRA-3885,"1) We should not be hand editing generated code/ SliceRange.
",,,4:2398 - 4:2459,1,arjan
21:15,2) Can we avoid doing ranges = ranges.toArray(new SliceRange[ranges.si…,CASSANDRA-3885,2) Can we avoid doing ranges = ranges.toArray(new SliceRange[ranges.size()]); to avoid un-  necessary copies,,"Architectural component behavior and structure
Architectural tactics",4:2460 - 4:2567,2,arjan
21:17,3) we should not create org.apache.cassandra.thrift.SliceRange inside…,CASSANDRA-3885,"3) we should not create org.apache.cassandra.thrift.SliceRange inside of SliceQueryFilter we  might want to keep the dependency of the thrift outside of the storage layer.
",,,4:2570 - 4:2742,1,arjan
21:16,4) not sure about the caching the results... We can just validate it i…,CASSANDRA-3885,"4) not sure about the caching the results... We can just validate it in the thrift layer so users  will send proper query (this reduces complexity and comparison on reads)?
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",4:2743 - 4:2916,2,arjan
21:87,dr-alves,CASSANDRA-3885,dr-alves,,Comment,5:4 - 5:11,1,arjan
21:19,"Sorry for the delay also, somehow I didn’t get notifed that the issue…",CASSANDRA-3885,"Sorry for the delay also, somehow I didn’t get notifed that the issue was updated/com-  mented.",,,5:24 - 5:118,1,arjan
21:20,"1) - With regard to SliceRange you’re right, I just wanted to get some…",CASSANDRA-3885,"1) - With regard to SliceRange you’re right, I just wanted to get some feedback before chang-  ing thrift stuf",,,5:121 - 5:230,1,arjan
21:21,"2) - We can defnitely avoid that, maybe make IndexedSliceReader receiv…",CASSANDRA-3885,"2) - We can defnitely avoid that, maybe make IndexedSliceReader receive the ranges as an  array?
",,Architectural component behavior and structure,5:233 - 5:330,1,arjan
21:22,3) - Hadn’t thought about that... maybe we could have a internal (with…,CASSANDRA-3885,"3) - Hadn’t thought about that... maybe we could have a internal (within org.apache.cassandra.db)  version and transform?
",,,5:331 - 5:453,1,arjan
21:23,"4) - Cacheing the results is not about query validation, at least I ca…",CASSANDRA-3885,"4) - Cacheing the results is not about query validation, at least I can’t see how better query  validation would discard the necessity of cacheing to avoid re-reads. There is always a sce-  nario where cacheing the results avoids re-reads (when we’re sure that the next reversed  range will need them)",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:454 - 5:754,2,arjan
21:24,the thing is that right now we’re cacheing without knowing wether  the…,CASSANDRA-3885,the thing is that right now we’re cacheing without knowing wether  they will be necessary (vs making sure the previous range will need them). In any case the  maximum that gets cached is an index range of records per query so that might not be a  terrible issue.,,Run-time quality issues,5:757 - 5:1018,1,arjan
21:88,dr-alves,CASSANDRA-3885,dr-alves,,Comment,5:1043 - 5:1050,1,arjan
21:25,"- A slice range is now specifed as a ColumnSlice, a db package immutab…",CASSANDRA-3885,"- A slice range is now specifed as a ColumnSlice, a db package immutable object.
- Ranges are passed as arrays and never changed or copied.
",,Architectural component behavior and structure,5:1104 - 5:1245,1,arjan
21:26,The only thing that was not addressed was the cache issue. IMO cache i…,CASSANDRA-3885,The only thing that was not addressed was the cache issue. IMO cache is useful as it  prevents disk rereads.,,Architectural solution benefits and drawbacks,5:1246 - 5:1353,1,arjan
21:27,"It *might* be better to make sure columns are needed, but even that  I…",CASSANDRA-3885,"It *might* be better to make sure columns are needed, but even that  I’m really not sure since making sure would require a series of bytebufer comparisons, and  keeping a single index-lenght (max) of cols is probably not that bad.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:1355 - 5:1586,2,arjan
21:89,vijay2win@yahoo.com,CASSANDRA-3885,vijay2win@yahoo.com,,Comment,5:1590 - 5:1608,1,arjan
21:28,"We can validate and also rewrite the query, Example: user wants a quer…",CASSANDRA-3885,"We can validate and also rewrite the query, Example: user wants a query from {A:B-A:D,  A:D-A:H, A:D-A:G} can be rewritten as {A:B-A:H}... End of the day the user needs a list  of sorted columns.
",,Architectural design configuration,5:1802 - 5:1998,1,arjan
21:29,"In addition with the new patch: ColumnSlice can be a Pair<T1,T2>, (but…",CASSANDRA-3885,"In addition with the new patch: ColumnSlice can be a Pair<T1,T2>, (but I thought we also  need count and isReverse in it?)",,Architectural component behavior and structure,5:1999 - 5:2120,1,arjan
21:90,dr-alves,CASSANDRA-3885,dr-alves,,Comment,5:2126 - 5:2133,1,arjan
21:31,"Now I understand what you were saying, but cacheing is used in a difer…",CASSANDRA-3885,"Now I understand what you were saying, but cacheing is used in a diferent circumstance",,Architectural solution benefits and drawbacks,5:2184 - 5:2269,1,arjan
21:30,In  fact the IndexedReader assumes that the query has already been ade…,CASSANDRA-3885,In  fact the IndexedReader assumes that the query has already been adequately rewritten and  that ranges are in order (either forward or reverse) and non-overlapping.,,Architectural component behavior and structure,5:2272 - 5:2437,1,arjan
21:32,"Cacheing is used in the following, very particular, circumstance, lets…",CASSANDRA-3885,"Cacheing is used in the following, very particular, circumstance, lets say we the follow-  ing columns: a, b, c, d, e, f and that index segments cover the columns as such i1=[a-c]  i2=[e-f] and that we want the following (reversed) ranges [f-e] [d-b]. We start by looking for  the index segment for ""f"" which falls into i2 and we’ll deserialize columns d through f. Now  4
while the the current range we’re looking for only needs ""e"" and ""f"" we have also deserialized  ""d"". Had we not cached ""d"" we would have to re-read the ""d"" to handle the next range (now  [d-b]), but because we cached it we don’t. In general if the next range requires any of the  data we’ve already read we’re sure to have it in cache and won’t need to re-read, if it doesn’t  we clear the cache.
As you can see it’s a very particular optimization for indexed, reverse reads.
",,"Architectural component behavior and structure
Architectural tactics",5:2440 - 6:478,2,arjan
21:91,dr-alves,CASSANDRA-3885,dr-alves,,Comment,6:482 - 6:489,1,arjan
21:33,"With regard to count/reverse per slice, I tried to keep it relatively…",CASSANDRA-3885,"With regard to count/reverse per slice, I tried to keep it relatively simple. My  reasoning was that writing a query that specifes count and order (fwd,rev) per slice would  be hard to do clearly, grammar wise, and that most people would mostly global (for all  ranges) ordering and counting.",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",6:492 - 6:783,2,arjan
21:34,That being said I can always rewrite if people think that per  slice c…,CASSANDRA-3885,"That being said I can always rewrite if people think that per  slice count and order are important.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",6:785 - 6:885,2,arjan
21:92,dr-alves,CASSANDRA-3885,dr-alves,,Comment,6:889 - 6:896,1,arjan
21:35,"Refactored to use Pair<ByteBufer,ByteBufer> instead of ColumnSlice.",CASSANDRA-3885,"Refactored to use Pair<ByteBufer,ByteBufer> instead of ColumnSlice.
",,Architectural component behavior and structure,6:899 - 6:967,1,arjan
21:93,slebresne,CASSANDRA-3885,slebresne,,Comment,6:999 - 6:1007,1,arjan
21:36,"That’s what looks wrong to me (without having read the patch, I’ll adm…",CASSANDRA-3885,"That’s what looks wrong to me (without having read the patch, I’ll admit). It seems that  as soon as we deserialize ""d"", we should realize that we’re outside of [f-e] and thus we should  start considering [d-b] and as such add the column to the result without a need for caching.
Provided the requested range don’t overlap (which I agree could be assumed by the sstable  reader and validated way upfront), we shouldn’t need to deserialize anything twice and we  shouldn’t need any cache.
",,Architectural component behavior and structure,6:1119 - 6:1607,1,arjan
21:94,dr-alves,CASSANDRA-3885,dr-alves,,Comment,6:1613 - 6:1620,1,arjan
21:37,keep comparing every column to see if it matches the previous range (t…,CASSANDRA-3885,keep comparing every column to see if it matches the previous range (the next  range to be processed in reverse) doing two bb comparisons and then store it for later if yes  (because we’re not fnished with the current range) ,,Architectural component behavior and structure,6:1783 - 6:2007,1,arjan
21:38,simply storing anyway it in the case  it is needed.,CASSANDRA-3885,"simply storing anyway it in the case  it is needed.
",,Architectural component behavior and structure,6:2011 - 6:2062,1,arjan
21:39,"I fgured the latter option would probably be faster, but I might be wr…",CASSANDRA-3885,"I fgured the latter option would probably be faster, but I might be wrong.
",,"Architectural tactics
Assumptions",6:2064 - 6:2139,2,arjan
21:95,slebresne,CASSANDRA-3885,slebresne,,Comment,6:2144 - 6:2152,1,arjan
21:40,Yeah but we kind of do that in the current code already with the queue…,CASSANDRA-3885,"Yeah but we kind of do that in the current code already with the queue {{blockColumns}}.
{{blockColumns}} is a cache of sorts and that’s why I think we shouldn’t add a second one.
",,Architectural solution benefits and drawbacks,6:2211 - 6:2392,1,arjan
21:41,"Much like we currently do, during deserialization we can simply check…",CASSANDRA-3885,"Much like we currently do, during deserialization we can simply check if it’s worth deserial-  izing the next column of the block (which should only mean comparing each column once,  against the ""biggest"" range intersecting the index block). Then, in computeNext(), when  polling the column from {{blockColumns}} we can validate if the column is really needed  (again, since we know the order in which we poll the column, this should only require com-  parison to one of the range). This should be roughly equivalent to the cache of your patch,  but it avoids having both {{blockColumns}} and the cache.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",6:2393 - 6:2997,2,arjan
21:96,dr-alves,CASSANDRA-3885,dr-alves,,Comment,6:3002 - 6:3009,1,arjan
21:42,The new version of the code has one diferece in regard to the blockCol…,CASSANDRA-3885,"The new version of the code has one diferece in regard to the blockColumns  queue, that’s that it never adds values to it that aren’t going to be necessary (as as done  previously) so the blockColumns queue is not really a cache at all, all values there are re-  turned (if computNext() is called, of course) that’s why the ""cache"" is needed only for a  (partial) index segment size and only in reverse. In fact I can add couple of bb checks and  5
it is no longer a cache and simply stuf that hasn’t been added to the blockColumns queue yet.
",,Architectural component behavior and structure,6:3012 - 7:94,1,arjan
21:43,Do you think it’s important to change the code to mimic how it behaved…,CASSANDRA-3885,"Do you think it’s important to change the code to mimic how it behaved before?
",,Architectural component behavior and structure,7:96 - 7:175,1,arjan
21:97,slebresne,CASSANDRA-3885,slebresne,,Comment,7:180 - 7:188,1,arjan
21:44,"It’s not so much about necessarily mimicking the current behavior, but…",CASSANDRA-3885,"It’s not so much about necessarily mimicking the current behavior, but that  the cache make the code a lot more disymetric between forward and reverse slices, which  imo makes it harder to follow and more prone to having bug for reversed but not forward  slices",,Architectural solution benefits and drawbacks,7:191 - 7:451,1,arjan
21:45,"Also (and though that is arguably minor), reusing the {{blockColumns}}…",CASSANDRA-3885,"Also (and though that is arguably minor), reusing the {{blockColumns}} queue as  the ""cache"" as is done currently saves the cache allocation.
",,Architectural solution benefits and drawbacks,7:454 - 7:595,1,arjan
21:98,slebresne,CASSANDRA-3885,slebresne,,Comment,7:601 - 7:609,1,arjan
21:46,"On an unrelated note, I disagree with using Pair<ByteBufer, ByteBufer>…",CASSANDRA-3885,"On an unrelated note, I disagree with using Pair<ByteBufer, ByteBufer>  everywhere in the code, as it’s not explicit enough (and it’s a lot more character than worth  it)",,Architectural solution benefits and drawbacks,7:612 - 7:781,1,arjan
21:47,So I (strongly) think we should defne a specifc class for this (say Co…,CASSANDRA-3885,"So I (strongly) think we should defne a specifc class for this (say ColumnRange). *But*,  I’m fne having that class extends {{Pair<ByteBufer, ByteBufer>}}, it’s only a matter of  having an explicit name.
",,Architectural component behavior and structure,7:784 - 7:988,1,arjan
21:99,dr-alves,CASSANDRA-3885,dr-alves,,Comment,7:993 - 7:1000,1,arjan
21:48,With regard to bugs that’s why theres’ extensive testing.,CASSANDRA-3885,"With regard to bugs that’s why theres’ extensive testing.
",,,7:1063 - 7:1121,1,arjan
21:49,With regard to the symmetry of forward and reverse it is indeed broken…,CASSANDRA-3885,"With regard to the symmetry of forward and reverse it is indeed broken but because the two  operations (IMO) are really not symmetric since columns are always read from left to right.
Not adding unnecessary data to blockColumns prevents having to check ranges for every  tuple that comes out of it as was done before, which i think is an advantage in most cases  but that bears the penalty of making it impossible to add out-of-order values (as was done  before because values were always range-checked twice). Moreover the code is now naturally  more complex because the operation is more complex.
",,Architectural solution benefits and drawbacks,7:1122 - 7:1722,1,arjan
21:50,"All in all I think that most of what you’re saying makes sense, but si…",CASSANDRA-3885,"All in all I think that most of what you’re saying makes sense, but since things are work-  ing (and commented throughout) I’d prefer to leave it",,"Architectural solution benefits and drawbacks
Assumptions",7:1723 - 7:1867,2,arjan
21:51,"With regard to the Pair<ByteBufer,ByteBufer> I agree, I think I jumped…",CASSANDRA-3885,"With regard to the Pair<ByteBufer,ByteBufer> I agree, I think I jumped the gun on  that. I particularly don’t like the the unchecked casts when using arrays. I’ll change that as  per your suggestion.
",,Architectural solution benefits and drawbacks,7:2024 - 7:2224,1,arjan
21:100,jbellis,CASSANDRA-3885,jbellis,,Comment,7:2229 - 7:2235,1,arjan
21:52,"While I’m sympathetic to the time spent getting code working, one of t…",CASSANDRA-3885,"While I’m sympathetic to the time spent getting code working, one of the reasons  we do code reviews is we have a strong bias towards doing things ""right"" as opposed to ""good  enough."" Granted, that can be taken too far, but I’m pretty happy with the balance we’ve  achieved between improving what we commit on the one hand, and bikeshedding on the  other.
",,,7:2238 - 7:2595,1,arjan
21:53,"In short, I’d like to see Sylvain’s remaining concerns addressed. Of c…",CASSANDRA-3885,"In short, I’d like to see Sylvain’s remaining concerns addressed. Of course, reviewers aren’t  infallible either, and getting rid of the cache (for instance) may not actually produce much  simplifcation, but in the interest of achieving consensus it’s worth spending the time to try  a second approach.
",,Architectural solution benefits and drawbacks,7:2596 - 7:2899,1,arjan
21:101,dr-alves,CASSANDRA-3885,dr-alves,,Comment,7:2904 - 7:2911,1,arjan
21:54,I’m sorry I wasn’t able to explain myself better. It’s not that I woul…,CASSANDRA-3885,"I’m sorry I wasn’t able to explain myself better. It’s not that I wouldn’t want to change  things, it’s that the most straightforward to use the same add cols and then recheck approach  is to add more checks to the isColumnNeeded method and that is not a good idea since it  is pretty convoluted and slow as is (ran some tests and the cache version vs the add the  recheck version is about 5-10% faster about 5 on forward reads and 10 on reverse).
",,Architectural solution benefits and drawbacks,7:2928 - 7:3376,1,arjan
21:55,Still in retrospective the code surely be improved lot in terms or rea…,CASSANDRA-3885,"Still in retrospective the code surely be improved lot in terms or readability and Sylvain  has made a couple of interesting suggestions that I’m trying out, hopefully we’ll get the best  of both worlds.
",,,8:1 - 8:205,1,arjan
21:102,dr-alves,CASSANDRA-3885,dr-alves,,Comment,8:210 - 8:217,1,arjan
21:56,much simple and readable patch (imo). - adds a column slice object (ge…,CASSANDRA-3885,"much simple and readable patch (imo).
- adds a column slice object (gets rid of the nasty unchecked cast warnings)  - gets rid of the isColumnNeeded method and diminishes the number of bb comparisons",,Architectural component behavior and structure,8:220 - 8:419,1,arjan
21:57,corrected a bug where in reverse the index was being looked up based o…,CASSANDRA-3885,"corrected a bug where in reverse the index was being looked up based on the start  of the slice and not on the fnish.
",,,8:436 - 8:554,1,arjan
21:103,vijay2win@yahoo.com,CASSANDRA-3885,vijay2win@yahoo.com,,Comment,8:559 - 8:577,1,arjan
21:58,SliceQueryFilter.serializer needs to deal with Multiple ColumnSlice’s,CASSANDRA-3885,SliceQueryFilter.serializer needs to deal with Multiple ColumnSlice’s,,Motivation of design issue,8:580 - 8:648,1,arjan
21:59,but why do we need to do this?,CASSANDRA-3885,"but why do we need to do this?
",,,8:853 - 8:884,1,arjan
21:60,In IndexedSliceReader itself is a iterator and within which there is S…,CASSANDRA-3885,"In IndexedSliceReader itself is a iterator and within which there is Simple and Indexed-  Fetcher which is also kind of a iterator ... it might be better to make IndexedSliceReader as  abstract class and add functionality into classes.
",,Architectural component behavior and structure,8:965 - 8:1201,1,arjan
21:104,dr-alves,CASSANDRA-3885,dr-alves,,Comment,8:1206 - 8:1213,1,arjan
21:61,I’m not completely sure I understood what you are asking. If you’re as…,CASSANDRA-3885,"I’m not completely sure I understood what you are asking. If you’re asking why the params  specify slices in reverse order when reading reversed, it was because I thought it would make  sense to specify the ranges we want the frst results to come from, frst.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",8:1252 - 8:1511,2,arjan
21:62,If you’re asking about this particular piece of code:  1 if (reversed…,CASSANDRA-3885,"If you’re asking about this particular piece of code:  1 if (reversed && readBackwards)  2 currentSlice--;  3 else  4 currentSlice++;  7
lets say we have the following two slices [a,c] [f,j] and, in reverse [j,f] [c,a]. In Indexed-  BlockFecther we always start with the frst slice ([a,c] and [j,f], respectively) and continue  from there as we want to make sure we don’t fetch more than necessary. In SimpleBlock-  Fecther however we always fetch the whole row so we might as well process [j,f] [c,a] as if it  were [a,c] [f,j] and simply add the blocks to the queue in reverse order. that’s why we read  reverse & backwards.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",8:1512 - 9:491,2,arjan
21:63,"Your question reminds me of one another one I had, though. Why don’t w…",CASSANDRA-3885,"Your question reminds me of one another one I had, though. Why don’t we make the  ""count"" information reach ISR so that we can stop at the precise point the user query spec-  ifes? It seems wasteful to be reading the whole row in SimpleBlockFetcher is the user only  requested the frst 5 cols. This wouldn’t work in reverse reads, of course, but would speed  up forward ones, which are probably the most frequent, no?
",,"Architectural component behavior and structure
Architectural tactics
Assumptions",9:518 - 9:936,3,arjan
21:64,I’m not sure I understood what you are suggesting... is it that we mov…,CASSANDRA-3885,"I’m not sure I understood what you are suggesting... is it that we move the code that  decides whether we need a Simple- or IndexedBlockFetcher out of ISR and make ISR itself  the parent abstract class to Simple- or IndexedBlockFetcher?
",,,9:1178 - 9:1415,1,arjan
21:105,slebresne,CASSANDRA-3885,slebresne,,Comment,9:1420 - 9:1428,1,arjan
21:65,Because it’s more complex than that. The fnal result is based on mergi…,CASSANDRA-3885,"Because it’s more complex than that. The fnal result is based on merging (potentially)  multiple sstables, so the Nth column in a given sstable is not necessarily the Nth returned  column.
",,Motivation of design issue,9:1555 - 9:1744,1,arjan
21:106,dr-alves,CASSANDRA-3885,dr-alves,,Comment,9:1749 - 9:1756,1,arjan
21:107,slebresne,CASSANDRA-3885,slebresne,,Comment,9:1782 - 9:1790,1,arjan
21:66,"Ok, I like the last patch much more and I’ve convinced myself that thi…",CASSANDRA-3885,"Ok, I like the last patch much more and I’ve convinced myself that this prefetched  thing is a good idea with multiple slices.
",,Architectural solution benefits and drawbacks,9:1793 - 9:1920,1,arjan
21:67,I believe this can be simpler a tiny bit further though. Typically the…,CASSANDRA-3885,"I believe this can be simpler a tiny bit further though. Typically the {{readBackward}}  business is a tad confusing and since only SimpleBlockFetcher really cares about it, it can  be moved there. ",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",9:1921 - 9:2118,2,arjan
21:68,I also think the switch of slice/lookup of index block can be cleaned…,CASSANDRA-3885,I also think the switch of slice/lookup of index block can be cleaned by  doing both together.,,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",9:2119 - 9:2212,2,arjan
21:69,"* Since we always know the order on which we read columns, we can reme…",CASSANDRA-3885,"* Since we always know the order on which we read columns, we can remember when we’ve  ""entered"" a slice to avoid a bunch of comparisons until we ""leave"" it.
* When we switch to the next slice, we must reuse the binary search to locate where that  new slice starts rather than going to the next block, otherwise we may end up reading lots  of unnecessary blocks.
",,"Architectural component behavior and structure
Architectural tactics",9:2339 - 9:2703,2,arjan
21:70,"I’ll note that imho, with those optimizations, SimpleSliceReader (not…",CASSANDRA-3885,"I’ll note that imho, with those optimizations, SimpleSliceReader (not to be confused with  SimpleBlockFetcher) isn’t really useful anymore, but we probably want to make sure by  8
benchmarking it.
",,"Architectural component behavior and structure
Assumptions",9:2704 - 10:17,2,arjan
21:71,"Anyway, outside of IndexedSliceReader, there was a few problems (that…",CASSANDRA-3885,"Anyway, outside of IndexedSliceReader, there was a few problems (that are all solved by  the attached v2):  * We needed to deal with multiple slices for the memtable iterator too, otherwise we’ll end  up returning the wrong columns.
* We needed to correctly serialize multiple slices for the inter-node protocol.
",,Motivation of design issue,10:19 - 10:333,1,arjan
21:72,"I’ll note that with this patch, db.SerializationsTest is broken, but t…",CASSANDRA-3885,"I’ll note that with this patch, db.SerializationsTest is broken, but that is no mystery: it’s  trying to read old messages using the current protocol version",,Motivation of design issue,10:334 - 10:490,1,arjan
21:73,"So I could regenerate the  binary messages, but I’m confused on what S…",CASSANDRA-3885,"So I could regenerate the  binary messages, but I’m confused on what SerializationsTest is actually testing. I though  it was making sure we don’t break backward compatibility. If we regenerate the binary  message at each release we’re not testing that at all.
ps: @david, it seems your editor is splitting lines where it shouldn’t and is reordering imports  in a way that don’t respect http://wiki.apache.org/cassandra/CodeStyle.
",,,10:493 - 10:925,1,arjan
21:74,PS: wrt to code style I’ve made changes to the imports to meet code st…,CASSANDRA-3885,"PS: wrt to code style I’ve made changes to the imports to meet code style, but I was  already using tjake’s cassandra eclipse profle...
",,,10:1021 - 10:1157,1,arjan
21:75,Patch needed rebase. Rebased version attached. I’ve also pushed it at…,CASSANDRA-3885, Patch needed rebase. Rebased version attached. I’ve also pushed it at https://github.com/pcmanus/cass,,,10:1172 - 10:1273,1,arjan
21:108,vijay2win@yahoo.com,CASSANDRA-3885,vijay2win@yahoo.com,,Comment,10:1280 - 10:1298,1,arjan
21:76,I always thought we have /cassandra/test/data/serialization/x.x if you…,CASSANDRA-3885,"I always thought we have /cassandra/test/data/serialization/x.x if you want to test the older  versions.
",,,10:1429 - 10:1534,1,arjan
21:77,LGTM +1,CASSANDRA-3885,LGTM +1,,Architectural solution benefits and drawbacks,10:1535 - 10:1541,1,arjan
21:78,nit: setStart() method should have a assert which will check if there…,CASSANDRA-3885,"nit: setStart() method should have a assert which will check if there is only one Slice.
kind of afects:  1 // As soon as we’d done our first call, we want to reset the start column if we’re  paging  2 if (isPaging)  3 ((SliceQueryFilter)initialFilter()).setStart(ByteBufferUtil.
EMPTY_BYTE_BUFFER);",,,10:1544 - 10:1844,1,arjan
21:79,PS: I was actually doing a parallel work without the prefetch queue an…,CASSANDRA-3885,"PS: I was actually doing a parallel work without the prefetch queue and thought of sharing.
(https://github.com/Vijay2win/cassandra/commit/31ca6fd9e1bafc1f4d8dfe858929586637bfdef#L3L18)",,,10:1847 - 10:2032,1,arjan
21:80,I still can’t apply this cleanly to trunk. as far as I can see from th…,CASSANDRA-3885," I still can’t apply this cleanly to trunk. as far as I can see from the 3885 branch  there are other changes in there beyond this patch that are more recent than the last change  to trunk.
Sylvain do you want me to try and pick that up? (i mean take what you did and make  it applicable to trunk)",,,10:2048 - 10:2345,1,arjan
21:81,Then you have the wrong version of trunk. The attached 3885-v2.txt pat…,CASSANDRA-3885,"Then you have the wrong version of trunk. The attached 3885-v2.txt patch applies cleanly  to current trunk (as of this comment).
31. slebresne: Be sure to check against http://git-wip-us.apache.org/repos/asf/cassandra.git,  not any other repository. In particular the github mirror very often get behind.
32. slebresne: bq. I always thought we have /cassandra/test/data/serialization/x.x if you  want to test the older versions.
Ok, I see. So there is diferent ant targets to run the serialization test against older version.
I’ve personally never ran that. Is there any reason why we don’t just always run the serial-  ization test on all versions?
But anyway, for this patch I’ll regenerate the message binaries for 1.2 before committing.
33. dr-alves: right, I can confrm that, sorry for the n00biness.
patch applies cleanly, running tests.
",,,11:166 - 11:1017,1,arjan
21:109,dr-alves,CASSANDRA-3885,dr-alves,,Comment,11:1022 - 11:1029,1,arjan
21:82,"+1  I reviewed the patch, looks good overall.",CASSANDRA-3885,"+1  I reviewed the patch, looks good overall.
",,Architectural solution benefits and drawbacks,11:1032 - 11:1078,1,arjan
21:83,I does not add failures other than the previously mentioned Serializat…,CASSANDRA-3885,"I does not add failures other than the previously mentioned SerializationTest (Compaction-  sTest fails on a diferent method, for a diferent reason on my pc, that’s expected right?).
",,,11:1079 - 11:1262,1,arjan
21:84,"Alright, committed. Thanks all.",CASSANDRA-3885,"Alright, committed. Thanks all.
",,,11:1278 - 11:1310,1,arjan
22:1,Support cql3 table defnitions in Hadoop InputFormat,CASSANDRA-4421,Support cql3 table defnitions in Hadoop InputFormat,,User requirement,3:52 - 3:102,1,arjan
22:2,"Hello,  i faced a bug while writing composite column values and follow…",CASSANDRA-4421,"Hello,  i faced a bug while writing composite column values and following validation on server side.
This is the setup for reproduction:  1. create a keyspace  create keyspace test with strategy_class = ’SimpleStrategy’ and strategy_options:replication_factor  = 1;  2. create a cf via cql (3.0)  create table test1 (  a int,  b int,  c int,  primary key (a, b)  );  If i have a look at the schema in cli i noticed that there is no column metadata for columns  not part of primary key.
create column family test1  with column_type = ’Standard’  and comparator = ’CompositeType(org.apache.cassandra.db.marshal.Int32Type,org.apache.cassandra.db.marshal.UTF8T  and default_validation_class = ’UTF8Type’  and key_validation_class = ’Int32Type’  and read_repair_chance = 0.1  and dclocal_read_repair_chance = 0.0  and gc_grace = 864000  and min_compaction_threshold = 4  2
and max_compaction_threshold = 32  and replicate_on_write = true  and compaction_strategy = ’org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy’  and caching = ’KEYS_ONLY’  and compression_options = {’sstable_compression’ : ’org.apache.cassandra.io.compress.SnappyCompressor’};  Please notice the default validation class: UTF8Type  Now i would like to insert value > 127 via cassandra client (no cql, part of mr-jobs). Have a  look at the attachement.
Batch mutate fails:  InvalidRequestException(why:(String didn’t validate.) [test][test1][1:c] failed validation)  A validator for column value is fetched in ThriftValidation::validateColumnData which returns  always the default validator which is UTF8Type as described above (The ColumnDefnition for  given column name ""c"" is always null)  In UTF8Type there is a check for  if (b > 127)  return false;  Anyway, maybe i’m doing something wrong, but i used cql 3.0 for table creation. I assigned  data types to all columns, but i can not set values for a composite column because the default  validation class is used.
I think the schema should know the correct validator even for composite columns. The usage  of the default validation class does not make sense.
",,"Assumptions
Run-time quality issues",3:122 - 4:1231,2,arjan
22:95,jbellis,CASSANDRA-4421,jbellis,,Comment,5:108 - 5:114,1,arjan
22:3,You need to use cqlsh to interact with cql3 table defnitions.,CASSANDRA-4421,"You need to use cqlsh to interact with cql3 table defnitions.
",,User requirement,5:117 - 5:179,1,arjan
22:4,"Oh, i got it, so it means we can not use MR-Jobs using ColumnFamilyOut…",CASSANDRA-4421,"Oh, i got it, so it means we can not use MR-Jobs using ColumnFamilyOut-  putFormat or BulkOutputFormat?",,,5:195 - 5:297,1,arjan
22:96,jbellis,CASSANDRA-4421,jbellis,,Comment,5:303 - 5:309,1,arjan
22:5,"I should say: you need to use cqlsh, or cql from the client (see comme…",CASSANDRA-4421,"I should say: you need to use cqlsh, or cql from the client (see comments on  CASSANDRA-4377).
",,User requirement,5:312 - 5:407,1,arjan
22:97,jbellis,CASSANDRA-4421,jbellis,,Comment,5:411 - 5:417,1,arjan
22:6,"You can still create appropriate composites from m/r, but the schema d…",CASSANDRA-4421,"You can still create appropriate composites from m/r, but the schema design doesn’t  ft in the structures thrift knows about. So just create a (int, ’c’) composite value and an int  column name and you’ll be fne.",,User requirement,5:420 - 5:631,1,arjan
22:7,The cli can’t display this metadata because it only knows  how to deal…,CASSANDRA-4421,"The cli can’t display this metadata because it only knows  how to deal with named non-composite columns.
",,Existing system architecture description,5:633 - 5:738,1,arjan
22:8,"Ah, well the issue was already closed so i didn’t care the attachement…",CASSANDRA-4421,"Ah, well the issue was already closed so i didn’t care the attachement. But  you are right, i had problems inserting data from thrift (via client.batch_mutate) to a cql3  cf. I just mentioned in the debugger, that ThriftValidation doesn’t know about metadata,  so default validator is always used which results in rejecting data on server side.
Sometimes it can be confusing when talking about cql 2, 3, cli,thrift etc. :)  Thanks.
",,,5:1014 - 5:1447,1,arjan
22:98,jbellis,CASSANDRA-4421,jbellis,,Comment,5:1451 - 5:1457,1,arjan
22:9,CASSANDRA-3647 makes map/reduce from Thrift more painful as well.,CASSANDRA-4421,"CASSANDRA-3647 makes map/reduce from Thrift more painful as well.
",,Run-time quality issues,5:1460 - 5:1526,1,arjan
22:10,"Add a CqlInputFormat, which is painful (see https://issues.apache.org/…",CASSANDRA-4421," Add a CqlInputFormat, which is painful (see https://issues.apache.org/jira/browse/CASSANDRA-  2878?focusedCommentId=13189138&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-  tabpanel#comment-13189138)",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:1543 - 5:1757,2,arjan
22:11,Add collections support to Thrift via String serialization (which has…,CASSANDRA-4421,Add collections support to Thrift via String serialization (which has the added beneft of  allowing clients to support collections w/o doing a full rewrite to cql3),,"Architectural design configuration
Architectural solution benefits and drawbacks",5:1762 - 5:1925,2,arjan
22:99,slebresne,CASSANDRA-4421,slebresne,,Comment,5:1931 - 5:1939,1,arjan
22:12,I’m not really sure what you have in mind but I’m not sure I’m a fan o…,CASSANDRA-4421,"I’m not really sure what you have in mind but I’m not sure I’m a fan of that idea. Supporting  collections on write is one thing, supporting in on reads is another. Do we really want to  add a new pass over the resulting columns in thrift to group those belonging to the same  collection? That sound very messy.
",,"Architectural solution benefits and drawbacks
Assumptions",5:2006 - 5:2317,2,arjan
22:13,"While this might be painful, I have a strong feeling that long term th…",CASSANDRA-4421,"While this might be painful, I have a strong feeling that long term this is probably the  right solution (one reason being if we ever want to support CASSANDRA-2478 for the input  format). On the painful part of this:  * on the short term, can’t we use the CQL processor client side to convert the select state-  ment to a thrift query (since we know how to do this for thrift queries)?
* on the slightly longer term, we will need general paging for CQL queries for CASSANDRA-  4415. Once that’s in, that should lift the main difculty, shouldn’t it?
",,"Architectural solution benefits and drawbacks
Assumptions",6:27 - 6:578,2,arjan
22:14,"But for this specifc issue, I suppose the patch I’ve attached to CASSA…",CASSANDRA-4421,"But for this specifc issue, I suppose the patch I’ve attached to CASSANDRA-4377 should  solve Bert’s problem.
",,Architectural design configuration,6:579 - 6:688,1,arjan
22:100,jbellis,CASSANDRA-4421,jbellis,,Comment,6:693 - 6:699,1,arjan
22:15,"Well, we know how to convert select to StorageProxy queries, which isn…",CASSANDRA-4421,"Well, we know how to convert select to StorageProxy queries, which isn’t quite the same  thing. So we’d probably need to shove an abstraction layer in there, which is already some  pretty thick code.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",6:871 - 6:1071,2,arjan
22:16,"Yes, I think it would.",CASSANDRA-4421,"Yes, I think it would.
",,Architectural solution benefits and drawbacks,6:1238 - 6:1261,1,arjan
22:17,10. slebresne: Unassigned myself for now because I’m really not an exp…,CASSANDRA-4421,"10. slebresne: Unassigned myself for now because I’m really not an expert of the InputFormat.
So if someone else want to pick it up, feel free to do it.
11. ondrej.cernos: Is this ticket really planned for 1.2.5?
",,,6:1262 - 6:1477,1,arjan
22:18,I have done some work on it. The pull is @https://github.com/riptano/c…,CASSANDRA-4421, I have done some work on it. The pull is @https://github.com/riptano/cassandra/pull/45,,,6:1492 - 6:1578,1,arjan
22:19,"Can you explain the approach you took? In particular, how do you handl…",CASSANDRA-4421,"Can you explain the approach you took? In particular, how do you handle paging?
",,,6:1594 - 6:1674,1,arjan
22:101,alexliu68,CASSANDRA-4421,alexliu68,,Comment,6:1679 - 6:1687,1,arjan
22:20,"There are no auto paging for CQL3, so I use a work around method to pa…",CASSANDRA-4421,"There are no auto paging for CQL3, so I use a work around method to page  through CQL wide rows. Basic idea is to use CQL3 query on the partition key and cluster  columns  1 e.g. PRIMARY(m, n , o, p) where partition key is m, cluster columns are n, o, p  for Query  1 Select * from test limit 1000;  We store the last values of m, n, o, p to m_end, n_end, O_end and p_end after the  initial 1000 rows  so the next page query is  5
1 Select * from testwhere token(m) = token (m_end) and n = n_end  2 and o = o_end  3 and p > p_end  4 Limit 1000  If it reach the end of O, then the next query is the following query  1 Select * from testwhere token(m) = toekn(m_end) and n = n_end  2 and o > o_end  3 Limit 1000  otherwise  1 Select * from testwhere token(m) = token (m_end) and n = n_end  2 and o = o_end  3 and p > p_end1  4 Limit 1000  until it reach to the next row, the query is  1 Select * from testwhere token(m) > token(m_end)Limit 1000  For the table has more than one columns in partition key  1 PRIMARY((m, n) , o, p) where partition key is m and n, cluster columns are o, p  we use the following query  1 Select * from testwhere token(m, n) > token(m_end, n_end)Limit 1000",,Architectural component behavior and structure,6:1690 - 7:751,1,arjan
22:102,alexliu68,CASSANDRA-4421,alexliu68,,Comment,7:758 - 7:766,1,arjan
22:21,User needs to pass the following settings to the job. 1 1. Keyspace an…,CASSANDRA-4421,"User needs to pass the following settings to the job.
1 1. Keyspace and Columnfamily name  2 2. intial host, port and Partitioner  3 2. Column names that need to be retrieved (optional), default are all the columns  4 3. the number of CQL rows per page (optional), default is 1000  5 4. User defined the where clauses on indexed columns (optional)",,User requirement,7:769 - 7:1116,1,arjan
22:22,"The input format is of List<IColumn>, Map<ByteBufer, IColumn>  where L…",CASSANDRA-4421,"The input format is of List<IColumn>, Map<ByteBufer, IColumn>  where List<IColumn> is the keys columns including partition keys and clustering keys  6
Map<ByteBufer, IColumn> is the map of CQL query output column name and column  Internally, we use the following CQL query  1 SELECT <columns> FROM <Column_family_name> WHERE <where_clause>  2 AND <user_defined_WhereClauses_on_indexed_column> LIMIT <page_row_size>  3 ALLOW FILTERING  4 5  <where_clause> could be any of the following format  6 WHERE token(<partition_key>) >= <start_token> AND token(<partition_key>) <= <  end_token>  7 or  8 WHERE token(<partition_key>) > token(<partition_key_value>) AN  9 D token(<partition_key>) <= <end_token>  10 or  11 WHERE token(<partition_key>) = token(<partition_key_value>) AND <clustering_key1  > = <key_value1>  12 AND <clustering_key2> > <key_value2>  13 AND token(<partition_key>) <= <end_token>  14 or  15 WHERE token(<partition_key>) = token(<partition_key_value>) AND <clustering_key1  > = <key_value1>  16 AND <clustering_key2> = <key_value2>  17 AND <clustering_key3> > <k  18 ey_value3>  19 AND token(<partition_key>) <= <end_token>",,Architectural component behavior and structure,7:1119 - 8:988,1,arjan
22:103,alexliu68,CASSANDRA-4421,alexliu68,,Comment,8:995 - 8:1003,1,arjan
22:23,"If we could get the auto paging through native protocol for CQL3, then…",CASSANDRA-4421,"If we could get the auto paging through native protocol for CQL3, then we can  easily implement the CQL record reader.",,"Architectural design configuration
Architectural solution benefits and drawbacks",8:1006 - 8:1123,2,arjan
22:24,"Before auto paging is available, we can use this  record reader to go…",CASSANDRA-4421,"Before auto paging is available, we can use this  record reader to go through the paging.
",,Architectural design configuration,8:1125 - 8:1215,1,arjan
22:25,Can we consider this code as functional but not efcient ?,CASSANDRA-4421,"Can we consider this code as functional but not efcient ?
",,,8:1230 - 8:1288,1,arjan
22:26,Elaborate?,CASSANDRA-4421," Elaborate?
",,,8:1301 - 8:1313,1,arjan
22:104,cscetbon,CASSANDRA-4421,cscetbon,,Comment,8:1318 - 8:1325,1,arjan
22:27,I’m talking about the patches provided by Alex Liu. If it works (not t…,CASSANDRA-4421," I’m talking about the patches provided by Alex Liu. If it works (not tested and  it’s part of the question) can we use it until it’s more efcient with the use of native paging  ? Do I make a bad supposition about the lack of performance of this paging strategy ?
",,"Architectural solution benefits and drawbacks
Assumptions",8:1327 - 8:1591,2,arjan
22:105,alexliu68,CASSANDRA-4421,alexliu68,,Comment,8:1596 - 8:1604,1,arjan
22:28,It does a few extra CQL requests to get to the next page/CF rows. Othe…,CASSANDRA-4421,"It does a few extra CQL requests to get to the next page/CF rows. Other than  that it’s efcient on thrift server.
",,Architectural solution benefits and drawbacks,8:1607 - 8:1721,1,arjan
22:29,Because that native paging could keep using the same connection and in…,CASSANDRA-4421,"Because that native paging could keep using the same connection and internally keep reading  the data where page it’s, native auto paging could be more efcient.
I don’t know how difcult to implement the native auto paging and the time line.",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Architectural tactics",8:1722 - 8:1962,3,arjan
22:30,"When it’s  available, we can add a new CQL native reader, so user can…",CASSANDRA-4421,"When it’s  available, we can add a new CQL native reader, so user can have choice to use this one and  the new native reader.",,Architectural design configuration,8:1964 - 8:2088,1,arjan
22:31,"Alex, Can you provide a patch that can be applied to cassandra-1.2.3 b…",CASSANDRA-4421,"Alex, Can you provide a patch that can be applied to cassandra-1.2.3 branch ?
I would like to test it. Thanks",,,8:2105 - 8:2214,1,arjan
22:32,I attach the patch for cassandra-1.2.3,CASSANDRA-4421,I attach the patch for cassandra-1.2.3,,,8:2232 - 8:2269,1,arjan
22:33,thanks but I had an issue when compiling. TClientTransportFactory inte…,CASSANDRA-4421,"thanks but I had an issue when compiling. TClientTransportFactory interface  was not found so I copied the fle src/java/org/apache/cassandra/thrift/TClientTransport-  Factory.java from your DSP-1954 branch and the compilation succeeded. I’ll give it a try.
Tell me if I did an error by doing this copy.
",,,8:2286 - 8:2590,1,arjan
22:34,you’ll probably also need TFramedTransportFactory (the implementation…,CASSANDRA-4421," you’ll probably also need TFramedTransportFactory (the implementation of  that) ... I’m going through this same exercise now as well.
25. cscetbon: I didn’t need that fle to compile. Cassandra is starting well. I’ll create and load  a CQL3 CF and test a Hadoop Job in the next hour.
26. mikeschrag: yeah, it’s not necessary to compile, but it will be necessary to run  27. cscetbon: I didn’t have to add it cause it was already there :)  28. alexliu68: [~cscetbon] Sorry about the missing fle TClientTransportFactory. Let me know  your testing result.
",,,9:16 - 9:571,1,arjan
22:35,my frst trivial test was a one node localhost cass w/ a table with 1 r…,CASSANDRA-4421,"my frst trivial test was a one node localhost cass w/ a table with 1 row that  has a text key and that ended in an infnite loop of:  2013-05-07 10:47:41,459 [main] DEBUG org.apache.cassandra.hadoop.cql3.ColumnFamilyRecordReader  - query type: 0  2013-05-07 10:47:41,459 [main] DEBUG org.apache.cassandra.hadoop.cql3.ColumnFamilyRecordReader  - set tail to null  ...repeated...
I’m going to try some multi-node clusters, some multi-row tables, and some diferent key  types to see how that’s impacted",,,9:588 - 9:1086,1,arjan
22:36,"This is a stock 1.2.4 cassandra install. For total disclosure, I DID s…",CASSANDRA-4421,"This is a stock 1.2.4 cassandra install. For total disclosure, I DID suck your  code out of cass and into our project, and made a few tweaks to build against newer hadoop  libs, but I’m actually not even using hadoop here -- i’m just calling the ColumnFamilyIn-  putFormat from a simple java main method, so it’s possible i’m skewing something with a  busted test, but i don’t THINK so:  1 Configuration conf = new Configuration();  2 3  ConfigHelper.setInputInitialAddress(conf, ""127.0.0.1"");  4 ConfigHelper.setInputRpcPort(conf, ""9160"");  5 ConfigHelper.setInputPartitioner(conf, ""Murmur3Partitioner"");  6 ConfigHelper.setInputColumnFamily(conf, ""whatever"", ""branch"");  7 CQLConfigHelper.setInputCQLPageRowSize(conf, ""3"");  8 //CQLConfigHelper.setInputWhereCla  9 uses(conf, ""title=’A’"");  10  8
11 JobContext jobContext = new JobContextImpl(conf, new JobID());  12 TaskAttemptContext context = new TaskAttemptContextImpl(conf, new TaskAttemptID  ());  13 ColumnFamilyInputFormat inputFormat = new ColumnFamilyInputFormat();  14 List<InputSplit> splits = inputFormat.getSplits(jobContext);  15 for (InputSplit split : splits) {  16 ColumnFamilySplit columnFamilySpli  17 t = (ColumnFamilySplit) split;  18 System.out.printf(""split: %s\n"", split);  19  20 ColumnFamilyRecordReader reader = new ColumnFamilyRecordReader();  21 reader.initialize(split, context);  22 // now read out all the values...
23 while (reader.nextKeyValue()) {  24  25 List<IColumn> keys = reader.getCurrentKey();  26 System.out.println(""CassandraBulkTest.main: "" + ByteBufferUtil.strin  27 g(keys.get(0).value()));  28 Map<ByteBuffer, IColumn> columns = reader.getCurrentValue();  29 for (IColumn column : columns.values()) {  30 String name = ByteBufferUtil.string(column.name());  31 String value = ""skipped"";//column.value() != null ? ByteBufferUtil.string  (column.value()) : ""null value"";  32 System.out.println(""CassandraBulkTest.main: "" + name + ""=>"" + value  33 );  34 }  35 }  36 }  37 }  33. cscetbon: [~alexliu68] Something should be missing too on my new cassandra-1.2.3 patched  as the column family (CQL3 Storage) is not visible through Thrift :  15:28:03,073 DEBUG [main] (QueryParserDriver.java:283) - Resulting macro AST:  (QUERY (STATEMENT data (LOAD ’cassandra://ks1/t1’ (FUNC CassandraStorage))))  15:28:04,426 ERROR [main] (LogUtils.java:125) - ERROR 1200: Column family ’t1’ not  found in keyspace ’ks1’  34. mikeschrag: Cyril -- I git past initialization, so that code appears to work. Are you sure  you’re pointing at the right server?
35. mikeschrag: Oh, your case is loading data, so that might be diferent ... I’m only testing  fetching right now.
36. alexliu68: [~mikeschrag] Did you miss the keyspace and column family settings? I will  do some debugging and testing today. The code hasn’t been fully tested. It did pass the  example in the patch for me.
37. cscetbon: I need to test cassandra 1.2.3, so the method I used :  - git checkout cassandra-1.2.3  - patch -p0 < patch_from_Alex  - copy TFramedTransportFactory and TClientTransportFactory from git checkout remotes/origin/DSP-  1954 (from https://github.com/riptano/cassandra)  - ant and deploy everything to my test cluster  [~mikeschrag] it’s a Pig Load call so it’s actually fetching data from Cassandra.
38. mikeschrag: Alex - In my case, I get 2 rows out of my CF before it blows up with that  exception, so my basic confg is defnitely right. That response might have been intended  for Cyril, though.
9
39. mikeschrag: I’m still digging into this, but one thing I noticed in RowIterator.computeNext,  in the ""if (pageRows >= pageRowSize || !iterator.hasNext())"" condition, it looks like if you  hit the end of the page, and there isn’t another iterator (i.e. you’re done), you return end-  OfData() there, which I think would mean that you’re always losing the last row of results,  because the fnal row would be in the Pair.create(keyColumns, valueColumns) that you’d  ordinarily return from this method?
40. mikeschrag: Ah, I think all the clusterKeys.get(0).value == null need to be:  clusterKeys.size() == 0 || clusterKeys.get(0).value == null  My clusterKeys is always empty.
41. mikeschrag: and setTailNull needs to return -1 if the values is empty:  1 private int setTailNull(List<Key> values)  2 {  3 if (values.size() == 0)  4 return -1;  that fxes the infnite loop ... this lets me get through the rows now. I’m going to check to  see if all the rows are actually there now, but it’s not dying or hanging at least, so that’s a  start :)  42. mikeschrag: i do get all the rows back in my tests (even when the last row falls on a page  barrier). so a false alarm on the comment about eating the last row.
",,,9:1876 - 11:1213,1,arjan
22:37,I attached the fxed version 4421-1.txt. It now fxes the issue with no…,CASSANDRA-4421,"I attached the fxed version 4421-1.txt. It now fxes the issue with no clustering  keys and also removes the endOfData() for the condition mentioned by Mike Schrag.
BTW it patches on C*-1.2.3 version, you can review it at https://github.com/alexliu68/cassandra/pull/1  44. alexliu68: Attached the third version",,,11:1229 - 11:1538,1,arjan
22:38,[~alexliu68] Compilation works like a charm with your last patch on ca…,CASSANDRA-4421,"[~alexliu68] Compilation works like a charm with your last patch on cassandra-  1.2.3 tag. I’m still having the same issue concerning the invisible column family to thrift  API : http://pastebin.com/qGwGMa7r  However as it’s linked to issue https://issues.apache.org/jira/browse/CASSANDRA-5234, I  don’t if you’re code fxed it (seems it didn’t). But if CQL3 tables are now working with  Hadoop they should be returned through thrift describe_keyspace  46. jbellis: bq. if CQL3 tables are now working with Hadoop they should be returned through  thrift describe_keyspace  That doesn’t follow at all.
47. alexliu68: [~cscetbon]The patches is for Hadoop only. For Pig to work, we need modify  org.apache.cassandra.hadoop.pig.CassandraStorage to support CQL3. Unfortunately I only  implement it for hadoop. I will implement it later after my other assignments are done if no  one else have implemented it by that time.
48. cscetbon: [~alexliu68] Oh, I was thinking that only thrift was afected by the CQL3 issue  and that it was why pig was not working. If Pig needs to be updated too (as you say), I’ll wait  10
for that with hope that it will come soonâĂę Can you change the status of [CASSANDRA-  5234|https://issues.apache.org/jira/browse/CASSANDRA-5234] otherwise it won’t be as-  signed unless there is another JIRA for that ?
[~jbellis] I thought it was ONE whole block  49. mikeschrag: Alex - would you expect to get duplicate rows out of this code? I wasn’t sure  if I need to dedupe multiple results due to replication factor > 1. I’m seeing some weird  stuf with a large table (nominally should be about 50 million rows) that has been truncate  and recreated, and we’re up to 500 million rows dumped out of it so far. I’m not quite sure  what I’m seeing, yet, but just wanted to explore what the expected behavior is.
50. mikeschrag: Also curious if there’s any way I would get previously deleted rows back from  this?
",,,11:1555 - 12:820,1,arjan
22:106,alexliu68,CASSANDRA-4421,alexliu68,,Comment,12:825 - 12:833,1,arjan
22:39,If CQL3 statement provided in hadoop job doesn’t return dupli-  cate r…,CASSANDRA-4421,If CQL3 statement provided in hadoop job doesn’t return dupli-  cate rows then the hadoop job shouldn’t return duplicate rows.,,User requirement,12:850 - 12:975,1,arjan
22:40,"But CQL 3 doesn’t have  DISTINCT key word support, so some CQL3 query…",CASSANDRA-4421,"But CQL 3 doesn’t have  DISTINCT key word support, so some CQL3 query returns duplicate rows.
",,User requirement,12:977 - 12:1071,1,arjan
22:41,"You can test it at one node to see whether the duplicate rows occur, t…",CASSANDRA-4421,"You can test it at one node to see whether the duplicate rows occur, then test it for multiple  nodes with rp > 1.
RF shouldn’t create duplicate rows. Let’s trace it or reproduce it in a simple way.
",,,12:1072 - 12:1272,1,arjan
22:107,alexliu68,CASSANDRA-4421,alexliu68,,Comment,12:1277 - 12:1285,1,arjan
22:42,"If you have some snapshot of the nodes, you can restore them, otherwis…",CASSANDRA-4421,"If you have some snapshot of the nodes, you can restore them, otherwise you  will lose the deleted rows after compaction.
",,Architectural design configuration,12:1288 - 12:1410,1,arjan
22:108,mikeschrag,CASSANDRA-4421,mikeschrag,,Comment,12:1415 - 12:1424,1,arjan
22:43,"Sorry, i wasn’t clear. i’m not trying to recover deleted rows, i’m jus…",CASSANDRA-4421," Sorry, i wasn’t clear. i’m not trying to recover deleted rows, i’m just trying  to explain why a table that we THINK should have 50M rows returns far more than that  when we iterate over them in bulk.
One possibly interesting tidbit is that the table has a compound row key (text, text), so  maybe there’s something with that detail.
I’ve attempted a test with a small CF, and I don’t get dupes. I’ve tested on a 4.5M row CF,  and that doesn’t appear to get dupes. But this (what we THINK is) 50M row CF does. It  takes millions of rows before we start seeing them, though.
54. jeromatron: When you mapreduce over the column family, you need to flter out tomb-  stones to get an accurate count. Also, make sure you’re setting your consistency level to  ensure you have a consistent number.
55. mikeschrag: I thought CQL3 fltered tombstones automagically? In my case, all the rows  I get back actually have data in them. A tombstone would manifest as an empty row, right?
I’m beginning to think I’m hitting an edge case bug in this patch. The row count on this one  particular inputsplit got up to 400M before i killed it ... It sure looks like it’s stuck in some  sort of infnite loop. It doesn’t happen on every split, just this particular one. I’m going to  try and do some more diagnostics.
56. mikeschrag: I’ve tracked down the bug ... If the token value of the last row of the page  == the end value of the split, it ends up trying to fetch the next page using the query:  1 \newline%  2 If you fill this in ... Assume your split is 1000{-}2000, and the last row of the  page happened to actually be the max value 2000, that would be:\newline%  11
3 \newline%  4 \begin{lstlisting}SELECT * FROM [cf] WHERE token(key) > 2000 AND token(key) <= 2000  LIMIT 1000 ALLOW FILTERING  It looks like Cass freaks out here with the impossible predicate, and where it should be  returning an empty result, it ACTUALLY returns bogus values that fall outside the spec-  ifed range. Once you get a token outside of the split range, you’re totally screwed, and  everything goes of the rails.
",,Run-time quality issues,12:1426 - 13:427,1,arjan
22:44,I’ve fled https://issues.apache.org/jira/browse/CASSANDRA-5573 for the…,CASSANDRA-4421," I’ve fled https://issues.apache.org/jira/browse/CASSANDRA-5573 for the  Cass issue.
",,,13:444 - 13:529,1,arjan
22:45,Attached the third version which fx the issue when pass the columns to…,CASSANDRA-4421,"Attached the third version which fx the issue when pass the columns to input-  format and there are no clustering keys, then the composed query has ""null"" as one of the  column.
",,,13:545 - 13:722,1,arjan
22:109,jeromatron,CASSANDRA-4421,jeromatron,,Comment,13:728 - 13:737,1,arjan
22:46,"you’re right, cql3 does flter range ghosts.",CASSANDRA-4421,"you’re right, cql3 does flter range ghosts.",,Existing system architecture description,13:746 - 13:788,1,arjan
22:47,"FWIW, I have seen where if  I’ve used the default consistency level of…",CASSANDRA-4421,"FWIW, I have seen where if  I’ve used the default consistency level of ONE (for the CFRR) when counting rows, that an  inconsistent number may come back.
",,,13:790 - 13:944,1,arjan
22:48,Version 4 is attached which fx the issue describe at CASSANDRA-5573,CASSANDRA-4421,Version 4 is attached which fx the issue describe at CASSANDRA-5573,,,13:960 - 13:1026,1,arjan
22:110,mikeschrag,CASSANDRA-4421,mikeschrag,,Comment,13:1033 - 13:1042,1,arjan
22:49,"Looks good. Thanks, Alex.",CASSANDRA-4421," Looks good. Thanks, Alex.
",,Architectural solution benefits and drawbacks,13:1044 - 13:1071,1,arjan
22:50,I spoke too soon (I accidentally had my override classes still in plac…,CASSANDRA-4421,"I spoke too soon (I accidentally had my override classes still in place).
reachEndRange is consuming the partition key ByteBufers, so they’re basically empty val-  ues every time, so the split just keeps repeating starting at the beginning.
At the top of reachEndRange, if you:  1 \newline%  2 and at the bottom, you can reset them:\newline%  3 \begin{lstlisting}for (Key k : partitionKeys) k.value.reset();  that will fx it.
",,,13:1088 - 13:1516,1,arjan
22:51,Version 5 is attached to add the fx by Mike,CASSANDRA-4421,Version 5 is attached to add the fx by Mike,,,13:1532 - 13:1574,1,arjan
22:111,jbellis,CASSANDRA-4421,jbellis,,Comment,13:1581 - 13:1587,1,arjan
22:53,I dug in and started cleaning things up: https://github.com/jbellis/ca…,CASSANDRA-4421," I dug in and started cleaning things up: https://github.com/jbellis/cassandra/commits/4421.
(NB: there’s a bunch more redundant @Override annotations that I did not clean up. Those  should go too: http://wiki.apache.org/cassandra/CodeStyle.)",,,13:1589 - 13:1831,1,arjan
22:52,But when I looked up from the code I realized that we have an importan…,CASSANDRA-4421,"But when I looked up from the code I realized that we have an important discussion to  have frst: What API should we present? I don’t think {{RecordReader<List<IColumn>,  Map<ByteBufer, IColumn»}} and {{RecordWriter<ByteBufer, List<List<ByteBufer»>}}  are it.
",,Motivation of design issue,13:1834 - 13:2094,1,arjan
22:112,jbellis,CASSANDRA-4421,jbellis,,Comment,13:2099 - 13:2105,1,arjan
22:54,I think there are two sane alternatives for the reader. We could expos…,CASSANDRA-4421," I think there are two sane alternatives for the reader. We could expose {{Recor-  dReader<List<ByteBufer>, List<ByteBufer»}} and assume the caller can fgure out what  his PK defnition is, and what columns he asked for and therefore what the List items cor-  respond to.
",,"Architectural component behavior and structure
Assumptions",13:2107 - 13:2378,2,arjan
22:55,"Alternatively we could expose {{RecordReader<Map<String, ByteBufer>, M…",CASSANDRA-4421,"Alternatively we could expose {{RecordReader<Map<String, ByteBufer>, Map<String,  ByteBufer»}}, which makes it a lot harder for the caller to screw things up, while also mak-  ing it more convenient. (The only reason the original CFRR presents a Map as the value is  for convenience in referring to columns by name.)",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",14:1 - 14:316,2,arjan
22:56,The Map should be a LinkedHashMap to preserve order as well.,CASSANDRA-4421,The Map should be a LinkedHashMap to preserve order as well.,,Architectural component behavior and structure,14:320 - 14:379,1,arjan
22:57,The best argument for sticking with the List is that we’re basically f…,CASSANDRA-4421,"The best argument for sticking with the List is that we’re basically forced to use a List  for the Writer’s bind variables, since we don’t support named parameters in CQL. Which  would imply {{RecordWriter<List<ByteBufer>, <List<ByteBufer»}}. The key should be  a List, since we can have compound PKs and we don’t want to force people to turn those into  a single BB via CompositeType. And the value should just be a single list of bind variables  because the list-of-lists is a hold over from the original CFRW. (Where TBH I don’t think  it made sense either but we’re kind of stuck with it no for backwards compatibility.)",,Architectural solution benefits and drawbacks,14:383 - 14:1006,1,arjan
22:58,"Or, we could do {{RecordWriter<Map<String, ByteBufer>, <List<ByteBufer…",CASSANDRA-4421,"Or, we could do {{RecordWriter<Map<String, ByteBufer>, <List<ByteBufer»}}, for con-  sistency with a Map-based Reader.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",14:1009 - 14:1128,2,arjan
22:113,alexliu68,CASSANDRA-4421,alexliu68,,Comment,14:1144 - 14:1152,1,arjan
22:59,"RecordReader<Map<String, ByteBufer>, Map<String, ByteBufer» and Record…",CASSANDRA-4421,"RecordReader<Map<String, ByteBufer>, Map<String, ByteBufer» and Record-  Writer<Map<String, ByteBufer>, <List<ByteBufer» is better than RecordReader<List<ByteBufer>,  List<ByteBufer» and RecordWriter<List<ByteBufer>, <List<ByteBufer»",,Architectural solution benefits and drawbacks,14:1155 - 14:1387,1,arjan
22:60,"RecordReader<List<ByteBufer>, List<ByteBufer» and RecordWriter<List<By…",CASSANDRA-4421,"RecordReader<List<ByteBufer>, List<ByteBufer» and RecordWriter<List<ByteBufer>,  <List<ByteBufer» is more concise, but user needs be careful not to screw up the order. If  we go this route, we should document it clearly.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",14:1390 - 14:1611,2,arjan
22:114,jbellis,CASSANDRA-4421,jbellis,,Comment,14:1616 - 14:1622,1,arjan
22:61,"All right, let’s go with the Map versions then.",CASSANDRA-4421,"All right, let’s go with the Map versions then.
",,Architectural solution benefits and drawbacks,14:1625 - 14:1673,1,arjan
22:62,[~jbellis] I attached a patch for PIG CQL3 support to CASSANDRA-5234.…,CASSANDRA-4421,"[~jbellis] I attached a patch for PIG CQL3 support to CASSANDRA-5234. It  works on top of the patch for CASSANDRA-4421.
69. jbellis: I’m confused, is there a patch w/ updated signatures somewhere for this?
70. alexliu68: The patch is attached to CASSANDRA-5234, which fxes the issue that CQL3  table is not supported in CassandraStorage and it also creates CQL3Storage for cql3 tables  only. The patch is built on top of 4421-5.txt.
71. jbellis: What we need next here is for you to build on the branch I posted, to fx the  CFIF/CFOF signatures as discussed above. I don’t see that in the 5234 code, but in any  case it’s best to not entangle the two. (What you can do locally is copy your 4421 branch  to work on 5234 on top of it, but keep the 4421 branch itself ""pure."")  72. alexliu68: Sure. I will work on the branch you posted to change the signatures.
73. lanzaa: If anyone cares, attached is 4421-6.cb.txt which is the 4421-5 patch on top of commit  2f72f8b in cassandra-1.2  74. alexliu68: I attach patch 4421-6-je.txt to fx the CFIF/CFOF signatures.
75. alexliu68: patch 4421-6-je.txt on top of [~jbellis]’s branch. [~lanzaa] Can you describe what  do you fx in your patch?
",,,14:1689 - 14:2878,1,arjan
22:115,lanzaa,CASSANDRA-4421,lanzaa,,Comment,15:5 - 15:10,1,arjan
22:64,Obviously your new patch is better than mine. The major diferences bet…,CASSANDRA-4421,"Obviously your new patch is better than mine. The major diferences between the  two are: * lots of little formatting changes, 4421-6-je is better here  * 4421-6-je seems to leave out the example code  * the ClientHolder stuf, which 4421-6-je doesn’t include  * fx conficts with CASSANDRA-5536  * fx conficts with CASSANDRA-5529",,Architectural solution benefits and drawbacks,15:13 - 15:339,1,arjan
22:65,The confict resolution is the only difculty I noticed while putting th…,CASSANDRA-4421,"The confict resolution is the only difculty I noticed while putting the patch onto the  head of cassandra-1.2 . Overall not a big deal.
",,,15:342 - 15:477,1,arjan
22:116,jbellis,CASSANDRA-4421,jbellis,,Comment,15:483 - 15:489,1,arjan
22:66,We don’t need to have list-of-list for values,CASSANDRA-4421,We don’t need to have list-of-list for values,,Architectural component behavior and structure,15:623 - 15:667,1,arjan
22:67,4421-7-je.txt patch is attached to change List<List<ByteBufer» to List…,CASSANDRA-4421,"4421-7-je.txt patch is attached to change List<List<ByteBufer» to List<ByteBufer>  79. jbellis: Added to my github branch, with some extra cleanup. (Noticed I forgot to add the  examples/ directory before. This probably needs to be updated.)  I think we’re ready for you to rebase to 1.2 now. May or may not be easiest to take Colin’s  rebase and apply the patches from my branch on top. (""git remote add"" is probably the  easiest way to grab my branch.)",,,15:685 - 15:1138,1,arjan
22:117,mikeschrag,CASSANDRA-4421,mikeschrag,,Comment,15:1145 - 15:1154,1,arjan
22:68,"I just noticed that if executeQuery times out, you just lose rows (alo…",CASSANDRA-4421," I just noticed that if executeQuery times out, you just lose rows (along with  all the other failure conditions), and that doesn’t actually bubble the exception up to the  runtime, so the consumer can’t actually respond to the failure, so you end up with a null  result, which i believe will make the page appear to be done. ",,Architectural component behavior and structure,15:1156 - 15:1481,1,arjan
22:69,"It would be much better to  either support retry here,",CASSANDRA-4421,"It would be much better to  either support retry here, ",,Architectural component behavior and structure,15:1482 - 15:1536,1,arjan
22:70,or throw the exception all the way up so that clients can retry on  th…,CASSANDRA-4421,or throw the exception all the way up so that clients can retry on  their own.,,Architectural component behavior and structure,15:1537 - 15:1614,1,arjan
22:71,I haven’t checked the new round of patches to see if this behaves the…,CASSANDRA-4421,"I haven’t checked the new round of patches to see if this behaves the same way.
",,,15:1616 - 15:1696,1,arjan
22:118,mikeschrag,CASSANDRA-4421,mikeschrag,,Comment,15:1701 - 15:1710,1,arjan
22:72,"Note that to recover from some of those failures, you have to reconnec…",CASSANDRA-4421,"Note that to recover from some of those failures, you have to reconnect the  ColumnFamilyRecordReader. ",,Architectural component behavior and structure,15:1713 - 15:1815,1,arjan
22:73,It would be helpful to have the connection code moved into  a connect(…,CASSANDRA-4421,"It would be helpful to have the connection code moved into  a connect() method and make close() null out the client so you can cycle the underlying  connection in the event of a more traumatic failure case. Ideally, the iterators and tokens  would all be left alone so that you can pickup where you left of.
",,Architectural component behavior and structure,15:1816 - 15:2124,1,arjan
22:119,mikeschrag,CASSANDRA-4421,mikeschrag,,Comment,15:2129 - 15:2138,1,arjan
22:74,Ugh .. Kind of nasty. AbstractIterator (which RowIterator extends) poi…,CASSANDRA-4421,"Ugh .. Kind of nasty. AbstractIterator (which RowIterator extends) poisons  itself on failure without any apparent way to recover. It gets stuck in State.FAILED and  you can’t reset it. That seems overly aggressive.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",15:2141 - 15:2357,2,arjan
22:75,Attached is patch 4421-8-cb containing the changes from jbellis’s bran…,CASSANDRA-4421,"Attached is patch 4421-8-cb containing the changes from jbellis’s branch. It applies  onto cassandra-1.2 cleanly (11eb352).
",,,15:2370 - 15:2493,1,arjan
22:120,mikeschrag,CASSANDRA-4421,mikeschrag,,Comment,15:2499 - 15:2508,1,arjan
22:76,"Yeah, recycling the RowIterator is probably too complicated.",CASSANDRA-4421,"Yeah, recycling the RowIterator is probably too complicated.",,Architectural solution benefits and drawbacks,15:2511 - 15:2570,1,arjan
22:77,"owever, I do  think the Exception should bubble up. I can then catch i…",CASSANDRA-4421,"owever, I do  think the Exception should bubble up. I can then catch it and reread the split at the app  level to pick back up where i left of.
",,Architectural component behavior and structure,15:2573 - 15:2717,1,arjan
22:78,I am fxing the new merged code infnite loop issue and make the example…,CASSANDRA-4421,"I am fxing the new merged code infnite loop issue and make the example work.
I will post the fnal merge later.
",,,15:2733 - 15:2844,1,arjan
22:121,alexliu68,CASSANDRA-4421,alexliu68,,Comment,15:2850 - 15:2858,1,arjan
22:79,"Catch it at your client code, so you can handle it after job is done.",CASSANDRA-4421,"Catch it at your client code, so you can handle it after job is done.",,Architectural component behavior and structure,15:2950 - 15:3018,1,arjan
22:80,"Write it to log, so you can check it where is wrong.",CASSANDRA-4421,"Write it to log, so you can check it where is wrong.
",,Architectural component behavior and structure,16:4 - 16:57,1,arjan
22:81,Like you said to retry at the point where it fails.,CASSANDRA-4421,"Like you said to retry at the point where it fails.
",,Architectural component behavior and structure,16:61 - 16:113,1,arjan
22:82,"So choice 1 is a common solution,",CASSANDRA-4421,"So choice 1 is a common solution,",,Architectural solution benefits and drawbacks,16:114 - 16:146,1,arjan
22:83,2 is the easiest to implement.,CASSANDRA-4421,2 is the easiest to implement.,,Architectural solution benefits and drawbacks,16:148 - 16:177,1,arjan
22:84,3 is quite some work  to do to make it’s reliable and robust.,CASSANDRA-4421,"3 is quite some work  to do to make it’s reliable and robust.
",,Architectural solution benefits and drawbacks,16:179 - 16:241,1,arjan
22:85,4421-8-je.txt is attached to merge the fnal code and some fxes on exam…,CASSANDRA-4421,4421-8-je.txt is attached to merge the fnal code and some fxes on example on  top of trunk commit 9e8691c26283f2532be3101486a8290ed5128c18,,,16:257 - 16:394,1,arjan
22:122,mikeschrag,CASSANDRA-4421,mikeschrag,,Comment,16:401 - 16:410,1,arjan
22:86,"I vote #1, defnitely. I need to be able to handle these conditions inl…",CASSANDRA-4421," I vote #1, defnitely. I need to be able to handle these conditions inline,  not after the job is done. If you implement #1, the user can choose #2 if s/he wants.",,Architectural solution benefits and drawbacks,16:419 - 16:580,1,arjan
22:87,"If  the library chooses #2 for you, you’re just out-of-luck. Particula…",CASSANDRA-4421,"If  the library chooses #2 for you, you’re just out-of-luck. Particularly in the case of a timeout,  that’s a relatively straightforward situation to resolve in many cases.
",,Architectural solution benefits and drawbacks,16:582 - 16:754,1,arjan
22:123,jbellis,CASSANDRA-4421,jbellis,,Comment,16:760 - 16:766,1,arjan
22:88,+1 for #1.,CASSANDRA-4421,+1 for #1.,,Architectural solution benefits and drawbacks,16:769 - 16:778,1,arjan
22:89,"We’ll want a patch against 1.2 as well as trunk, btw.",CASSANDRA-4421,"We’ll want a patch against 1.2 as well as trunk, btw.
",,,16:781 - 16:835,1,arjan
22:124,alexliu68,CASSANDRA-4421,alexliu68,,Comment,16:840 - 16:848,1,arjan
22:90,4421-9-je.txt patch is attached on top 9e8691c26283f2532be3101486a8290…,CASSANDRA-4421,"4421-9-je.txt patch is attached on top 9e8691c26283f2532be3101486a8290ed5128c18  of trunk to add exception handling.
",,,16:851 - 16:968,1,arjan
22:91,"try three time for TimedOutException and UnavailableException, any oth…",CASSANDRA-4421,"try three time for TimedOutException and UnavailableException, any other exception is  thrown back to client as IOException with the original cause throwable.
Client side can catch it and handle at client side. check this link for example  http://stackoverfow.com/questions/14920236/how-to-prevent-hadoop-job-to-fail-on-corrupted-  input-fle",,Architectural component behavior and structure,16:969 - 16:1310,1,arjan
22:92,Attach the fnal version 10 patches for trunk and 1.2 branch. It fxes s…,CASSANDRA-4421,Attach the fnal version 10 patches for trunk and 1.2 branch. It fxes some issue  with writer,,,16:1328 - 16:1419,1,arjan
22:93,Committed!,CASSANDRA-4421,"Committed!
",,,16:1435 - 16:1446,1,arjan
22:94,"(Post-commit, I renamed TClientTransportFactory to ITransportFactory.)",CASSANDRA-4421," (Post-commit, I renamed TClientTransportFactory to ITransportFactory.)",,,16:1459 - 16:1529,1,arjan
23:3,Remove Table.switchLock,CASSANDRA-5549,Remove Table.switchLock,,Architectural component behavior and structure,3:52 - 3:74,1,arjan
23:1,"As discussed in CASSANDRA-5422, Table.switchLock is a bottleneck on th…",CASSANDRA-5549,"As discussed in CASSANDRA-5422, Table.switchLock is a bottleneck on the write path",,Run-time quality issues,3:94 - 3:175,1,arjan
23:2,"Reen-  trantReadWriteLock is not lightweight, even if there is no cont…",CASSANDRA-5549,"Reen-  trantReadWriteLock is not lightweight, even if there is no contention per se between readers and  writers of the lock (in Cassandra, memtable updates and switches).
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",3:178 - 3:349,2,arjan
23:70,jbellis,CASSANDRA-5549,jbellis,,Comment,3:473 - 3:479,1,arjan
23:4,Rebased my switchLock-removal patch from CASSANDRA-5064 to https://git…,CASSANDRA-5549,Rebased my switchLock-removal patch from CASSANDRA-5064 to https://github.com/jbellis/cassandra/c  Sylvain’s comments from then:,,,3:482 - 3:609,1,arjan
23:6,I see nothing that prevents fushing the same memtable multiple times.,CASSANDRA-5549," I see nothing that prevents fushing the same memtable multiple times.
",,Architectural component behavior and structure,3:613 - 3:684,1,arjan
23:5,getting the commit log context and switching the memtable is not done…,CASSANDRA-5549,"getting the commit log context and switching the memtable is not done atomically with  respect to writes. So a write can be pushed in the commit log after the context we’re get-  ting but still reach the memtable we’re about to fush. For normal update, this is mostly  inefcient in that we’ll kept commit logs around long than necessary and potentially replay  some update unnecessarily, but for counter this is a bug.
",,Run-time quality issues,3:687 - 3:1105,1,arjan
23:7,it’s also possible that for postFlush tasks to not be scheduled in the…,CASSANDRA-5549,"it’s also possible that for postFlush tasks to not be scheduled in the order the commit log  context were acquired. So we could discard a commitlog for which the data is not yet fully  fushed.
",,Architectural component behavior and structure,3:1109 - 3:1302,1,arjan
23:8,I haven’t yet addressed these concerns; it’s just a straight-up rebase…,CASSANDRA-5549,"I haven’t yet addressed these concerns; it’s just a straight-up rebase so far. However, unit  2
tests pass, so it’s probably Good Enough to see what kind of performance impact this would  have. /cc [~danielnorberg]  2. enigmacurry: [~jbellis] I ran a benchmark against your branch comparing it to the prior  commit. I didn’t see any diference in write performance:  !5549-removed-switchlock.png!
[Data for this benchmark here|http://ryanmcguire.info/ds/graph/graph.html?stats=stats.removed_switchlock.json&  write&smoothing=1]  3. jbellis: Was this on the 4 core machines? Can you test on 8?
4. enigmacurry: Yes, this is on the quad cores. I’ll try the other cluster.
5. enigmacurry: Looks pretty similar on the eight core machines:  !5549-sunnyvale.png!
[Data for this benchmark here|http://ryanmcguire.info/ds/graph/graph.html?stats=stats.remove_switchlock.sunny  write&smoothing=1]  6. jbellis: (Note that counter replay not being idempotent should be fxed by CASSANDRA-  4775.)  7. vijay2win@yahoo.com: Hi Ryan, Can you give a shot at https://github.com/Vijay2win/cassandra/commits/5549  v2 on 10M keys atleast.
",,,3:1303 - 4:1025,1,arjan
23:71,vijay2win@yahoo.com,CASSANDRA-5549,vijay2win@yahoo.com,,Comment,4:895 - 4:913,1,arjan
23:9,"I moved the CommitLogAllocator forceFlush back to sepa-  rate thread,…",CASSANDRA-5549,"I moved the CommitLogAllocator forceFlush back to sepa-  rate thread, removed isDirty boolean since isClean is called in a separate thread and hence  shouldn’t help performance on writes",,Architectural component behavior and structure,4:1056 - 4:1241,1,arjan
23:10,My benchmark on 32 physical core machine shows a better performance th…,CASSANDRA-5549,My benchmark on 32 physical core machine shows a better performance than earlier. ~72  vs ~84,,Architectural solution benefits and drawbacks,4:1269 - 4:1361,1,arjan
23:72,benedict,CASSANDRA-5549,benedict,,Comment,4:1397 - 4:1404,1,arjan
23:11,"I suggest the following (somewhat complex seeming approach), building…",CASSANDRA-5549,"I suggest the following (somewhat complex seeming approach), building on my  patch for 3578:  We extract the CLS.Allocation object into a CommitState object that is allocated in CFS.apply()  prior to performing CL.add(). The CLS.AppendLock object is rewritten to be a more cus-  tom job which we will for now call MutationBarrier, and extracted along with CommitState.
",,Architectural component behavior and structure,4:1407 - 4:1776,1,arjan
23:12,MutationBarrier will be a synchronisation primitive that permits issui…,CASSANDRA-5549,"MutationBarrier will be a synchronisation primitive that permits issuing periodic barriers  that ensure operations started prior to the barrier have all completed, and also can be used  to create a token on an about-to-be-issued barrier that ensures operations started after the  barrier (when it *is* issued) know not to interfere with any state of an object that is using  the barrier.",,Architectural component behavior and structure,4:1777 - 4:2163,1,arjan
23:13,"This was probably unclear, but the steps of CFS.apply() using it may c…",CASSANDRA-5549,"This was probably unclear, but the steps of CFS.apply() using it may clarify it:  # Allocate CommitState, register operation with MutationBarrier  # CL.add() - on exit, has updated CommitState with position and segment of replay posi-  tion.*  # Checks Memtable’s BarrierToken to see if we are permitted to modify:#* if it’s absent we  simply make our modifcation and scoot;  #* if it’s present and permits us to make our modifcation, we do so but ALSO update a  3
ReplayPosition property (with cas, ensuring it is >= the one we have in CommitState)  #* if it’s present and does not permit us to modify, we look up its replacement Memtable  and repeat  # Release our hold on the MutationBarrier, signalling any waiters  When we fush a memtable, we:  # Set the ReplayPosition  # Create the replacement Memtable and chain it from ourselves  # Set the BarrierToken  # Wait on the Barrier  # Flush to disk, using the ReplayPosition we have maintained  Note that we will no longer perform any reference counting on the Memtables. I will ensure  that the mutation calls are all non-blocking, but may for correctness and simplicity make  those attempting to fush/issue a new barrier take out a (possibly spin-) lock on the MB in  order to issue a Token atomically.
",,Architectural design configuration,4:2165 - 5:794,1,arjan
23:14,\*CL.sync() will use the MB to fulfl the AppendLock role also. CL.add(…,CASSANDRA-5549,"\*CL.sync() will use the MB to fulfl the AppendLock role also. CL.add() will release a  hold on the MB that is related to CL only, to permit CL to proceed immediately.
",,Architectural component behavior and structure,5:806 - 5:974,1,arjan
23:73,benedict,CASSANDRA-5549,benedict,,Comment,5:978 - 5:985,1,arjan
23:15,"Without switch lock, we won’t have anything preventing writes coming t…",CASSANDRA-5549," Without switch lock, we won’t have anything preventing writes coming through  when we’re over-burdened with memory use by memtables.",,Architectural solution benefits and drawbacks,5:987 - 5:1119,1,arjan
23:16,"What I’d like to suggest is efectively a global Semaphore, with permit…",CASSANDRA-5549,"What I’d like to suggest is efectively a global Semaphore, with permits equal to the size  allocated for memtables; on KS.apply(RM) we estimate the size of the RM and take that  many permits. Once we’ve added the RM and know better how much it occupies, we adjust  the Semaphore to (more) accurately refect the amount of memory in use. When we fush a  memtable we release permits equal to the *estimated size* of each RM.
This may be pushing the boat out, but would probably result in not relying on memtable live  metering/scanning for size estimation, which we could retire. Either way we’re estimating  the size, but with this approach we’re keeping *tight* control over the (estimated) memory  allocated to memtables, whereas at the moment we have some tricks that we hope keep it  there. If we estimate space used cautiously, we should be able to better guarantee no OOM,  at least from this part of the code.
I have a *reasonably* straight forward scheme for estimating size used by a RM that should  be as good as we currently have. Basic premise is to calculate average space used by an item  in ConcurrentSkipListMap using metering at startup with a map of size, say, 1M entries,  rounded up. If we depend on CASSANDRA-6271 we can easily calculate exact overhead for  the BTrees, or otherwise can do a similar metering approach for SnapTreeMap. So we have  an overhead per row and per value. Separately we track how much space we are using for a  given memtable’s slab allocator. We use the RM’s data size only for the initial estimation,  to decide if we have room, and ignore it once it’s actually added, as it will be accounted for  in the slaballocator.
",,Architectural design configuration,5:1122 - 5:2791,1,arjan
23:74,vijay2win@yahoo.com,CASSANDRA-5549,vijay2win@yahoo.com,,Comment,5:2796 - 5:2814,1,arjan
23:17,"I should be missing something, how does the switch RW Lock to a kind o…",CASSANDRA-5549,"I should be missing something, how does the switch RW Lock to a kind of CAS operation  change this schematics?
4
Are we talking about additional requirement/enhancements to this ticket?
",,,5:2969 - 6:73,1,arjan
23:18,"IMHO, that might not be good enough since Java’s memory over head is n…",CASSANDRA-5549,"IMHO, that might not be good enough since Java’s memory over head is not considered.
And calculating the object size is not cheap either....
",,Architectural solution benefits and drawbacks,6:176 - 6:318,1,arjan
23:75,benedict,CASSANDRA-5549,benedict,,Comment,6:323 - 6:330,1,arjan
23:19,"In forceFlush() we obtain the writeLock, but do not relinquish it unti…",CASSANDRA-5549,"In forceFlush() we obtain the writeLock, but do not relinquish it until we have success-  fully added to the fushWriters queue. The fushWriters queue length also confgures how  often we should fush, so that once it is full, we are efectively ""out of memory"". This is  hardly a *precise* mechanism for memory control, but it is the one we currently use, and it  defnitely needs a replacement.
",,Architectural component behavior and structure,6:418 - 6:810,1,arjan
23:20,I don’t see your concerns here? We can easily and cheaply calculate th…,CASSANDRA-5549,"I don’t see your concerns here? We can easily and cheaply calculate the costs - we precom-  pute the overheads, and simply apply them on a per row and per key basis. The overheads  are pretty fxed for both - for SnapTreeMap they’re exactly the same for each key, and with  CASSANDRA-6271 they are relatively easily computable (or simply countable, in log(32,N)  time - probably I will opt for computing frst, then counting after insertion to get exact  amount used). Java’s memory overhead is included in any calculation.
",,Architectural solution benefits and drawbacks,6:960 - 6:1482,1,arjan
23:76,vijay2win@yahoo.com,CASSANDRA-5549,vijay2win@yahoo.com,,Comment,6:1487 - 6:1505,1,arjan
23:21,Well it is not exactly a constant overhead you might want to look  at…,CASSANDRA-5549,"Well it is not exactly a constant overhead you might want to look  at o.a.c.u.ObjectSizes (CASSANDRA-4860)...
",,Architectural solution benefits and drawbacks,6:1508 - 6:1618,1,arjan
23:77,benedict,CASSANDRA-5549,benedict,,Comment,6:1623 - 6:1630,1,arjan
23:22,For a given run of the JVM the overhead is constant for each type of o…,CASSANDRA-5549,"For a given run of the JVM the overhead is constant for each type of object al-  located, and the objects allocated can be predicted accurately given the number of columns  we are storing. I’ve done object size measurement before :-)  I don’t see anything in CASSANDRA-4860 that is surprising, but perhaps I’ve missed some-  thing specifc you’re worrying about? In general it’s dealing with ""miscalculating"" the portion  of a ByteBufer we’re referencing. This is a concern for live bytes, not retained bytes, and  my scheme outlined above was for retained bytes which is what we care about for memory  constraints, but I will also be replacing the live bytes calculation, since it will be easy to do  at the same time. But the same approach works, care is just needed.
",,Architectural solution benefits and drawbacks,6:1633 - 6:2402,1,arjan
23:78,benedict,CASSANDRA-5549,benedict,,Comment,6:2407 - 6:2414,1,arjan
23:23,],CASSANDRA-5549,],,,6:2516 - 6:2516,1,arjan
23:24,1) Removal of switchLock itself: The main work here is actually in the…,CASSANDRA-5549,"1) Removal of switchLock itself: The main work here is actually in the OpOrdering syn-  chronisation class. This class explains itself, so I won’t go into detail here, but provides  an easy mechanism for ensuring we can coordinate our updates to Memtables so that we  know what CL position they contain data to, and to know when the memtable is safe to be  written to disk. The actual fushing of the memtable has been refactored a little also, to  keep ordering guarantees",,Architectural component behavior and structure,7:1 - 7:472,1,arjan
23:25,"2) Allocators and Memory Management: by removing the switch lock, we g…",CASSANDRA-5549,"2) Allocators and Memory Management: by removing the switch lock, we get rid of our  ability to control heap growth by row mutations. To fx this, I’ve created the concept of a  PoolAllocator, with associated Pool that has fxed memory limits. Any allocation requires  the pool to allot room from its limit to the allocator (this is dealt with by MemoryTracker and  MemoryOwner). This required a lot of minor modifcations all over the place, to make mea-  surement of object sizes at modifcation time cheap and accurate. Mostly I’ve achieved this by  modifying jamm - a new branch is [here|https://github.com/belliottsmith/jamm/tree/guess]  so that it will always give us a useful answer. Wherever we used to be using ObjectSizes  adhoc in a class (generally incorrectly it turns out, not unsurprisingly as the API isn’t ob-  vious) I now *always* call measure() on an instance of the object and store that in a static  feld, and use simpler methods for any dynamic space use.
Worth noting: I’ve renamed IMeasureableMemory.memorySize() to excessHeapSize(), and  I’ve modifed (where applicable) its value to only count data we wouldn’t otherwise be stor-  ing. This only makes a diference in a few places, but I think is an important distinction.
This change also makes any limit on fush queue size irrelevant, so the metric we use for con-  trolling fushing is instead a ratio of in-use-memory to memory-limit, ignoring any already  fushing data, which once breached will trigger a fush of the largest CFS.
",,Architectural component behavior and structure,7:476 - 7:1983,1,arjan
23:26,3) Some concurrency primitives: NonBlockingQueue (and related classes)…,CASSANDRA-5549,"3) Some concurrency primitives: NonBlockingQueue (and related classes) and WaitQueue.
NonBlockingQueue is used more extensively in the of heap changes, but I leave it in here  because it improves WaitQueue a lot, and we rely on WaitQueue much more with the prolifer-  ation of the OpOrdering operations. It helps us move much closer to completely non-blocking  read/write operations also. We also use it to get rid of the Thread.yield() in SlabAllocator.
I’ve aimed to keep NBQ as simple as possible.",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",7:1984 - 7:2485,2,arjan
23:27,"4) CommitLog has been updated to use OpOrdering, and also includes a b…",CASSANDRA-5549,"4) CommitLog has been updated to use OpOrdering, and also includes a bug fx. I con-  sidered splitting this into a separate ticket, but it’s such a tiny proportion of the overall  changes I’m not sure it warrants it. The bug fx we may want to split out if this takes a  while to go through.
",,,7:2488 - 7:2779,1,arjan
23:28,"What happens now when I hit my memtable memory ceiling, before fush ma…",CASSANDRA-5549,"What happens now when I hit my memtable memory ceiling, before fush makes  more room?
",,,7:2793 - 7:2879,1,arjan
23:79,benedict,CASSANDRA-5549,benedict,,Comment,7:2884 - 7:2891,1,arjan
23:29,"Largely the same as before, the mutation thread blocks until enough me…",CASSANDRA-5549,"Largely the same as before, the mutation thread blocks until enough memory  becomes available to complete the request. The diference is, depending on where/why the  breach occurs, it may not block until after it completes its modifcation (as some of the  memory bookkeeping is batched to the end for ease and speed).
Any call to MemoryOwner.allocate() is potentially a blocking call, if there isn’t enough  room available to satisfy the allocation.
",,Architectural component behavior and structure,7:2894 - 7:3344,1,arjan
23:80,benedict,CASSANDRA-5549,benedict,,Comment,7:3349 - 7:3356,1,arjan
23:30,I just realised there was a fairly glaring bug with Flush/PostFlush. I…,CASSANDRA-5549," I just realised there was a fairly glaring bug with Flush/PostFlush. I was ’op-  timising’ the path to discard CL segments when there were no 2is, but this was dangerous  because of potential reordering of fushes (so a later fush could mark CLS unused when an  earlier fush was still in progress). I’ve fxed and uploaded.
",,Architectural component behavior and structure,7:3358 - 7:3681,1,arjan
23:31,Looks like the memtables.isEmpty path in Flush.run will result in Post…,CASSANDRA-5549,"Looks like the memtables.isEmpty path in Flush.run will result in PostFlush running with  a null lastReplayPosition which will cause NPE.
PoolAllocator.stateUpdater is unused. Should transition be CAS-ing?
PoolAllocator.Gc is also unused. Let’s take this out and add back in when needed.
PoolAllocator.setDiscarding and writeBarrier.markBlocking are both commented as allow-  ing allocations to exceed the memory limit. Only isBlocking actually appears to afect this.
There are several unused methods in OpOrdering. (If we’re planning to use this in a future  patch, let’s also leave these out for now.)  Signal javadoc ends mid-sentence. Would be nice to have javadoc on all the methods too.
Why wrap Pool constructor parameters in Setup object? Simpler to just inline the helper  methods into the constructor.
Should we bother allowing Pool cleaner to be null?
OCD at https://github.com/jbellis/cassandra/commits/5549-2. 6e029a3ee4943a30af078a5c2b6d483c348fc1f  is the only non-cosmetic one.
",,,8:32 - 8:1033,1,arjan
23:32,bq. Looks like the memtables.isEmpty path in Flush.run will result in…,CASSANDRA-5549,"bq. Looks like the memtables.isEmpty path in Flush.run will result in PostFlush  running with a null lastReplayPosition which will cause NPE.
Damn. Should have been more careful with my ninja bugfx.
bq. PoolAllocator.stateUpdater is unused. Should transition be CAS-ing?
Used by OfHeapAllocator. Can remove it until then.
bq. PoolAllocator.Gc is also unused. Let’s take this out and add back in when needed.
Makes sense  bq. PoolAllocator.setDiscarding and writeBarrier.markBlocking are both commented as  allowing allocations to exceed the memory limit. Only isBlocking actually appears to afect  this.
You’re absolutely correct: PoolAllocator.setDiscarding() no longer does this. I narrowed  the scope under which overshoot was permitted by introducing markBlocking, but appar-  ently didn’t keep the javadocs up to date.
bq. There are several unused methods in OpOrdering. (If we’re planning to use this in  a future patch, let’s also leave these out for now.)  I am a little less comfortable about this, as the most important unused methods are safe*,  which are somewhat interwoven with functionality. Although we can remove them relatively  cleanly if you prefer.
bq. Signal javadoc ends mid-sentence. Would be nice to have javadoc on all the methods too.
7
Whoops.
bq. Why wrap Pool constructor parameters in Setup object? Simpler to just inline the  helper methods into the constructor.
Do you mean to have protected methods we can call from within the constructor and over-  ridden by the extending class? This is another case of not needed just yet, but if you want  to provide a custom PoolCleaner or MemoryTracker, you need to construct them in the Pool  constructor so that the object is fully constructed and can be passed to the PoolCleaner and  MemoryTracker constructors. Can always introduce this in my next patch though.
bq. Should we bother allowing Pool cleaner to be null?
Good point. We could not. At the moment the only pools I intend to create without a  cleaner in the near future, I probably intend to create ""unbounded"", so it actually should be  fne (the cleaner will never be called). We can always introduce the checks later if we need  them.
I should mention that I hope to introduce a patch next week that relies on most of these  things we’ll be stripping out. But it shouldn’t make a huge diference either way.
",,,8:1048 - 9:1088,1,arjan
23:81,benedict,CASSANDRA-5549,benedict,,Comment,9:1093 - 9:1100,1,arjan
23:33,"I’m not totally  convinced it will remain stack allocated, due to the…",CASSANDRA-5549,"I’m not totally  convinced it will remain stack allocated, due to the allocation being split into two locations,  that would need to be coalesced into one by the compiler. It’s possible it does this, but it’s  not obvious that it would. It’s also not trivial to design a test that tells you for sure that it  does/doesn’t.
I doubt it will make a huge diference to performance, especially at the moment, though.
",,Architectural solution benefits and drawbacks,9:1165 - 9:1577,1,arjan
23:34,bq. I should mention that I hope to introduce a patch next week that r…,CASSANDRA-5549,"bq. I should mention that I hope to introduce a patch next week that relies on most  of these things we’ll be stripping out  I get that, but it’s good hygiene to keep things self contained (and I don’t have to re-  view it until then :).
bq. It’s also not trivial to design a test that tells you for sure that it does/doesn’t  How good are you at reading JIT assembly? :)  But if it’s not critical then I’m defnitely partial to this form as being easier to understand.
",,,9:1591 - 9:2061,1,arjan
23:35,"bq. I get that, but it’s good hygiene to keep things self contained (a…",CASSANDRA-5549,"bq. I get that, but it’s good hygiene to keep things self contained (and I don’t  have to review it until then .
Sure, and I shouldn’t get into bad habits anyway. I was already feeling a guilty about  this. I should have split the branch a long time ago and never got into this problem :-)  bq. But if it’s not critical then I’m defnitely partial to this form as being easier to un-  derstand.
It’s defnitely not, at least not yet. We allocate so much on the write path this will dis-  appear in the noise. But it would be nice to be slowly moving towards a day when that isn’t  the case, and baby steps in the right direction help.
8
bq. How good are you at reading JIT assembly?
Not good enough, but this is probably a good opportunity to fx that a little. As much  as it isn’t super important right now, it’s a useful thing in and of itself.
",,,9:2076 - 10:212,1,arjan
23:36,I’ve merged your changes and removed all of the mentioned unnecessary…,CASSANDRA-5549," I’ve merged your changes and removed all of the mentioned unnecessary changes,  as well as improved some javadoc, and fxed the bug in PostFlush.
Same repository as before.
",,,10:226 - 10:400,1,arjan
23:82,jbellis,CASSANDRA-5549,jbellis,,Comment,10:405 - 10:411,1,arjan
23:37,Pushed more refactorage to my branch.,CASSANDRA-5549,Pushed more refactorage to my branch.,,,10:414 - 10:450,1,arjan
23:38,I have a nagging feeling that OpOrdering could be done with two classe…,CASSANDRA-5549,"I have a nagging feeling that OpOrdering could be done with two classes instead of three,  merging Barrier and Ordered:  1 public void consume()  2 {  3 SharedState state = this.state;  4 state.setReplacement(new State())  5 state.doSomethingToPrepareForBarrier();  6 7  state.opGroup = ordering.currentActiveGroup();  8 state.opGroup.expire()  9 state.opGroup.await();  10  11 this.state = state.getReplacement();  12 state.d  13 oSomethingWithExclusiveAccess();  14 }  15  16 public void produce()  17 {  18 Group opGroup = ordering.start();  19 try  20 {  21 state.doProduceWork();  22 }  23 finally  24 {  25 opGroup.finishOne();  26 }  27 }  (We could still provide an accepts() method for the beneft of getMemtableFor, but I don’t  see that requiring a 3rd class either.)",,Architectural component behavior and structure,10:453 - 10:1229,1,arjan
23:83,benedict,CASSANDRA-5549,benedict,,Comment,10:1236 - 10:1243,1,arjan
23:39,For accepts() to work correctly the Ordered on which it is called MUST…,CASSANDRA-5549," For accepts() to work correctly the Ordered on which it is called MUST be  exposed atomically wrt changing the ""current"" Ordered/Group. This is at the very least dif-  fcult with the scheme you suggest, and I think probably impossible. At least, not without  synchronising on the OpOrdered, and doing everything that Barrier does, in the caller.
",,Architectural solution benefits and drawbacks,10:1245 - 10:1592,1,arjan
23:40,Note I have scrapped a lengthy message about how *expiring* atomically…,CASSANDRA-5549,"Note I have scrapped a lengthy message about how *expiring* atomically would also be  ugly, as I hadn’t yet realised that exposing atomically would be nearly impossible, which  I hope underlines how difcult this is, and that encapsulating as much of it as possible in  Barrier is a Good Thing. So that we only have to get it right the once.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",10:1593 - 10:1934,2,arjan
23:41,Stylistically I also think it is *much* clearer to separate the two co…,CASSANDRA-5549,"Stylistically I also think it is *much* clearer to separate the two concepts.
",,Architectural solution benefits and drawbacks,10:1935 - 10:2013,1,arjan
23:42,"Do we rely on accept returning true before issue, or can we make that…",CASSANDRA-5549," Do we rely on accept returning true before issue, or can we make that IllegalState?
",,,11:13 - 11:98,1,arjan
23:84,benedict,CASSANDRA-5549,benedict,,Comment,11:103 - 11:110,1,arjan
23:43,It’s a necessity of the semantics. For accept() to be properly synchro…,CASSANDRA-5549,"It’s a necessity of the semantics. For accept() to be properly synchronised with issue(),  it needs to be called as soon as the Barrier is exposed, so that false can happen the instant  issue() happens. Probably should have commented that better. The semantics of accept re-  main consistent, though - namely that it only returns true for any operations started before  the (eventual) issue().",,Architectural component behavior and structure,11:205 - 11:597,1,arjan
23:44,WaitQueue has changed enough that git no longer recognizes the new one…,CASSANDRA-5549,"WaitQueue has changed enough that git no longer recognizes the new one as sharing  history with the old one. Can you summarize?
",,,11:613 - 11:741,1,arjan
23:45,"We have ANBQ -> NBQV -> NBQ, with no other implementations. Can we com…",CASSANDRA-5549,"We have ANBQ -> NBQV -> NBQ, with no other implementations. Can we com-  bine these?
What is the diference between NBQ and CLQ? I’d be inclined to introduce NBQ in a  separate ticket.
",,,11:755 - 11:940,1,arjan
23:85,benedict,CASSANDRA-5549,benedict,,Comment,11:945 - 11:952,1,arjan
23:46,"NBQV and NBQ should be kept separate, as having two diferent queues mo…",CASSANDRA-5549,"NBQV and NBQ should be kept separate, as having two diferent queues modifying state  could get ugly. They could strictly speaking probably be merged at the moment, but unpick-  ing them in future might be difcult, and I’m not sure it’s helpful. ABQ I use for OfHeap  memtables, as I have a more memory efcient queue for storing references necessary for GC  (at least until we move more of-heap).
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Architectural tactics",11:1020 - 11:1416,3,arjan
23:47,"FIrstly, NBQ is non-blocking, CLQ is not. This is a nice property to h…",CASSANDRA-5549,"FIrstly, NBQ is non-blocking, CLQ is not. This is a nice property to have in and of it-  self, as we now have an almost totally non-blocking read and write path (actually codahale  is now one of the only main blocking points, other than the obvious memtable/CL fushes),  which maybe not immediately useful may allow us some neat optimisations in the near future.
Secondly, NBQ provides some very useful methods, most specifcally appendIfTail() and  removeHeadIf(). Even though CLQ *could* ofer these methods, it doesn’t, and it makes  certain things very difcult to write. These are mostly useful for the of-heap memtables,  but I also use them for CASSANDRA-6557 to fx a potentially dangerous bug, and make  the code easier to understand.
Lastly, and the only reason to include it in _this_ ticket, is the snap() functionality that  allows a persistent view of the queue that (mostly) does not change. In WaitQueue, since  it is now used extensively in more highly concurrent places with spurious wake ups, this is  really essential: waiting threads can (actually very easily) wake-up, fnd they have no work  to do, and go back to sleep again _before the signalling thread has reached the end of the  queue_, meaning they get woken up again... potentially repeatedly. This is especially a  risk due to the use of pthread mutexes to implement LockSupport.park/unpark - whilst the  signalling thread releases the waiting thread’s mutex before waking it, if that thread is state  changing at that time anyway, the signalling thread will wait (a full scheduler delay), and  this can happen repeatedly.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",11:1521 - 11:3122,2,arjan
23:86,benedict,CASSANDRA-5549,benedict,,Comment,11:3127 - 11:3134,1,arjan
23:48,Sure:  - It includes the aforementioned improvements with NBQ (includi…,CASSANDRA-5549,"Sure:  - It includes the aforementioned improvements with NBQ (including now being non-blocking,  except in the case of signaller/waiter trampling on each other occasionally in pthread world).
- It abstracts the Signal, so that we can have other implementations: wait for all, wait for  any, for example.
- It supports timing the amount of time spent waiting. I have toyed with splitting this out  into another ticket, but I did it whilst I was going, as I thought having the amount of time  spent waiting on Memtable (or CL) fush would be a helpful metric.
",,Architectural design configuration,12:1 - 12:561,1,arjan
23:49,"That said, perhaps we could try splitting this whole thing into a few…",CASSANDRA-5549,"That said, perhaps we could try splitting this whole thing into a few smaller tickets, make  it more manageable for you to review. I kind of suspect the main body won’t diminish a lot  though, which is why I didn’t in the frst place. But every little probably helps :-)  32. benedict: Maybe split :  - WaitQueue, NBQ  - BTree UpdateFunction  - OpOrdering + CL utilisation  - WaitQueue timing + CL timing  - ObjectSizes + JAMM  - RoW  ?
",,,12:562 - 12:998,1,arjan
23:50,"As a progress update: I’m done with OpOrdering, CFS, Memtable, et al.,…",CASSANDRA-5549,"As a progress update: I’m done with OpOrdering, CFS, Memtable, et al., and now looking  at the plumbing (NBQ and the Allocator stuf). So if we can call NBQ an optimization and  split it out, great. Otherwise, I don’t see a good place to split things. :)",,,12:1059 - 12:1311,1,arjan
23:87,benedict,CASSANDRA-5549,benedict,,Comment,12:1318 - 12:1325,1,arjan
23:51,"It’s double locked, so lock to read, lock to write. Also double-lock t…",CASSANDRA-5549,"It’s double locked, so lock to read, lock to write. Also double-lock to Iterator remove.
So by NonBlockingQueue, I mean WaitFreeQueue, not NoBlockingMethodQueue :-)",,Architectural component behavior and structure,12:1379 - 12:1543,1,arjan
23:52,"If it weren’t for WaitQueue I’d say it were just an optimisation, but…",CASSANDRA-5549,"If it weren’t for WaitQueue I’d say it were just an optimisation, but it’s likely to cause  real wasted cycles. I’ve seen it happening, it’s not a theoretical risk, the only question is  how big the problem would be given the use case of WaitQueue.... and the answer is, I’m  not sure. There’s a reasonable chance it will only trigger wasted cycles infrequently, in which  case we can address it later.
",,"Architectural solution benefits and drawbacks
Architectural tactics
Assumptions",12:1589 - 12:1992,3,arjan
23:53,"CASSANDRA-6557 really needs it to fx the bug I spotted, though, so we’…",CASSANDRA-5549,"CASSANDRA-6557 really needs it to fx the bug I spotted, though, so we’ll have to put it  in before release anyway. Not sure that buys you much respite!
",,,12:1993 - 12:2145,1,arjan
23:54,"FYI, on an unrelated note I’ve merged your changes and pushed an unrel…",CASSANDRA-5549," FYI, on an unrelated note I’ve merged your changes and pushed an unrelated  bug fx to [5549|https://github.com/belliottsmith/cassandra/tree/only-5549]",,,12:2159 - 12:2309,1,arjan
23:55,I realised as I was going to sleep this morning (strangely the best ti…,CASSANDRA-5549,"I realised as I was going to sleep this morning (strangely the best time to realise  you’ve made a mistake, I fnd) that my fx for the bug was itself busted. Re-uploaded minor  tweak to the branch.
",,,12:2326 - 12:2523,1,arjan
23:56,"With an alternative identifed for CASSANDRA-6557, let’s build this on…",CASSANDRA-5549,"With an alternative identifed for CASSANDRA-6557, let’s build this on top of  CLQ for now. I’ll fnish review of the Pool stuf and we’ll be good to go here.
38. benedict: bq. and we’ll be good to go here.
Awesome.
bq. let’s build this on top of CLQ for now",,,13:14 - 13:271,1,arjan
23:88,benedict,CASSANDRA-5549,benedict,,Comment,13:175 - 13:182,1,arjan
23:57,"Got errands to run and don’t want to rush swapping  it in WaitQueue, a…",CASSANDRA-5549,"Got errands to run and don’t want to rush swapping  it in WaitQueue, as it requires a slightly diferent approach.
",,Architectural component behavior and structure,13:310 - 13:424,1,arjan
23:58,"In the meantime, I’ve pushed a few more renames for your enjoyment. (O…",CASSANDRA-5549,"In the meantime, I’ve pushed a few more renames for your enjoyment. (OpOrdering  -> OpOrder, issue -> seal, accept -> includes.)  Of these, I am least fond of {{seal}} which I think is better than issue (which could mean  a lot of diferent things including creation) but still not super explanatory withoutreading  javadoc. Maybe {{sealGroup}} or even {{sealCurrentGroup}}?
40. benedict: issue() is the normal parlance when talking about memory fences, in my expe-  rience, which this is roughly a high level model of, so I would like to keep it. However we  could go with partition()? Or I can wrack my brains some more...
OpOrdering -> OpOrder is good. I’m defnitely with you on Group as well, now.
I’m not fond of includes(). Maybe isAfter()?
41. jbellis: bq. issue() is the normal parlance when talking about memory fences  The problem is that it’s not ""just"" a memory fence, but is tied to the Group behavior.
(Once issued, the old group is sealed and a new Group started.)  bq. isAfter()?
WFM.
42. benedict: bq. The problem is that it’s not ""just"" a memory fence, but is tied to the Group  behavior. (Once issued, the old group is sealed and a new Group started.)  True, but from the point of view of the Barrier API, that doesn’t really seem like im-  portant information to me, although it is a necessity of function that it happens. I think it  is important to convey, especially, that the Barrier itself doesn’t really exist until you call  this method, it’s just a place holder, which seal() doesn’t seem to. A few alternatives: fx(),  impose(), slice().
Coming up a bit empty on really good alternatives, though, and probably not worth much  more discussion. I am not completely against seal(), as the word sounds good when said  with Barrier. So whatever works for you.
43. jbellis: Pushed seal back to issue and includes to isAfter.
44. benedict: Merged your changes, and pushed a version without NBQ et al.
One thing I rolled back was your deletion of the commented out code. I uncommented  it. That was a massive oversight of something I was using for stress testing the memory  management stuf for slab allocators :-/  12
45. jbellis: I think what I’m having a hard time with is, Pool should be a reservoir that we  allocate out of and instead it’s a container of two such reservoirs (MT). I propose renaming:  MemoryTracker -> Pool  Pool -> LinkedPools? DualPool? OnOfHeapPools? Reservoir? PoolPool?
Edit: isn’t the traditional cop out name a Manager? I could go for MemoryManager. :)  46. jbellis: Aside: we have one (two) MemoryOwner per Memtable right? I don’t think it’s  worth obfuscating {{owns}} with an updater instead of just using AtomicLong.
47. jbellis: I kind of like the Linked prefx since we can apply that at the MO level too:  MemoryTracker -> Pool  Pool -> LinkedPools  MemoryOwner -> Allocator  PoolAllocator -> LinkedAllocators  48. benedict: bq. I think what I’m having a hard time with is, Pool should be a reservoir that  we allocate out of and instead it’s a container of two such reservoirs (MT)  I can see your criticism of Pool being in fact two pools, but I think it can also be viewed as  just one. It only ever allocates one kind of resource, but in some cases those resources may  occupy memory both on and of heap. The confusing thing, perhaps, is that we overload the  trackers/owners to track not only what the pool itself is using, but also what overheads we  incur in using the pool from Memtable. This is a bit unclean conceptually, but much cleaner  in implementation.
I also think that renaming MT to Pool would be confusing. Certainly an OfHeapPool  will legitimately _pool_ (and cache) the resources it allocates, so it could get confusing if  we call the thing logging the amount the pool, and the thing actually pooling something else.
MemoryOwner -> Allocator I’m very much a -1 on, as it really doesn’t allocate anything.
That said, I can see where you’re coming from. Only, I have already introduced Alloca-  torGroup into my follow on patch, which I think probably makes LinkedAllocatorsGroup  pretty confusing :-)  I want to ofer some alternatives, but I can’t think of anything better.
MemoryTracker -> Ledger?
MemoryOwner -> Account?
Pool -> Reservoir works for me  49. jbellis: bq. I can see your criticism of Pool being in fact two pools, but I think it can also  be viewed as just one. It only ever allocates one kind of resource, but in some cases those  resources may occupy memory both on and of heap.
Well, the real point is that we have two things (Pool/Allocator, MT/MO) that operate  on (connected on-of heap reservoirs / a single reservoir) and the names should refect that  relationship.
50. benedict: MemoryTracker -> PoolLedger  MemoryOwner -> AllocatorLedger  ?
13
51. jbellis: Okay, went with plan B of unifying MT/Pool and MO/Allocator. Pretty happy  with how this worked out: https://github.com/jbellis/cassandra/commits/5549-3  In my mind, of heap stuf can now be added by creating an appropriate Allocator class, and  a Pool implementation that owns two sub-pools.
(I’m seeing a bunch of test failures but I don’t think it’s from this refactor.)",,,13:438 - 15:386,1,arjan
23:89,benedict,CASSANDRA-5549,benedict,,Comment,15:393 - 15:400,1,arjan
23:59,"I’m not totally convinced this is better, but I think I can make it wo…",CASSANDRA-5549,"I’m not totally convinced this is better, but I think I can make it worth with the  of-heap stuf. I think it will get a little ugly, as we’ll need two allocators as well - we’ll need  some method in the AbstractAllocator interface to getOfHeapPartner() and getOnHeap-  Partner(), or something, so that Memtable can avoid special casing the OfHeapAllocator.
But the OnHeapPartner won’t actually support allocating BBs, it will just be for querying  and updating amounts of memory.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",15:403 - 15:884,2,arjan
23:60,"Not relishing it, but don’t mind pushing it of until we have to addres…",CASSANDRA-5549,"Not relishing it, but don’t mind pushing it of until we have to address that problem.
53. jbellis: Fair enough.
",,,15:885 - 15:998,1,arjan
23:61,I’m seeing tests fail on both your branch and mine that do not fail in…,CASSANDRA-5549,"I’m seeing tests fail on both your branch and mine that do not fail in trunk, e.g.
RangeTombstoneListTest.
",,,15:1012 - 15:1120,1,arjan
23:62,(tried to squash only-5549 onto trunk to see if it was something that…,CASSANDRA-5549," (tried to squash only-5549 onto trunk to see if it was something that got fxed  recently in trunk and got a zillion conficts, so rebasing that would be useful in any case)",,,15:1133 - 15:1304,1,arjan
23:63,"Right, I’ll take a look frst thing tomorrow. Don’t trust myself to act…",CASSANDRA-5549,"Right, I’ll take a look frst thing tomorrow. Don’t trust myself to actually correct  anything right now.
",,,15:1321 - 15:1426,1,arjan
23:64,"I’ve got a squashed/rebased version that’s only a week or so old, so I…",CASSANDRA-5549,"I’ve got a squashed/rebased version that’s only a week or so old, so I’ll update that against  your changes and upload.
",,,15:1427 - 15:1546,1,arjan
23:65,I’ve rebased from trunk and fxed the bugs and pushed (-f) to [merge-55…,CASSANDRA-5549, I’ve rebased from trunk and fxed the bugs and pushed (-f) to [merge-5549|https://github.com/belliottsmi  5549],,,15:1561 - 15:1671,1,arjan
23:66,There were two small issues: in RangeTombstoneList I was setting start…,CASSANDRA-5549,"There were two small issues: in RangeTombstoneList I was setting start[i] = null  before I copied its value; and in FBUtilities.hashToBigInteger() my ""equivalency"" rewrite  wasn’t so equivalent after all, so I reverted it. Whoops.
There are still three new tests failing, but this is because we fxed a bug and so DefsTest no  longer times out; CASSANDRA-6634 addresses these new issues.
",,,15:1674 - 15:2062,1,arjan
23:67,Committed!,CASSANDRA-5549," Committed!
",,,15:2075 - 15:2087,1,arjan
23:68,"(Please submit a pull request for jamm-0.2.6. Note that jamm uses ""nor…",CASSANDRA-5549," (Please submit a pull request for jamm-0.2.6. Note that jamm uses ""normal"" brace-  on-same-line convention.)",,,15:2100 - 15:2208,1,arjan
23:69,"Awesome! I’ve fxed the formatting, added a couple of comments and open…",CASSANDRA-5549,"Awesome! I’ve fxed the formatting, added a couple of comments and opened a  pull request.",,,15:2225 - 15:2313,1,arjan
24:3,Dealing with hints after a topology change,CASSANDRA-5902,Dealing with hints after a topology change,,Run-time quality issues,3:52 - 3:93,1,arjan
24:1,Hints are stored and delivered by destination node id. This allows the…,CASSANDRA-5902,"Hints are stored and delivered by destination node id. This allows them to survive IP changes  in the target, while making ""scan all the hints for a given destination"" an efcient operation.
However, we do not detect and handle new node assuming responsibility for the hinted row via  bootstrap before it can be delivered.
",,Run-time quality issues,3:113 - 3:436,1,arjan
24:2,I think we have to take a performance hit in this case -- we need to d…,CASSANDRA-5902,"I think we have to take a performance hit in this case -- we need to deliver such a hint to *all*  replicas, since we don’t know which is the ""new"" one. This happens infrequently enough, however  -- requiring frst the target node to be down to create the hint, then the hint owner to be down  long enough for the target to both recover and stream to a new node -- that this should be okay.
",,"Architectural solution benefits and drawbacks
Assumptions",3:437 - 3:827,2,arjan
24:38,jbellis,CASSANDRA-5902,jbellis,,Comment,3:911 - 3:917,1,arjan
24:4,If we have a hook for the topology  change I think that’s the only har…,CASSANDRA-5902,"If we have a hook for the topology  change I think that’s the only hard part.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",3:966 - 3:1043,3,arjan
24:5,"Maybe a bit more than LHF imo, but I guess it won’t hurt to try. 3. al…",CASSANDRA-5902,"Maybe a bit more than LHF imo, but I guess it won’t hurt to try.
3. ala.alkhaldi: Does [this dtest| https://github.com/alaalkhaldi/cassandra-dtest/commit/e03c1525949bdf9f69a40eb6  replicate the scenario in the ticket description ? WDYT [~jbellis]  4. jbellis: Yes.
5. jbellis: [~iamaleksey] is this worth tackling independent of CASSANDRA-6230?
2
6. aleksey: Yes, if we want to target 2.1 (and while not exactly LHF, it’s minor enough for  inclusion into 2.1.x, IMO).
",,,3:1066 - 4:122,1,arjan
24:39,blambov,CASSANDRA-5902,blambov,,Comment,4:126 - 4:132,1,arjan
24:7,It checks if the endpoint is no longer a replica in charge of the hint…,CASSANDRA-5902,"It checks if the endpoint is no longer a replica in charge of the hinted mutation’s key,  and if that’s the case sends the mutation to all replicas. The hint is treated as successfully  processed and deleted if at least one of the messages is successfully delivered.
",,Architectural design configuration,4:215 - 4:482,1,arjan
24:40,jbellis,CASSANDRA-5902,jbellis,,Comment,4:486 - 4:492,1,arjan
24:8,You’ll want to use CL.ALL instead of ONE when sending to all replicas.,CASSANDRA-5902,"You’ll want to use CL.ALL instead of ONE when sending to all replicas.
",,Architectural component behavior and structure,4:495 - 4:566,1,arjan
24:9,Otherwise LGTM!,CASSANDRA-5902,"Otherwise LGTM!
",,Architectural solution benefits and drawbacks,4:648 - 4:664,1,arjan
24:41,brandon.williams,CASSANDRA-5902,brandon.williams,,Comment,4:808 - 4:823,1,arjan
24:10,"There needs to be a way to disable this imo, I’m pretty certain some…",CASSANDRA-5902,"There needs to be a way to disable this imo, I’m pretty certain some  users will not want this behavior.
",,User requirement,4:826 - 4:931,1,arjan
24:11,I don’t see a hole in my original logic:,CASSANDRA-5902, I don’t see a hole in my original logic:,,Architectural solution benefits and drawbacks,4:944 - 4:984,1,arjan
24:42,brandon.williams,CASSANDRA-5902,brandon.williams,,Comment,4:1388 - 4:1403,1,arjan
24:12,"People still wreck themselves with hints as it is though, getting into…",CASSANDRA-5902,"People still wreck themselves with hints as it is though, getting into a  situation where it delivers to all the nodes would be rough, and users always fnd a way. A  simple -D to disable it won’t hurt anything :)",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",4:1406 - 4:1617,2,arjan
24:43,jbellis,CASSANDRA-5902,jbellis,,Comment,4:1624 - 4:1630,1,arjan
24:13,You’re overcomplicating it. There is no need to add more cognitive bur…,CASSANDRA-5902,"You’re overcomplicating it. There is no need to add more cognitive burden for  operators. If you have so many hints that this is a problem, then it would be a problem with  old behavior too. Either way you’re going to want {{deleteHintsForEndpoint}} rather than  restarting with -D.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",4:1633 - 4:1916,2,arjan
24:44,jbellis,CASSANDRA-5902,jbellis,,Comment,4:1921 - 4:1927,1,arjan
24:14,"Aside: if people are really having trouble with too many hints, should…",CASSANDRA-5902,"Aside: if people are really having trouble with too many hints, shouldn’t we reduce  the default hint window?
",,"Architectural component behavior and structure
Assumptions",4:1930 - 4:2040,2,arjan
24:45,blambov,CASSANDRA-5902,blambov,,Comment,4:2045 - 4:2051,1,arjan
24:15,Isn’t CL.ALL too risky? If there’s even one node down the hint will ke…,CASSANDRA-5902,"Isn’t CL.ALL too risky? If there’s even one node down the hint will keep being sent to  all replicas, creating a lot of network trafc; I don’t know if this happens in reality, but  there’s a risk that the hint will never have a chance to be deleted if there are many replicas.
",,Architectural solution benefits and drawbacks,4:2130 - 4:2407,1,arjan
24:16,I chose CL.ONE because this should still ensure that the data in the h…,CASSANDRA-5902,"I chose CL.ONE because this should still ensure that the data in the hint is not lost, and  we will still attempt to send it to all nodes. This might be insufcient for some partitioning  scenarios, though.
",,Architectural solution benefits and drawbacks,4:2408 - 4:2614,1,arjan
24:17,Another alternative is to duplicate the hint to a copy for each replic…,CASSANDRA-5902,"Another alternative is to duplicate the hint to a copy for each replica, write the copies  back to the hints table, and then try to send each one individually. This will avoid the issues  above at the expense of some hint table overhead.",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",4:2615 - 4:2851,2,arjan
24:46,benedict,CASSANDRA-5902,benedict,,Comment,5:5 - 5:12,1,arjan
24:18,"Well, we could write directly to each end point individually with CL.O…",CASSANDRA-5902,"Well, we could write directly to each end point individually with CL.ONE, and  if any fail write a new hint for that end point. In general that’s only likely to at most result  in one extra copy of the hint, and we can remove it immediately from the current end point’s  hint table, and the next retry won’t involve any more nodes since it should still be a member  of the end point set (unless more range movements have happened).
",,Architectural component behavior and structure,5:15 - 5:447,1,arjan
24:47,jbellis,CASSANDRA-5902,jbellis,,Comment,5:452 - 5:458,1,arjan
24:19,The hint contract is that repair should be unnecessary for downtime la…,CASSANDRA-5902,"The hint contract is that repair should be unnecessary for downtime lasting less  than the hint window. So, writing with ONE and calling it good isn’t enough.
",,Architectural solution benefits and drawbacks,5:461 - 5:620,1,arjan
24:20,I do think that ALL is good enough for 99% of scenarios in this alread…,CASSANDRA-5902,"I do think that ALL is good enough for 99% of scenarios in this already small corner case,  but Benedict’s suggestion of writing new hints for any replicas that are down shouldn’t be  much harder. (Note that we should check for liveness up front and short circuit the timeout  if FD already knows it’s down.)",,Architectural solution benefits and drawbacks,5:621 - 5:928,1,arjan
24:48,blambov,CASSANDRA-5902,blambov,,Comment,5:935 - 5:941,1,arjan
24:21,"As this appears to be the same process as a normal write would take, I…",CASSANDRA-5902,"As this appears to be the same process as a normal write would take, I created a  new version of the patch (at the same github branch, https://github.com/blambov/cassandra/compare/handof-  topology) which relies on StorageProxy.sendToHintedEndpoints to do the replication and  write the new hints as necessary. As a side beneft, messages to other datacentres will now  be combined.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:944 - 5:1326,2,arjan
24:22,A special WriteOrHintResponseHandler is provided to ensure the hint is…,CASSANDRA-5902,"A special WriteOrHintResponseHandler is provided to ensure the hint is only deleted af-  ter all endpoints have either responded or have been hinted.
",,Architectural component behavior and structure,5:1327 - 5:1477,1,arjan
24:23,"The previous version ofered fne-grained rate control, which is much mo…",CASSANDRA-5902,"The previous version ofered fne-grained rate control, which is much more difcult to im-  plement now. ",,Architectural solution benefits and drawbacks,5:1478 - 5:1579,1,arjan
24:24,"The new version will still obey the rate in the longer term, but will…",CASSANDRA-5902,"The new version will still obey the rate in the longer term, but will send all  copies of the hint in a single burst.
",,Architectural component behavior and structure,5:1580 - 5:1698,1,arjan
24:49,benedict,CASSANDRA-5902,benedict,,Comment,5:1703 - 5:1710,1,arjan
24:25,I don’t think this behaves as you expect right now; it looks like no n…,CASSANDRA-5902,"I don’t think this behaves as you expect right now; it looks like no new hint-  ing will be done under any circumstance, and the original hint will not be deleted in the  event that any end point fails to respond. It’s possible I’m missing something obvious though.
Take a look at...
Hint writing: WriteCallbackInfo.shouldHint(), MessagingService.expiringMap  Hint deletion: CallbackInfo.isFailureCallback(), IAsyncCallbackWithFailure, MessagingSer-  vice.expiringMap  It seems that a new IAsyncCallbackWithFailure that both hints and decrements the callback  count, so that the deletion is defnitely called eventually is what’s necessary.
Separately, it’s not clear to me we should be stopping hint replay to the target if one of these  extra hints fails to be delivered, since they’re unrelated. This could cause hints to not be  delivered before their ttl expires unnecessarily, which would be bad for consistency.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:1713 - 5:2634,2,arjan
24:50,blambov,CASSANDRA-5902,blambov,,Comment,5:2639 - 5:2645,1,arjan
24:26,"It was a mistake not to add new tests. You are right, the code wasn’t…",CASSANDRA-5902,"It was a mistake not to add new tests. You are right, the code wasn’t working  correctly.
A new version is now uploaded, which add tests, makes hint reporting to the response  handler a little less obscure, fxes the issue with hints not being reported, and handles non-  hintable replicas.
",,Architectural component behavior and structure,5:2648 - 5:2939,1,arjan
24:27,Are we stopping hint replay if a hint fails to be delivered? I don’t t…,CASSANDRA-5902,"Are we stopping hint replay if a hint fails to be delivered? I don’t think so, we stop the cur-  rent delivery cycle, since it would result in an unbreakable loop if a hint wasn’t successfully  4
deleted. We can’t really delete it if it wasn’t successfully processed, but the latter shouldn’t  happen now. (Note: it _can_ happen if shouldHint changes for a node between compiling  the list and the time a hint is about to be written, but that will only happen due to TTL  expiration and should be extremely rare and will be sorted during the next delivery cycle.)",,"Architectural component behavior and structure
Assumptions",5:3103 - 6:367,2,arjan
24:51,blambov,CASSANDRA-5902,blambov,,Comment,6:374 - 6:380,1,arjan
24:28,Updated patch for the new hint infrastructure uploaded [here|https://g…,CASSANDRA-5902,Updated patch for the new hint infrastructure uploaded [here|https://github.com/apache/cassandra/com,,,6:383 - 6:482,1,arjan
24:29,Since we now try to not deserialize hints we can no longer identify mi…,CASSANDRA-5902,"Since we now try to not deserialize hints we can no longer identify misaddressed hints just  before delivery (doing this requires either deserializing all mutations or storing additional  information in the hint fles); we deliver the hint to the known destination, which then checks  if it should apply locally. This does one more hop than necessary, but since the problem  being solved is very rare it is preferable to pay a large penalty when it is hit rather than  signifcant complication during normal operation.
This leaves hints whose target no longer exists (has been removed from the ring or re-  placed), for which we identify the situation (removed nodes no longer have an address) and  directly treat all hints for the target as misaddressed.
Misaddressed hints are then sent to all hintable replicas which are responsible for the token.
Unsuccessful deliveries are converted to hints with the same creation time, and when all  deliveries or hints have completed the original hint is treated as processed.
Patch does not apply any form of rate limiting, as it currently applies on the rate of reading  hints from the store, which is not afected in any way by the explosion of the number of  required deliveries. Again, as this situation should be very rare, this treatment hopefully  sufces.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",6:485 - 6:1791,2,arjan
24:52,aleksey,CASSANDRA-5902,aleksey,,Comment,6:1797 - 6:1803,1,arjan
24:30,"This is fne, conceptually.",CASSANDRA-5902,"This is fne, conceptually.
",,Architectural solution benefits and drawbacks,6:1806 - 6:1833,1,arjan
24:31,"That said, if our working assumption is that this situation should be…",CASSANDRA-5902,"That said, if our working assumption is that this situation should be rare (and I agree  with the assumption here), then we might go a slightly simpler route:  - for hints fles for which the node is no longer part of the ring, instead of regular delivery,  write the new hints locally instead, just to their new destinations - and have them replay  later via the regular hints replay path  - on the receiving end, if the hint no longer belongs, write a hint on that node for all the  replicas instead, and have them be delivered later via the regular replay path  We do pay a bit more price in fle IO - in redundant writes, but writing a hint for mul-  tiple replicas is relatively cheap (serialised just once, using the same space in the bufer),  and this should be rare.
As a bonus, {{Hint::apply()}} remains local only, without calls to {{StorageProxy}}, plus  we could avoid further extending {{AWRH}}.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",6:1834 - 6:2742,2,arjan
24:53,blambov,CASSANDRA-5902,blambov,,Comment,6:2860 - 6:2866,1,arjan
24:32,I didn’t take that route as I believe the idea wasn’t liked earlier be…,CASSANDRA-5902,"I didn’t take that route as I believe the idea wasn’t liked earlier because of the  extra hint table trafc which shouldn’t be that much of a problem now.
It does make things simpler. New version based on transforming to new hints directly:",,Architectural solution benefits and drawbacks,6:2869 - 6:3108,1,arjan
24:33,"1. Factor out {{concat(getNaturalEndpoints(keyspaceName, token), token…",CASSANDRA-5902,"1. Factor out {{concat(getNaturalEndpoints(keyspaceName, token), tokenMetadata.pendingEndpointsFor(token,  keyspaceName))}} into its own method instead of duplicating it further  2. Move local/remote/owner logic to the border of the system - {{HintVerbHandler::doVerb}}  - where the rest of this logic lives, leaving {{Hint}} unaware and local-only  3. Revert {{HintsDispatcher}} changes - as conversion doesn’t really ft the surrounding  code, and nulls for callback/action feel a bit messy to me. Add a very trivial {{convert}}  method to {{HintsDispatchExecutor}} instead  (2) means that the tests that rely on {{Hint::apply()}} need to be rewritten (using MS  sinks), haven’t handled that yet.
",,,7:123 - 7:821,1,arjan
24:54,blambov,CASSANDRA-5902,blambov,,Comment,7:826 - 7:832,1,arjan
24:34,also reverts the change to {{appliesLocally}} as I think using the new…,CASSANDRA-5902,also reverts the change to {{appliesLocally}} as I think using the new method would be too  inefcient there since {{pendingEndpointsFor}} is quite slow and isn’t required most of the  time:,,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",7:913 - 7:1101,2,arjan
24:55,aleksey,CASSANDRA-5902,aleksey,,Comment,7:1299 - 7:1305,1,arjan
24:35,"+1 on the change and overall,",CASSANDRA-5902," +1 on the change and overall,",,Architectural solution benefits and drawbacks,7:1307 - 7:1336,1,arjan
24:36,{{HintTest}} is failing though (both on  cassci and locally for me). C…,CASSANDRA-5902,"{{HintTest}} is failing though (both on  cassci and locally for me). Can you have a look? If not, I will, no problem.
26. blambov: Sorry, the initialization in \@Before was still needed.
Updated the patch and rerun the tests. {{utests}} had three failures, I reran and got  three diferent ones. Base also has similar failures, so I think they are fne. {{dtests}} match  base.
",,,7:1346 - 7:1724,1,arjan
24:37,"Thanks, that did it. Committed as [b2f38ef177b5c19288f96d9bfe5304ec943…",CASSANDRA-5902,"Thanks, that did it. Committed as [b2f38ef177b5c19288f96d9bfe5304ec94391f73|https://github.com/apach  to 3.0 and merged with trunk.",,,7:1738 - 7:1868,1,arjan
25:2,Write hints to fat fles instead of the system.hints,CASSANDRA-6230,Write hints to fat fles instead of the system.hints,,Architectural component behavior and structure,3:52 - 3:102,1,arjan
25:1,Writing to a fle would have less overhead on both hint creation and re…,CASSANDRA-6230,"Writing to a fle would have less overhead on both hint creation and replay.
",,"Architectural component behavior and structure
Architectural tactics",3:122 - 3:198,2,arjan
25:41,nickmbailey,CASSANDRA-6230,nickmbailey,,Comment,3:282 - 3:292,1,arjan
25:3,It would be great if we could expose a metric indicating when hints ar…,CASSANDRA-6230," It would be great if we could expose a metric indicating when hints are  ’expired’. Potentially even which nodes hints were expired for.
",,Architectural solution benefits and drawbacks,3:294 - 3:432,1,arjan
25:42,rcoli,CASSANDRA-6230,rcoli,,Comment,3:436 - 3:440,1,arjan
25:4,As an operator who has encountered a number of serious issues related…,CASSANDRA-6230,"As an operator who has encountered a number of serious issues related to large  amounts of hints in SSTables (for example ""runaway compaction"" of 50GB+ of hints), I +1  this approach in a general sense.
",,Architectural solution benefits and drawbacks,3:443 - 3:646,1,arjan
25:43,rustyrazorblade,CASSANDRA-6230,rustyrazorblade,,Comment,3:782 - 3:796,1,arjan
25:5,Defnitely makes a bunch of operational tasks easier,CASSANDRA-6230,Defnitely makes a bunch of operational tasks easier,,Architectural solution benefits and drawbacks,3:799 - 3:849,1,arjan
25:6,"For people with  spinning disks, would it be recommended that this go…",CASSANDRA-6230,"For people with  spinning disks, would it be recommended that this go on a drive with data or the commit  log? My assumption would be the data drive, otherwise it would interfere with the append  only nature of the commit log. Maybe that’s not a factor if you’re only doing an fsync every  10s?
",,,3:852 - 3:1147,1,arjan
25:44,rustyrazorblade,CASSANDRA-6230,rustyrazorblade,,Comment,3:1151 - 3:1165,1,arjan
25:7,"Also, is it 1 fle per node? From an ops perspective that might be help…",CASSANDRA-6230,"Also, is it 1 fle per node? From an ops perspective that might be helpful.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",3:1168 - 3:1243,2,arjan
25:45,aleksey,CASSANDRA-6230,aleksey,,Comment,3:1276 - 3:1282,1,arjan
25:8,1+ fles per node. A-la per-node commitlogs.,CASSANDRA-6230," 1+ fles per node. A-la per-node commitlogs.
",,Architectural component behavior and structure,3:1284 - 3:1329,1,arjan
25:46,aleksey,CASSANDRA-6230,aleksey,,Comment,4:4 - 4:10,1,arjan
25:9,Pushed the current branch to https://github.com/iamaleksey/cassandra/c…,CASSANDRA-6230,Pushed the current branch to https://github.com/iamaleksey/cassandra/commits/6230,,,4:13 - 4:93,1,arjan
25:10,"First, what isn’t there, but should be:  1. Metrics need to be exposed…",CASSANDRA-6230,"First, what isn’t there, but should be:  1. Metrics need to be exposed, and {{nodetool}} should switch to the new MBean.
2. The logic to transfer your own hints when decommissioning (unboostrap) is not complete.
All the requires parts are there, except some code in {{StorageService}} itself",,Architectural component behavior and structure,4:96 - 4:388,1,arjan
25:11,"That said, I don’t feel like it should be blocking review, and for bot…",CASSANDRA-6230,"That said, I don’t feel like it should be blocking review, and for both separate tickets can be  created.
",,,4:392 - 4:498,1,arjan
25:12,What isn’t there that I wish was there:  1. A full-on zero-copy stream…,CASSANDRA-6230,"What isn’t there that I wish was there:  1. A full-on zero-copy streaming of hints fles instead of the way it’s implemented (which  is still way, way better than pre-3.0 hints). However we cannot reuse sstable streaming,  and implementing something similar is involved - and ultimately not required. I’ll open a  separate ticket for 3.X for that  2. Maybe an ability to replay directly from the bufers, skipping the fles entirely, for the  common case of a large number of nodes timing out occasionally.
",,Architectural component behavior and structure,4:499 - 4:1003,1,arjan
25:13,1. Writing a hint generates garbage (we are allocating a BB instance t…,CASSANDRA-6230,"1. Writing a hint generates garbage (we are allocating a BB instance to encode the mutation  into for each hint), and there is often contention on the partition key, which causes us to  retry and use more memory.
",,Run-time quality issues,4:1110 - 4:1323,1,arjan
25:14,"The new implementation writes into a shared direct bufer, the way comp…",CASSANDRA-6230,"The new implementation writes into a shared direct bufer, the way compresses CL does.
Furthermore, if we are writing a hint for several down nodes at a time, we’ll only write the  hint once.
",,"Architectural component behavior and structure
Architectural tactics",4:1324 - 4:1516,2,arjan
25:15,2. Write amplifcation with current hints is signifcant: we write to th…,CASSANDRA-6230,"2. Write amplifcation with current hints is signifcant: we write to the CL frst, then  to the sstables, and the tombstones, when replaying, plus large amounts of compaction. The  latter is necessary to be able to do replay at all in presence of huge amounts of tombstones  in the queue-like partitions.
",,Run-time quality issues,4:1517 - 4:1820,1,arjan
25:16,The new implementation writes hints to fat fles (in a separate ’hints’…,CASSANDRA-6230,"The new implementation writes hints to fat fles (in a separate ’hints’ directory), just once.
Upon successful replay the fle gets deleted, and that’s the end of the story.
",,"Architectural component behavior and structure
Architectural tactics",4:1821 - 4:1994,2,arjan
25:17,3. Mean time to delivery is very signifcant. Because of the required p…,CASSANDRA-6230,"3. Mean time to delivery is very signifcant. Because of the required pre-delivery major  compaction, we only schedule deliver every 10 minutes.
",,Existing system architecture description,4:1995 - 4:2139,1,arjan
25:18,"The new implementation triggers delivery (unloading) every 10 seconds,…",CASSANDRA-6230,"The new implementation triggers delivery (unloading) every 10 seconds, because it’s now  cheap, thus reducing the inconsistency window observed (MTTD).
",,Architectural component behavior and structure,4:2140 - 4:2292,1,arjan
25:19,The scenario it’s aiming to support is hundreds of nodes timing out oc…,CASSANDRA-6230,"The scenario it’s aiming to support is hundreds of nodes timing out occasionally  (provided a tight timeout), and a few nodes being properly down. That should explain the  shared write bufers instead of having one per fle.
",,Architectural component behavior and structure,4:2387 - 4:2610,1,arjan
25:20,Writing to the bufer is multi-threaded - works mostly the same way tha…,CASSANDRA-6230,"Writing to the bufer is multi-threaded - works mostly the same way that writing to the  commitlog. Flushing the bufers to disk is all done from a single-threaded {{HintsWriteEx-  ecutor}} - writing in big chunks, maximizing sequential IO.
",,Architectural component behavior and structure,4:2611 - 4:2850,1,arjan
25:21,The new implementation changes the semantics for {{CL.ANY}}. Writing a…,CASSANDRA-6230,"The new implementation changes the semantics for {{CL.ANY}}. Writing a hint is now  considered successful immediately after it made it to a {{HintsBufer}}. There is a new  3
yaml parameter - {{hints_fush_period_in_ms}}, defaulting to 10000, that regulates how  often the bufer should be fushed to disk, but it does not provide any guarantees (and no  fsync is implied, either). I would argue that it’s a reasonable thing to do to CL.ANY. For  hints created by the batchlog, we explicitly fush and fsync all the afected fles before re-  moving the batchlog entries.
Replay (now called unloading) has also changed. It’s not as streaming as I’d like it to  be, but for unloading same version hints fle to a same (messaging) version host, we now just  page through a hints fle, and send the encoded hints to the node, verbatim, without any  decoding/encoding steps.
",,Architectural component behavior and structure,4:2851 - 5:690,1,arjan
25:22,The code is really boring and dumb (I hope). Most of the new classes a…,CASSANDRA-6230,"The code is really boring and dumb (I hope). Most of the new classes are testable now,  though not all of them properly tested. There is no reliance on singletoniness.
[~shawn.kumar] has some comprehensive dtests brewing, and I’ll add some more, but, again,  I don’t feel like that should block review.
",,,5:691 - 5:995,1,arjan
25:47,benedict,CASSANDRA-6230,benedict,,Comment,5:999 - 5:1006,1,arjan
25:23,"First pass of review (for patches of this size and importance, I prefe…",CASSANDRA-6230," First pass of review (for patches of this size and importance, I prefer to do two or  three passes, so I get better familiarized with it, and tend to work towards the fner details  in later rounds).
",,,5:1008 - 5:1208,1,arjan
25:24,I’ve pushed some minor comments/suggestions [here|https://github.com/b…,CASSANDRA-6230,"I’ve pushed some minor comments/suggestions [here|https://github.com/belliottsmith/cassandra/tree/6230-  suggestions].
",,,5:1209 - 5:1328,1,arjan
25:25,"Overall, it’s an excellent patch",CASSANDRA-6230,"Overall, it’s an excellent patch",,Architectural solution benefits and drawbacks,5:1329 - 5:1360,1,arjan
25:26,"The main issues are nomenclature, in particular ""unload-  ing"" as prob…",CASSANDRA-6230,"The main issues are nomenclature, in particular ""unload-  ing"" as probably much more intuitively named ""delivery"" (after all, it hasn’t arrived yet, so  unloading is premature...)",,,5:1363 - 5:1541,1,arjan
25:27,"On writing hints to a fle, if there is an error we will never retry to…",CASSANDRA-6230," On writing hints to a fle, if there is an error we will never retry to write the hint, and it  will be lost. This seems both acceptable but also undesirable, especially for transient errors.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:1641 - 5:1833,2,arjan
25:28,"On reading, if there is corruption we stop reading the whole fle. As w…",CASSANDRA-6230,"On reading, if there is corruption we stop reading the whole fle. As with CL, we may  prefer to try to skip over the problematic hint.
",,Architectural component behavior and structure,5:1836 - 5:1971,1,arjan
25:29,I would like to see at least a simple burn test introduced for hints w…,CASSANDRA-6230,"I would like to see at least a simple burn test introduced for hints writing (and replay)  since, although it seems correctly written to me from a concurrency point-of-view, it is an  important piece of infrastructure that will have, at periods, a lot of concurrent access.
",,,5:2060 - 5:2334,1,arjan
25:30,"For future work, I have been mulling the idea of merging the Commit Lo…",CASSANDRA-6230,"For future work, I have been mulling the idea of merging the Commit Log and Hints Log  directly together, with the obsolescence of a record simply being made a little more complex.
The idea would be to log each record against multiple targets, and have a parallel obsoles-  cence log (which could be a simple bitmap, near enough, although with range support for  the common case of invalidating the majority of records). Since we typically route trafc to  an owning node, this would make hints near zero-overhead, and all we would need to do -  if hints turn out to need retention - is periodically flter the log fles to their minimal set of  entries.
This would: permit us to have almost unlimited hints in-fight without hurting the server;  prevent hints thrashing the commit log disk (assuming they’re stored there); permit hints  to have zero resource overhead during load spikes; and eliminate multiple serializations from  the write path.
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Architectural tactics",5:2335 - 5:3282,3,arjan
25:31,Rebased on top of 8099 and later changes [here|https://github.com/iama…,CASSANDRA-6230,Rebased on top of 8099 and later changes [here|https://github.com/iamaleksey/cassandra/commits/6230-,,,5:3295 - 5:3394,1,arjan
25:32,"3.0]. Tests haven’t been ported yet (hoping to be done today, or early…",CASSANDRA-6230,"3.0]. Tests haven’t been ported yet (hoping to be done today, or early tomorrow), and review  feedback not addressed yet (hopefully will by end of Thursday or early Friday, will defnitely  be done by early Monday).
",,,6:1 - 6:216,1,arjan
25:33,"Edit: force-pushed a complete rebase to the same branch, including all…",CASSANDRA-6230,"Edit: force-pushed a complete rebase to the same branch, including all tests uncommented  and passing. Will start addressing review feedback today and hopefully be done by tomor-  row.
",,,6:217 - 6:402,1,arjan
25:34,Feedback mostly addressed in the commits pushed to the same branch. Sw…,CASSANDRA-6230,"Feedback mostly addressed in the commits pushed to the same branch. Switching  to Patch Available - awaiting new feedback.
",,,6:415 - 6:538,1,arjan
25:48,benedict,CASSANDRA-6230,benedict,,Comment,6:543 - 6:550,1,arjan
25:35,"OK, I’m +1",CASSANDRA-6230,"OK, I’m +1",,Architectural solution benefits and drawbacks,6:553 - 6:562,1,arjan
25:36,# To honour disk failure policy on startup if we fail to read a descri…,CASSANDRA-6230,"# To honour disk failure policy on startup if we fail to read a descriptor (or something  similar, rather than always fail)  # To not discard hints if we have a transient write error (but to discard them if errors persist  for too long)",,Architectural component behavior and structure,6:634 - 6:869,1,arjan
25:37,"These might be unimportant if we intend to deliver CASSANDRA-9834, how…",CASSANDRA-6230,"These might be unimportant if we intend to deliver CASSANDRA-9834, however.",,Architectural solution benefits and drawbacks,6:872 - 6:946,1,arjan
25:38,Thanks. [utests|http://cassci.datastax.com/job/iamaleksey-6230-3.0-tes…,CASSANDRA-6230,"Thanks. [utests|http://cassci.datastax.com/job/iamaleksey-6230-3.0-testall/] are  fne now, making [dtests|http://cassci.datastax.com/job/iamaleksey-6230-3.0-dtest/] happy  still requires some work, but will hopefully deal with all of them (all broken by 6230, that  is) tonight, and commit.
",,,6:962 - 6:1253,2,arjan
25:39,"Took a while, but cassci dtests are now fnally happy enough. Committed…",CASSANDRA-6230,"Took a while, but cassci dtests are now fnally happy enough. Committed as  [96d41f0e0e44d9b3114a5d80dedf12053d36a76b|https://github.com/apache/cassandra/commit/96d41f0e0e44d9b311  to cassandra-3.0 and merged into trunk.
",,,6:1267 - 6:1487,2,arjan
25:40,Please entertain this question even though it may seem unnecessary. Is…,CASSANDRA-6230,"Please entertain this question even though it may seem unnecessary. Is  there some way to now know about the _oldest pending_ hint for a node? In system.hints,  currently, this is trivial to know.",,,6:1556 - 6:1751,1,arjan
26:1,There is a few problems/improvements that can be done with the way we…,CASSANDRA-6717,"There is a few problems/improvements that can be done with the way we store schema:  # CASSANDRA-4988: as explained on the ticket, storing the comparator is now redundant (or  almost, we’d need to store whether the table is COMPACT or not too, which we don’t cur-  rently is easy and probably a good idea anyway)",,Technical debt,3:94 - 3:405,1,arjan
26:2,it can be entirely reconstructed from the infos  in schema_columns (th…,CASSANDRA-6717,"it can be entirely reconstructed from the infos  in schema_columns (the same is true of key_validator and subcomparator, and replacing de-  fault_validator by a COMPACT_VALUE column in all case is relatively simple). And storing  the comparator as an opaque string broke concurrent updates of sub-part of said comparator (con-  current collection addition or altering 2 separate clustering columns typically) so it’s really worth  removing it.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",3:408 - 3:852,2,arjan
26:3,# CASSANDRA-4603: it’s time to get rid of those ugly json maps.,CASSANDRA-6717,# CASSANDRA-4603: it’s time to get rid of those ugly json maps.,,Technical debt,3:853 - 3:915,1,arjan
26:4,I’ll note that schema_keyspaces  is a problem due to its use of COMPAC…,CASSANDRA-6717,"I’ll note that schema_keyspaces  is a problem due to its use of COMPACT STORAGE, ",,Architectural solution benefits and drawbacks,3:917 - 3:997,1,arjan
26:5,# For CASSANDRA-6382 and to allow indexing both map keys and values at…,CASSANDRA-6717,"# For CASSANDRA-6382 and to allow indexing both map keys and values at the same time,  we’d need to be able to have more than one index defnition for a given column.
",,Technical debt,3:1070 - 3:1236,1,arjan
26:6,# There is a few mismatches in table options between the one stored in…,CASSANDRA-6717,"# There is a few mismatches in table options between the one stored in the schema and the one  used when declaring/altering a table which would be nice to fx. The compaction, compression and  replication maps are one already mentioned from CASSANDRA-4603, but also for some reason  ’dclocal_read_repair_chance’ in CQL is called just ’local_read_repair_chance’ in the schema  table, and ’min/max_compaction_threshold’ are column families option in the schema but just  compaction options for CQL (which makes more sense).
",,Technical debt,3:1237 - 3:1758,1,arjan
26:7,"In particular, the  fact that ’schema_keyspaces’ uses COMPACT STORAGE…",CASSANDRA-6717,"In particular, the  fact that ’schema_keyspaces’ uses COMPACT STORAGE is annoying (for the replication map,  but it may limit future stuf too)",,Technical debt,3:1936 - 3:2077,1,arjan
26:8,"which suggest we should migrate it to a new, non COMPACT  table.",CASSANDRA-6717,"which suggest we should migrate it to a new, non COMPACT  table.",,Architectural design configuration,3:2079 - 3:2142,1,arjan
26:9,"Overall, what I would suggest is to move all schema tables to a new ke…",CASSANDRA-6717,"Overall, what I would suggest is to move all schema tables to a new keyspace, named ’schema’  for instance (or ’system_schema’ but I prefer the shorter version), and fx all the issues above at  once. Since we currently don’t exchange schema between nodes of diferent versions, all we’d need  to do that is a one shot startup migration, and overall, I think it could be simpler for clients to  2
deal with one clear migration than to have to handle minor individual changes all over the place.
I also think it’s somewhat cleaner conceptually to have schema tables in their own keyspace since  they are replicated through a diferent mechanism than other system tables.
If we do that, we could, for instance, migrate to the following schema tables (details up for  discussion of course):  CREATE TYPE user_type (  name text,  column_names list<text>,  column_types list<text>  )  CREATE TABLE keyspaces (  name text PRIMARY KEY,  durable_writes boolean,  replication map<string, string>,  user_types map<string, user_type>  )  CREATE TYPE trigger_definition (  name text,  options map<tex, text>  )  CREATE TABLE tables (  keyspace text,  name text,  id uuid,  table_type text, // COMPACT, CQL or SUPER  dropped_columns map<text, bigint>,  triggers map<text, trigger_definition>,  // options  comment text,  compaction map<text, text>,  compression map<text, text>,  read_repair_chance double,  dclocal_read_repair_chance double,  gc_grace_seconds int,  caching text,  rows_per_partition_to_cache text,  default_time_to_live int,  min_index_interval int,  max_index_interval int,  speculative_retry text,  populate_io_cache_on_flush boolean,  bloom_filter_fp_chance double  memtable_flush_period_in_ms int,  PRIMARY KEY (keyspace, name)  )  3
CREATE TYPE index_definition (  name text,  index_type text,  options map<text, text>  )  CREATE TABLE columns (  keyspace text,  table text,  name text,  kind text, // PARTITION_KEY, CLUSTERING_COLUMN, REGULAR or COMPACT_VALUE  component_index int;  type text,  indexes map<text, index_definition>,  PRIMARY KEY (keyspace, table, name)  )  Nit: wouldn’t hurt to create a simple enum that is reuse by both CFMetaData and CFPropDefs for  table options names while we’re at it once they are the same instead of repeating string constants  which is fragile.
",,Architectural design configuration,3:2316 - 5:556,1,arjan
26:10,I think it could be simpler for clients to  2deal with one clear migra…,CASSANDRA-6717,"I think it could be simpler for clients to  2
deal with one clear migration than to have to handle minor individual changes all over the place.
I also think it’s somewhat cleaner conceptually to have schema tables in their own keyspace since  they are replicated through a diferent mechanism than other system tables.
",,"Architectural solution benefits and drawbacks
Assumptions",3:2665 - 4:274,2,arjan
26:118,jbellis,CASSANDRA-6717,jbellis,,Comment,5:640 - 5:646,1,arjan
26:11,"I like the idea,",CASSANDRA-6717,"I like the idea,",,Architectural solution benefits and drawbacks,5:649 - 5:664,1,arjan
26:12,"but I do prefer the consistency of ""system tables are prefxed with  sy…",CASSANDRA-6717,"but I do prefer the consistency of ""system tables are prefxed with  system_."" /bikeshed",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:666 - 5:752,2,arjan
26:119,snazy,CASSANDRA-6717,snazy,,Comment,5:758 - 5:762,1,arjan
26:13,"I’d prefer to change PK of {{columns}} to {{((keyspace, table), name)}…",CASSANDRA-6717,"I’d prefer to change PK of {{columns}} to {{((keyspace, table), name)}} to reduce par-  tition size - just for the people that create a huge total number of columns.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:1031 - 5:1197,2,arjan
26:14,But altogether the schema draft in the description needs to be rewritt…,CASSANDRA-6717,"But altogether the schema draft in the description needs to be rewritten to refect CASSANDRA-  6382 for example.
",,,5:1198 - 5:1310,1,arjan
26:15,To keep old drivers/applications working when this is implemented (upg…,CASSANDRA-6717,"To keep old drivers/applications working when this is implemented (upgrade/migration  path), CASSANDRA-7622 could be used to simulate ’system’ keyspace tables.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",5:1312 - 5:1472,2,arjan
26:120,snazy,CASSANDRA-6717,snazy,,Comment,5:1476 - 5:1480,1,arjan
26:16,Proposal:  If we imagine a tool that extract and apply schema difs bet…,CASSANDRA-6717,"Proposal:  If we imagine a tool that extract and apply schema difs between clusters, it would be nice  to know whether the user had explicitly set a parameter value or whether it has not been  4
touched.
E.g. for such tools it would be great to have something like a {{user_modifed set<text>}}  in the {{tables}} table to be able to recognize parameters that have been explicitly (inten-  tionally) set (to their default values).",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:1483 - 6:235,2,arjan
26:121,slebresne,CASSANDRA-6717,slebresne,,Comment,6:241 - 6:249,1,arjan
26:17,"Btw, that wasn’t mentioned above but I do think we should move from th…",CASSANDRA-6717,"Btw, that wasn’t mentioned above but I do think we should move from the  old AbstractType class names for types in the schema tables. Let’s serialize types using  their CQL name (knowing that even for non-CQL types we’ll still use the double-quoted  classname). That probably means that for clustering columns defnition we’d have to keep  a boolean on whether the clustering order is reversed or not.
",,"Architectural design configuration
Assumptions",6:252 - 6:653,2,arjan
26:122,aleksey,CASSANDRA-6717,aleksey,,Comment,6:657 - 6:663,1,arjan
26:18,The end goal is to get as close to CQL CREATE TABLE syntax as technica…,CASSANDRA-6717,"The end goal is to get as close to CQL CREATE TABLE syntax as technically possible,  both for the schema tables and the metadata classes, too.
",,Motivation of design issue,6:703 - 6:846,1,arjan
26:123,aleksey,CASSANDRA-6717,aleksey,,Comment,6:850 - 6:856,1,arjan
26:19,"Actually, I think we should instead store the clustering order in ‘sys…",CASSANDRA-6717,"Actually, I think we should instead store the clustering order in ‘system_schema.tables‘  instead. That way we wouldn’t need the ‘is_reversed‘ boolean *or* the ‘component_index‘.
Would’ve allowed us to get rid of ‘component_index‘ too, if not for the composite parti-  tion key columns.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",6:1003 - 6:1291,3,arjan
26:20,"I’m sure I’m missing something, but why can’t we handle partition key…",CASSANDRA-6717,"I’m sure I’m missing something, but why can’t we handle partition key columns the same  way as clustering columns?
",,,6:1610 - 6:1725,1,arjan
26:124,thobbs,CASSANDRA-6717,thobbs,,Comment,6:1729 - 6:1734,1,arjan
26:21,"As of CASSANDRA-7563, whenever a UDT has a feld renamed and a UDF  use…",CASSANDRA-6717," As of CASSANDRA-7563, whenever a UDT has a feld renamed and a UDF  uses that UDT, we’re updating {{schema_functions}} to modify the argTypes and return-  Type. This is required because the AbstractType representation of UDTs includes the feld  name.",,Existing system architecture description,6:1736 - 6:1985,1,arjan
26:22,"With the changes in this ticket, we should be able to remove that hack…",CASSANDRA-6717,"With the changes in this ticket, we should be able to remove that hack ({{Func-  tions.FunctionsMigrationListener}})",,Architectural solution benefits and drawbacks,6:1987 - 6:2102,1,arjan
26:125,mfguiere,CASSANDRA-6717,mfguiere,,Comment,6:2109 - 6:2116,1,arjan
26:23,Builtin CQL functions are not described in the {{system}} keyspace in…,CASSANDRA-6717,"Builtin CQL functions are not described in the {{system}} keyspace in its  current representation, this new schema should include them next to the user defned ones  as:  * The {{system}} keyspace and its tables are described in the {{system}} keyspace, therefore  it would be consistent.
* Having builtin CQL functions described there would allow external tools to manipulate all  the functions in a similar way.
* This would document the available builtin function for users that don’t remember the ones  available in their current version of Cassandra.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",6:2119 - 6:2676,2,arjan
26:24,"If interested for interim development, schema processing updates for p…",CASSANDRA-6717,"If interested for interim development, schema processing updates for python-  driver are happening here: [branch 276|https://github.com/datastax/python-driver/tree/276].
Intended for use with {{iamaleksey/cassandra:JAVA-571}} branch (at 95740b as of this  post).
",,,6:2691 - 6:2954,1,arjan
26:25,"Looking into some failing metadata tests in the driver suite, I notice…",CASSANDRA-6717,"Looking into some failing metadata tests in the driver suite, I noticed this:  https://gist.github.com/aholmberg/d3c471a8fe16c9bdcb1d  Wanted to confrm that this is not expected, and inquire about the appropriate place to  raise the issue (existing ticket? new?).
",,,7:15 - 7:279,1,arjan
26:26,It’s how post-8099 should work with current schema.,CASSANDRA-6717,"It’s how post-8099 should work with current schema.
",,,7:293 - 7:345,1,arjan
26:27,"It is up to this ticket and JAVA-571, however, to deal with deal with…",CASSANDRA-6717,"It is up to this ticket and JAVA-571, however, to deal with deal with the new  representation (I’ll be pushing the necessary changes shortly).
The failing test you can ignore because that table won’t be in 3.0 post this ticket.
",,,7:359 - 7:588,1,arjan
26:126,aleksey,CASSANDRA-6717,aleksey,,Comment,7:593 - 7:599,1,arjan
26:28,Pushed the frst commit in the batch to https://github.com/iamaleksey/c…,CASSANDRA-6717,Pushed the frst commit in the batch to https://github.com/iamaleksey/cassandra/commits/6717-  0,,,7:602 - 7:696,1,arjan
26:29,"The frst commit merely moves the existing tables, with mostly existing…",CASSANDRA-6717,"The frst commit merely moves the existing tables, with mostly existing structure, to a  new system keyspace ({{system_schema}}). It doesn’t contain any of the deeper improve-  ments whatsoever, and is not supposed to. One exception is {{system_schema.keyspaces}}  table - that one is no longer {{COMPACT STORAGE}} or using JSON.
What it does contain is migration logic and tests ({{LegacySchemaMigrator}}, {{Lega-  cySchemaMigratorTest}}), the upgraded drivers, and code throughout the codebase modi-  fed to treat {{system_schema}} as a system table.
",,Architectural design configuration,7:699 - 7:1252,1,arjan
26:30,Things it’s missing:  - tests for aggregates migration; this one is be…,CASSANDRA-6717,"Things it’s missing:  - tests for aggregates migration; this one is because loading aggregates is broken in general  at the moment, in trunk  - upgrade dtests; it includes a reasonable amount of upgrade utests, though, and I’ve done  some manual testing as well  What it breaks:  - the included python-driver lacks some recent trunk-driver PRs. I will have it rebased before  committing this  I would be grateful if Test Eng could spare some time and help me with writing some  extra upgrade dtests for this. I’m over-capacity at the moment.
No new utests are failing, but dtests needs a new python-driver to properly run.
Once this patch is in, I’ll start incrementally adding the remaining patches.
",,,7:1253 - 7:1956,1,arjan
26:127,thobbs,CASSANDRA-6717,thobbs,,Comment,7:1961 - 7:1966,1,arjan
26:31,The frst commit looks reasonable overall to me.,CASSANDRA-6717, The frst commit looks reasonable overall to me.,,Architectural solution benefits and drawbacks,7:1968 - 7:2015,1,arjan
26:32,LegacySchemaMigrator.java:  * {{migrate()}}: should log when migration…,CASSANDRA-6717,"LegacySchemaMigrator.java:  * {{migrate()}}: should log when migration has completed successfully  * {{checkNeedsUpgrade()}}: the comment explaining the check for the ""supercolumn map""  isn’t immediately clear -- maybe point to the {{CompactTables}} javadoc or explicitly men-  tion that the supercolumn map is the only way {{column_name}} can be empty  * {{decodeTableMetadata()}}: when would {{cf_id}} not be present?
* {{serializeKind()}} is a dupe of {{SchemaKeyspaces.deserializeKind()}}  * {{decodeTableMetadata()}} is a near dupe of {{SchemaKeyspaces.createTableFromTableRowAndColumnRows()}  -- can we unify those somewhat?
* In {{parseAggregateFunctionName()}}, there’s the following comment: {{// function  name can be abbreviated (pre 2.2rc2) - it is in the same keyspace as the aggregate}}. It  6
sounds like we don’t allow that any more, so we don’t need to handle it.
* Perhaps rename {{LegacySchemaTables}} to {{LEGACY_SCHEMA_TABLES}}? (Looks  like a class name, currently.)  * typo in javadoc: infromation  SchemaKeyspaces.java:* This comment should be updated (or maybe just removed): ""Note  that because Keyspaces is a COMPACT TABLE, we’re really only setting static columns  internally and shouldn’t set any clustering""  Schema.java:  * You added a call to {{cfs.indexManager.setIndexRemoved()}} in {{dropTable()}}. Why  do we need that there now?
LegacySchemaMigratorTest.java:  * Needed test coverage:  ** Legacy schema tables are removed** New schema tables are written to with the correct  timestamp  ** Legacy schema tables don’t exist in new schema tables  ** Migrating tables in general, especially COMPACT ones  *** Null values for any optional felds  ** Maybe UDTs that refer to other UDTs?
** NTS keyspaces",,,7:2045 - 8:929,1,arjan
26:33,bq. typo in javadoc: infromation  Fixed. bq. migrate(): should log whe…,CASSANDRA-6717,"bq. typo in javadoc: infromation  Fixed.
bq. migrate(): should log when migration has completed successfully  Fixed.
bq. This comment should be updated (or maybe just removed): ""Note that because Keyspaces  is a COMPACT TABLE, we’re really only setting static columns internally and shouldn’t  set any clustering""  Fixed.
bq. In parseAggregateFunctionName(), there’s the following comment: // function name  can be abbreviated (pre 2.2rc2) - it is in the same keyspace as the aggregate. It sounds like  we don’t allow that any more, so we don’t need to handle it.
If we drop it here, we should drop it from 2.2 as well - depends on whether or not we  care about 2.2.0 being compatible with rc1-created aggregates. That said, it doesn’t hurt to  have it there, and it’s already gone from {{SchemaKeyspace}}.
bq. serializeKind() is a dupe of SchemaKeyspaces.deserializeKind()  bq. decodeTableMetadata() is a near dupe of SchemaKeyspaces.createTableFromTableRowAndColumnRows()  âĂŞ can we unify those somewhat?
We can, but there is zero point in doing so. With the next few commits they will diverge,  as the new {{system_schema.tables}} tables will take on an entirely diferent structure.
bq. Perhaps rename LegacySchemaTables to LEGACY_SCHEMA_TABLES? (Looks like  a class name, currently.)  7
That’s the old convention w/ these things, I don’t know how it started, but for tables  names we use {{TABLE_NAMES}} in constants, and for {{CFMetaData}} collections we  use {{TableNames}}. I’m just being consistent.
bq. decodeTableMetadata(): when would cf_id not be present?
I think after 2.1 startup upgrade it should never be the case, but it doesn’t hurt to leave it  there either. I did remove it from {{SchemaKeyspace.createTableFromTableRowAndColumnRows()}}  though  bq. checkNeedsUpgrade(): the comment explaining the check for the ""supercolumn map""  isn’t immediately clear âĂŞ maybe point to the CompactTables javadoc or explicitly men-  tion that the supercolumn map is the only way column_name can be empty  This is just a copy-paste of previous Sylvain’s code. Some of it will be gone soon - in  {{SchemaKeyspace}}, but some will remain in the migrate code.
bq. Migrating tables in general  That *should* be covered by {{SchemaLoader.schemaDefnition()}}. Some of the tables  there are currently commented out though, for one reason or the other.
bq. New schema tables are written to with the correct timestamp  Planned for this initially, but won’t do it until I’m done with the ticket. The tables will be  diferent, and so will be the code to check for timestamps - doing it at this point is somewhat  wasteful.
bq. Legacy schema tables don’t exist in new schema tables  Fixed.
The rest of the tests - yes. Will add later, but before closing the ticket, if you don’t mind -  I need this, and more code depending on this, in trunk, soon.
bq. You added a call to cfs.indexManager.setIndexRemoved() in dropTable(). Why do  we need that there now?
We used to add deletion to drop table/drop keyspace mutations - see https://github.com/apache/cassandra/blob/tru  and https://github.com/apache/cassandra/blob/trunk/src/java/org/apache/cassandra/schema/LegacySchemaTab  . It’s no longer feasible now that schema tables are not in the same keyspace as {{Index-  Info}} table, so I’m doing this instead - which is the same path that we use when we drop  an individual index on a column, or drop a column.
",,,8:945 - 9:2120,1,arjan
26:34,"bq. If we drop it here, we should drop it from 2.2 as well - depends o…",CASSANDRA-6717,"bq. If we drop it here, we should drop it from 2.2 as well - depends on whether or  not we care about 2.2.0 being compatible with rc1-created aggregates. That said, it doesn’t  hurt to have it there, and it’s already gone from SchemaKeyspace.
I don’t think we care about supporting rc1-created aggregates, but if you think it’s worth it  to keep the code there, maybe just make the code comment clearer to indicate that.
bq. I think after 2.1 startup upgrade it should never be the case, but it doesn’t hurt to leave it  there either. I did remove it from SchemaKeyspace.createTableFromTableRowAndColumnRows()  8
though  Okay, maybe just add that as a code comment where it’s left?
bq. That should be covered by SchemaLoader.schemaDefnition(). Some of the tables there  are currently commented out though, for one reason or the other.
Ah, I totally missed that. However, relying on the right kinds of tables being in SchemaLoader  for testing seems haphazard. Future changes to that fle could result in us losing test cover-  age without realizing it. I have a strong preference for systematically listing out all of the  table structures we need to cover inside LegacySchemaMigratorTest.
bq. The rest of the tests - yes. Will add later, but before closing the ticket, if you don’t  mind - I need this, and more code depending on this, in trunk, soon.
Sounds good.
bq. We used to add deletion to drop table/drop keyspace mutations \[...\] It’s no longer  feasible now that schema tables are not in the same keyspace as IndexInfo table  Makes sense, thanks.
It looks like cassci isn’t running the tests on this branch for some reason. Can you look  into that so that we don’t accidentally hose everything when this is committed?
",,,9:2133 - 10:1122,1,arjan
26:35,"bq. I don’t think we care about supporting rc1-created aggregates, but…",CASSANDRA-6717,"bq. I don’t think we care about supporting rc1-created aggregates, but if you  think it’s worth it to keep the code there, maybe just make the code comment clearer to  indicate that.
CASSANDRA-9771 makes this a no-brainer - we are reverting the change entirely.
",,,10:1136 - 10:1398,1,arjan
26:36,"bq. Okay, maybe just add that as a code comment where it’s left? Done.…",CASSANDRA-6717,"bq. Okay, maybe just add that as a code comment where it’s left?
Done.
bq. Ah, I totally missed that. However, relying on the right kinds of tables being in  SchemaLoader for testing seems haphazard. Future changes to that fle could result in us  losing test coverage without realizing it. I have a strong preference for systematically listing  out all of the table structures we need to cover inside LegacySchemaMigratorTest.
Done.
",,,10:1413 - 10:1849,1,arjan
26:37,"Rebased and force-pushed to the same branch, awaiting cassci results n…",CASSANDRA-6717,"Rebased and force-pushed to the same branch, awaiting cassci results now (http://cassci.datastax.com/view/Dev/vie  6717-0-dtest/ and http://cassci.datastax.com/view/Dev/view/iamaleksey/job/iamaleksey-  6717-0-testall/).
",,,10:1850 - 10:2070,1,arjan
26:38,Committed to trunk as {{7d6c876ec9f8dd143046f49b5d61066ad5206c1}}. Fix…,CASSANDRA-6717,"Committed to trunk as {{7d6c876ec9f8dd143046f49b5d61066ad5206c1}}. Fixed  the dtests broken by the patch in cassandra-dtest commit {{d31b56075623c19e5151400f83c8ea43f986d5ea}},  with the exception of {{auth_test.py}}.
Dtests should really switch to using python-driver metadata API directly, and not query  the internal schema tables. Will ask someone to make those changes.
",,,10:2084 - 10:2460,2,arjan
26:39,PR updating {{auth_test.py}} [here | https://github.com/riptano/cassan…,CASSANDRA-6717,PR updating {{auth_test.py}} [here | https://github.com/riptano/cassandra-dtest/pull/380],,,10:2471 - 10:2559,1,arjan
26:128,aholmber,CASSANDRA-6717,aholmber,,Comment,11:5 - 11:12,1,arjan
26:40,working on Aleksey’s branch commit [613053|https://github.com/iamaleks…,CASSANDRA-6717,"working on Aleksey’s branch commit [613053|https://github.com/iamaleksey/cassandra/commit/61305  this contrived schema is giving me issues:  1 create table k.t (a int, b int, c int, primary key((a,b))) with compact storage;  If I create starting in 3.0, system_schema.tables.fags is returning null (unclear if this is  expected or not).
If I create starting in 2.2.0-rc2 and try to upgrade to 3.0, the table is missing completely  from system_schema.tables",,Motivation of design issue,11:15 - 11:471,1,arjan
26:129,aleksey,CASSANDRA-6717,aleksey,,Comment,11:478 - 11:484,1,arjan
26:41,"Trunk has issues with reading pre-3.0 sstable at the moment, that’s th…",CASSANDRA-6717,"Trunk has issues with reading pre-3.0 sstable at the moment, that’s the reason why.
",,Run-time quality issues,11:612 - 11:696,1,arjan
26:130,aleksey,CASSANDRA-6717,aleksey,,Comment,11:701 - 11:707,1,arjan
26:42,"It’s not {{super}}, it’s not {{counter}} (duh). It’s not {{compound}},…",CASSANDRA-6717,"It’s not {{super}}, it’s not {{counter}} (duh). It’s not {{compound}}, and not supposed  to be, and it’s not supposed to be {{dense}} either. So you wouldn’t expect any fags here.
It’s a static compact.
",,Existing system architecture description,11:829 - 11:1033,1,arjan
26:43,"Now, it would be nice to have a way to diferentiate between  1 create…",CASSANDRA-6717,"Now, it would be nice to have a way to diferentiate between  1 create table k.t (a int, b int, c int static, column1 text, value blob, primary key  ((a, b), column1))  and  1 create table k.t (a int, b int, c int, primary key((a,b))) with compact storage;  , if only for {{DESCRIBE}} purposes, but this is not an issue introduced by this patch.
Plus I’m not certain if there is too much value in doing so.
",,Architectural solution benefits and drawbacks,11:1034 - 11:1441,1,arjan
26:44,"The easiest way would be to introduce a {{compact}} fag, with the sole…",CASSANDRA-6717,"The easiest way would be to introduce a {{compact}} fag, with the sole purpose of in-  dicating that a table was originally created with {{COMPACT STORAGE}}.
",,Architectural component behavior and structure,11:1442 - 11:1600,1,arjan
26:45,"EDIT: Never mind, I was just 3 A.M. - level tired. The diference is in…",CASSANDRA-6717,"EDIT: Never mind, I was just 3 A.M. - level tired. The diference is in the {{compound}}  fag. If it’s not there, the table would’ve been created with {{COMPACT STORAGE}},  and the clustering {{column1}}, the regular {{value}}, and the static of {{c}} are all auto-  generated. You should be looking at absence of {{compound}} fag here.
25. aleksey: [~aholmber] Have a look at [these methods|https://github.com/apache/cassandra/blob/trunk/src/java/or  L1238] for {{DESCRIBE}} purposes.
26. aholmber: Makes sense. Thanks.
I was also forgetting that empty set returns null.
",,,11:1601 - 11:2175,1,arjan
26:131,thobbs,CASSANDRA-6717,thobbs,,Comment,12:5 - 12:10,1,arjan
26:46,2.1 and 3.0 currently have diferent behavior around default compact va…,CASSANDRA-6717,"2.1 and 3.0 currently have diferent behavior around default compact value columns.
When you create a table like this:  CREATE TABLE foo (  k int,  c int,  PRIMARY KEY (k, c)  ) WITH COMPACT STORAGE;  2.1 will add a {{compact_value}} column to {{system.schema_columns}} with an empty  {{column_name}} and a {{BytesType}} validator.
In 3.0, we instead add a {{regular}} column with the default compact value name ({{value}})  and an {{EmptyType}} validator.
The logic in 3.0 depends on having an EmptyType column (see {{CompactTables.hasEmptyCompactValue()}})  but current trunk doesn’t migrate the column. {{LegacySchemaMigrator.addDefnitionForUpgrade()}}  almost does what we want, but doesn’t add the {{EmptyType}} column because it sees the  existing {{compact_value}} column.
",,Motivation of design issue,12:13 - 12:795,1,arjan
26:132,aleksey,CASSANDRA-6717,aleksey,,Comment,12:800 - 12:806,1,arjan
26:47,Pushed the [next commit|https://github.com/iamaleksey/cassandra/commit…,CASSANDRA-6717,Pushed the [next commit|https://github.com/iamaleksey/cassandra/commit/f23421467eaa9d85387cfced9  to [6717-1 branch|https://github.com/iamaleksey/cassandra/commits/6717-1].,,,12:809 - 12:980,1,arjan
26:48,That one gets rid of all the cruft and JSON in {{system_schema.tables}…,CASSANDRA-6717,"That one gets rid of all the cruft and JSON in {{system_schema.tables}} table, match-  ing the structure exactly with CQL {{CREATE TABLE}} syntax.
",,Architectural design configuration,12:983 - 12:1130,1,arjan
26:49,"It also renames {{Kind.CLUSTERING_COLUMN}} to {{Kind.CLUSTERING}}, whi…",CASSANDRA-6717,"It also renames {{Kind.CLUSTERING_COLUMN}} to {{Kind.CLUSTERING}}, which  it should, but not in this commit. I don’t remember why it slipped there. Will commit to  trunk separately. Sorry.
",,,12:1131 - 12:1320,1,arjan
26:50,[Another commit|https://github.com/iamaleksey/cassandra/commit/f0f1d6f…,CASSANDRA-6717,"[Another commit|https://github.com/iamaleksey/cassandra/commit/f0f1d6f88a9539663b982708bb188524efed53a2]  deals with dropped columns properly, fetching the required collection information from the  old comparator. It also fxes the issue which is lack of {{equals()}} and {{hashCode()}}  which was breaking schema changes a bit",,Architectural design configuration,12:1321 - 12:1646,1,arjan
26:51,"Unfortunately, I can’t test it in a unit test, for collections are no…",CASSANDRA-6717,"Unfortunately, I can’t test it in a unit test, for collections are no longer in the compara-  tor - this will have to be verifed via a dtest (but manual testing shows that it works).
",,,12:1650 - 12:1833,1,arjan
26:133,snazy,CASSANDRA-6717,snazy,,Comment,12:1838 - 12:1842,1,arjan
26:52,Looks  pretty good so far,CASSANDRA-6717,Looks  pretty good so far,,Architectural solution benefits and drawbacks,12:1914 - 12:1938,1,arjan
26:53,* {{NativeSSTableLoaderClient}}: unused import + copy-paste bug in [li…,CASSANDRA-6717,* {{NativeSSTableLoaderClient}}: unused import + copy-paste bug in [line 105|https://github.com/iamaleksey/cass  3d1a427a3ad17cc9b29f766e464d7f01R101],,,12:1989 - 12:2138,1,arjan
26:54,* {{SchemaKeyspace.buildCompactionMap()}} uses Java refection to valid…,CASSANDRA-6717,"* {{SchemaKeyspace.buildCompactionMap()}} uses Java refection to validate compaction  parameters. It looks a bit weird. Any plans to implement some _CompactionStrategyOp-  tions_ classes?
",,Architectural component behavior and structure,12:2141 - 12:2328,1,arjan
26:55,"* {{CFMetaData}} has now the feld {{EnumSet fags}}, which is used for…",CASSANDRA-6717,"* {{CFMetaData}} has now the feld {{EnumSet fags}}, which is used for equals/hashCode  and from {{SchemaKeyspace.addTableToSchemaMutation()} - so that’s both the {{fags}}  set and the four boolean felds. The fags feld is easier to understand - the discrete felds  are better for performance. Can you refactor that to a simple bitmap backed by a primitive  {{byte}} so we get best of both worlds?
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Architectural tactics",12:2330 - 12:2726,3,arjan
26:56,* {{CFMetaData.bloomFilterFpChance}} is a boxed {{Double}}. Should be…,CASSANDRA-6717,"* {{CFMetaData.bloomFilterFpChance}} is a boxed {{Double}}. Should be possible to  11
migrate it to a primitive {{double}} when {{null}} handling as in {{getBloomFilterF-  pChance()}} is done in {{LegacySchemaMigrator}}  * {{CFMetaData.equals}} uses {{Objects.equal}} even for primitive felds (so boxing these  primitives). I could not fnd any usage of {{CFMetaData.equals()}} on a critical path - so  feel free to leave it as is.
",,,12:2727 - 13:346,1,arjan
26:57,"* {{system_schema.tables}}: the columns {{fags}}, {{caching}}, {{compa…",CASSANDRA-6717,"* {{system_schema.tables}}: the columns {{fags}}, {{caching}}, {{compaction}}, {{com-  pression}} could be frozen. AFAIK the whole collection will be contained in a mutation  anyway - so we could end up with less cells.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",13:347 - 13:567,2,arjan
26:58,* {{system_schema.columns}} got a new column {{column_name_bytes}}. Th…,CASSANDRA-6717,"* {{system_schema.columns}} got a new column {{column_name_bytes}}. This feels re-  dundant for CQL tables. AFAIK this is for Thrift backwards compatibility, right?
",,Architectural solution benefits and drawbacks,13:568 - 13:733,1,arjan
26:134,snazy,CASSANDRA-6717,snazy,,Comment,13:778 - 13:782,1,arjan
26:59,just +1,CASSANDRA-6717,just +1,,Architectural solution benefits and drawbacks,13:833 - 13:839,1,arjan
26:60,"[~snazy] This ticket is about changing the schema tables, not refactor…",CASSANDRA-6717,"[~snazy] This ticket is about changing the schema tables, not refactoring {{CFMeta-  Data}}. CASSANDRA-9712 is for the latter. Here, I’m doing the minimal amount of change  necessary ({{CLUSTERING}} rename aside) to these classes go get the correct schema work.
Plus, some of the comments here, while appreciated, aren’t even about the changes made.
Other than the comment about frozen, save these for CASSANDRA-9712, please. Still,  thanks.
",,,13:925 - 13:1369,2,arjan
26:135,snazy,CASSANDRA-6717,snazy,,Comment,13:1374 - 13:1378,1,arjan
26:62,"Regarding my review comments, [~iamaleksey] and I agreed on:  * re-thi…",CASSANDRA-6717,"Regarding my review comments, [~iamaleksey] and I agreed on:  * re-think about making the collections in the schema {{frozen}} as a fnal step of this ticket.
* re-consider the {{CFMetaData}} and {{SchemaKeyspace}} when CASSANDRA-9712 is  under review  * fx the nits in {{NativeSSTableLoaderClient}} on commit.
",,,13:1381 - 13:1692,2,arjan
26:61,This leaves one +1 on the frst commit in his branch and another +1 on…,CASSANDRA-6717,This leaves one +1 on the frst commit in his branch and another +1 on the second commit  - ending in a +1+1=+1 on 6717-1 ;),,Architectural solution benefits and drawbacks,13:1693 - 13:1815,1,arjan
26:136,aleksey,CASSANDRA-6717,aleksey,,Comment,13:1822 - 13:1828,1,arjan
26:63,Force-pushed an update to the second commit that fxes {{LegacyLayout.m…,CASSANDRA-6717,"Force-pushed an update to the second commit that fxes {{LegacyLayout.makeLegacyComparator()}}  (by having it account for dropped collection columns), and adds dropped-columns migration  coverage to {{LegacySchemaMigratorTest}}, now that it’s possible with a properly stored  legacy comparator.
",,Architectural component behavior and structure,13:1831 - 13:2124,1,arjan
26:137,thobbs,CASSANDRA-6717,thobbs,,Comment,13:2130 - 13:2135,1,arjan
26:64,I’m also +1 on the second commit,CASSANDRA-6717,I’m also +1 on the second commit,,Architectural solution benefits and drawbacks,13:2138 - 13:2169,1,arjan
26:65,* {{addSetEntry()}} should ensure it’s a non-frozen set (through {{c.t…,CASSANDRA-6717,"* {{addSetEntry()}} should ensure it’s a non-frozen set (through {{c.type.isMultiCell()}}).
We should go ahead and similarly fx {{addMapEntry()}} and {{addListEntry()}} as well.
",,Architectural component behavior and structure,13:2245 - 13:2424,1,arjan
26:66,"* typo: s/hasn’t/has/ in ""Cannot set non static column "" + c + "" since…",CASSANDRA-6717,"* typo: s/hasn’t/has/ in ""Cannot set non static column "" + c + "" since no clustering hasn’t  been provided""  SchemaKeyspace:  * {{buildCompactionMap()}} could use a comment explaining what we’re doing with the  threshold options and {{validateOptions()}}. Something like ""Add min_threshold and  max_threshold to the compaction strategy options if they’re recognized by the compaction  strategy class.""  * {{isSystemKeyspaceSchemaPartition()}} should technically be using {{UTF8Type.instance.compose()}}  instead of {{AsciiType}}. Shouldn’t matter for now, but it’s nice to use the expected type.
As a side note, we should be documenting the keyspace, table, and column changes. Driver  12
authors will need to know how to handle the new schema, and it may be useful for some  users as well. I don’t know if you’re waiting to do that at the end, but doing it as you go  might help to ensure that you don’t miss anything.
",,,13:2425 - 14:232,1,arjan
26:138,thobbs,CASSANDRA-6717,thobbs,,Comment,14:237 - 14:242,1,arjan
26:67,+1 overall on the dropped columns handling commit,CASSANDRA-6717,+1 overall on the dropped columns handling commit,,Architectural solution benefits and drawbacks,14:245 - 14:293,1,arjan
26:68,I would like to see test  coverage for re-adding and then dropping aga…,CASSANDRA-6717,"I would like to see test  coverage for re-adding and then dropping again (with normal columns, collections, and  frozen collections), though.
",,,14:296 - 14:438,1,arjan
26:69,"Committed to trunk with nits addressed, as {{8d7c608bac9440911f4803db0…",CASSANDRA-6717,"Committed to trunk with nits addressed, as {{8d7c608bac9440911f4803db04f306f0616f2a22}},  {{dc8523819f549acd0c902dc1d118cc404718003}}, and {{1b5fa8ce3cbd238b0e735ed067eb95c83b67f262}}.
",,,14:452 - 14:637,1,arjan
26:139,snazy,CASSANDRA-6717,snazy,,Comment,14:642 - 14:646,1,arjan
26:70,"You should add a method {{QueryProcessor.resultifyPrepared}}, that wor…",CASSANDRA-6717,"You should add a method {{QueryProcessor.resultifyPrepared}}, that works like {{resul-  tify}}, but uses {{SelectStatement ss = (SelectStatement) prepareInternal(query).statement;}}  instead of {{getStatement}} to omit CQL parse+prepare.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",14:656 - 14:894,2,arjan
26:71,"If this has been committed to trunk, should this be marked resolved?",CASSANDRA-6717,"If this has been committed to trunk, should this be marked resolved?
",,,14:912 - 14:981,1,arjan
26:72,"No, there is more to do. I’m just committing in chunks to not stall so…",CASSANDRA-6717,"No, there is more to do. I’m just committing in chunks to not stall some dependent  progress, and reuse a single ticket instead of multiplying many.
",,,14:995 - 14:1144,2,arjan
26:73,IâĂŹve started adding dtests for this and ran into a small issue. With…,CASSANDRA-6717,"IâĂŹve started adding dtests for this and ran into a small issue. With the  schema_* tables being renamed some of them confict with the cql describe command. Ex-  ample when scoped to the system_schema keyspace running ‘desc tables‘ gives a list of tables  in the keyspace instead of the cql for the tables table. Using ‘desc system_schema.tables‘  works as expected.
Does any documentation or ? need to be updated to explain that behavior?
",,,14:1161 - 14:1603,1,arjan
26:74,"No, I don’t think *that* is something we care about - it’s been like t…",CASSANDRA-6717,"No, I don’t think *that* is something we care about - it’s been like this forever.
Create a keyspace test, {{USE}} it, create a table ’tables’ in it, and run {{desc tables}},  and you’ll see the same exact behavior.
",,,14:1617 - 14:1834,1,arjan
26:75,I added some [dtests|https://github.com/riptano/cassandra-dtest/commit…,CASSANDRA-6717,"I added some [dtests|https://github.com/riptano/cassandra-dtest/commit/c346c6b87ec081956330e5b  to check schema metadata -- anything additional that should be added?
",,,14:1851 - 14:2017,1,arjan
26:140,aleksey,CASSANDRA-6717,aleksey,,Comment,14:2022 - 14:2028,1,arjan
26:76,"[~nutbunnies] Secondary indexes, UDFs, UDAs, at least. A much wider ra…",CASSANDRA-6717,"[~nutbunnies] Secondary indexes, UDFs, UDAs, at least. A much wider range of  tables - including {{COMPACT STORAGE}}.
",,Architectural component behavior and structure,14:2031 - 14:2149,1,arjan
26:77,Reassigning to Sam to deal with multiple indexes per column. Will reas…,CASSANDRA-6717,"Reassigning to Sam to deal with multiple indexes per column. Will reassign back to  self once it’s done, to deal with representing types in schema in CQL form (think {{int}} in-  stead of {{org.apache.cassandra.db.marshal.Int32Type}}) in {{system_schema.columns}},  {{system_schema.types}}, {{system_schema.functions}}, etc",,,14:2163 - 14:2485,1,arjan
26:141,nutbunnies,CASSANDRA-6717,nutbunnies,,Comment,14:2493 - 14:2502,1,arjan
26:78,In adding additional table [dtests|https://github.com/riptano/cassandr…,CASSANDRA-6717,In adding additional table [dtests|https://github.com/riptano/cassandra-dtest/pull/444/fles]  I came across a o.a.c.e.UnrecognizedEntityException when migrating aggregates from 2.2 to  3.0. This failure can be exercised outside of the upgrade dtest with this [gist|https://gist.github.com/nutbunnies/3a5,,Motivation of design issue,14:2505 - 14:2807,1,arjan
26:142,aleksey,CASSANDRA-6717,aleksey,,Comment,14:2814 - 14:2820,1,arjan
26:79,"UDAs are currently broken in 3.0, yes. [~snazy] is aware, and we have…",CASSANDRA-6717,"UDAs are currently broken in 3.0, yes. [~snazy] is aware, and we have a JIRA  open for it (I don’t recall the # though).
",,Run-time quality issues,14:2823 - 14:2944,1,arjan
26:143,samt,CASSANDRA-6717,samt,,Comment,14:2949 - 14:2952,1,arjan
26:80,I’ve pushed a commit to [6717-notest|https://github.com/beobal/cassand…,CASSANDRA-6717,I’ve pushed a commit to [6717-notest|https://github.com/beobal/cassandra/tree/6717-  notest] which moves secondary index metadata out of column defnitions and into its own  table & classes.,,Architectural design configuration,14:2955 - 14:3143,1,arjan
26:144,aholmber,CASSANDRA-6717,aholmber,,Comment,15:5 - 15:12,1,arjan
26:81,"While testing python-driver against this, I noticed that secondary ind…",CASSANDRA-6717,"While testing python-driver against this, I noticed that secondary indexes are  not implicitly dropped when a table they’re attached to is dropped. Previous versions would  drop them. Is this change in behavior expected?
",,Motivation of design issue,15:15 - 15:236,1,arjan
26:145,aleksey,CASSANDRA-6717,aleksey,,Comment,15:241 - 15:247,1,arjan
26:82,"No, it’s not expected.",CASSANDRA-6717,"No, it’s not expected.
",,Motivation of design issue,15:250 - 15:273,1,arjan
26:83,"[~aholmber] good catch, thanks. I’ve fxed that, rebased and pushed an…",CASSANDRA-6717,"[~aholmber] good catch, thanks. I’ve fxed that, rebased and pushed an updated  version. Also, a couple of minor naming changes, only {{index_options}} -> {{options}}  in {{system_schema.indexes}} will be relevant to drivers I think.
",,,15:284 - 15:517,2,arjan
26:84,The [driver branch|https://github.com/datastax/python-driver/tree/276]…,CASSANDRA-6717,"The [driver branch|https://github.com/datastax/python-driver/tree/276] is up-  dated to refect that naming change.
",,,15:532 - 15:647,1,arjan
26:146,aleksey,CASSANDRA-6717,aleksey,,Comment,15:652 - 15:658,1,arjan
26:85,"Publicly-visible bits LGTM, the remained - mostly LGTM",CASSANDRA-6717,"Publicly-visible bits LGTM, the remained - mostly LGTM",,Architectural solution benefits and drawbacks,15:661 - 15:714,1,arjan
26:86,A few places  1. {{indexDef.indexType == IndexMetadata.IndexType.CUSTO…,CASSANDRA-6717,"A few places  1. {{indexDef.indexType == IndexMetadata.IndexType.CUSTOM}} and similar compar-  isons to {{IndexType}} enum, would better be {{isCustom()}}, {{isKeys()}}, {{isCompos-  ites()}} methods in {{IndexMetadata}}  {{CFMetaData}}  2. {{CFMetaData.getAvailableIndexName()}} should be moved to Indexes  3. {{else if (getIndexes().get(def).isPresent())}} - should be a method in {{Indexes}} ({{In-  dexes.indexes()}}?)  4. {{isIndexNameValid()}} should be moved to {{IndexMetadata}}  5. {{existingIndexNames()}} should be keyspace-scoped - and moved to {{KeyspaceMeta-  data}} (a per-existing issue)  6. {{equals()}}/{{hashCode()}}/{{toString()}} should take indexes into account  7.
1 if (index.indexType == IndexMetadata.IndexType.CUSTOM)  2 {  3 if (index.options == null || !index.options.containsKey(SecondaryIndex.
CUSTOM_INDEX_OPTION_NAME))  4 throw new ConfigurationException(""Required index option missing: "" +  SecondaryIndex.CUSTOM_INDEX_OPTION_NAME);  5 }  belongs to {{IndexMetadata.validate()}}, and so does  1 if (!isIndexNameValid(index.name))  2 throw new ConfigurationException(""Illegal index name "" + index.name);  8.
1 if (isSuper())  2 throw new ConfigurationException(""Secondary indexes are not supported on super  column families"");  14
doesnâĂŹt need to be in a loop, just {{if (!indexes.isEmpty() && isSuper())}} on top will  do (pre-exsiting)  {{CreateIndexStatement}}  9. {{fndIndexedCF()}} should be moved to KeyspaceMetadata (pre-existing issue)  {{ColumnFamilyStore}}  10. {{if (info.indexType != null)}} check is redundant, {{indexType}} is non-nullable  11.
1 // also clean out any index leftovers.
2 for (IndexMetadata def : metadata.getIndexes())  3 {  4 CFMetaData indexMetadata = SecondaryIndex.newIndexMetadata(metadata, def);  5 if (indexMetadata != null)  6 scrubDataDirectories(indexMetadata);  7 }  should check type for {{CUSTOM}} right there instead, and {{SI.newIndexMetadata()}}  should assert {{type != CUSTOM}} (pre-existing-ish)  {{SchemaKeyspace}}  12. {{resetCollection}}, {{addMapEntry}}, and {{addSetEntry}} loops should be replaced  with {{RowUpdateBuilder.map()/set()}}} where possible. And then all switched to {{frozen}}  collection, with the rest of the schema (I or Robert will handle in a separate commit)",,,15:833 - 16:1006,1,arjan
26:87,"[~iamaleksey] thanks, I’ve pushed additional commits addressing your c…",CASSANDRA-6717," [~iamaleksey] thanks, I’ve pushed additional commits addressing your comments.bq.
5. existingIndexNames() should be keyspace-scoped - and moved to KeyspaceMetadata (a  per-existing issue)  done, but this required an additional null check in {{CFMetadata#validate}} because when  a keyspace is frst added, we can’t get the ksm from schema.
bq. 9. fndIndexedCF() should be moved to KeyspaceMetadata (pre-existing issue)  done, and though it’s right to move the lookup to KSM, it doesn’t clean up {{DropIndexS-  tatement}} a great deal as it still needs the logic for handling an undefned keyspace and  {{ifExists}}  [~aholmber] thanks, that’s great. I can get onto running dtests now.
",,,16:1018 - 16:1703,1,arjan
26:88,The [Java driver PR|https://github.com/datastax/java-driver/pull/430]…,CASSANDRA-6717,"The [Java driver PR|https://github.com/datastax/java-driver/pull/430] is also up-  to-date with the latest changes.
",,,16:1717 - 16:1833,1,arjan
26:89,bq. The Java driver PR is also up-to-date with the latest changes. Bri…,CASSANDRA-6717," bq. The Java driver PR is also up-to-date with the latest changes.
Brilliant, thanks!",,,16:1843 - 16:1929,1,arjan
26:147,aleksey,CASSANDRA-6717,aleksey,,Comment,16:1936 - 16:1942,1,arjan
26:90,"LGTM, +1, once cassci is happy",CASSANDRA-6717,"LGTM, +1, once cassci is happy",,Architectural solution benefits and drawbacks,16:1945 - 16:1974,1,arjan
26:91,Pulling in the new version of the driver required some changes to UDFs…,CASSANDRA-6717,"Pulling in the new version of the driver required some changes to UDFs. I’ve pushed  a new version [here|https://github.com/beobal/cassandra/tree/6717] with that done and  pretty much all of the previously failing unit tests are now passing.
[~snazy], would you mind reviewing the UDF changes please? It’s only the last commit on  15
that branch. FTR, there’s one new UF test failure - {{UFTest#testFunctionWithFrozenTupleType}}  - see [this comment|https://datastax-oss.atlassian.net/browse/JAVA-875?focusedCommentId=23660&page=com.at  tabpanel#comment-23660] for details.
",,,16:1988 - 17:241,2,arjan
26:92,"Just a note, there are actually some new test failures in BatchLogMana…",CASSANDRA-6717,"Just a note, there are actually some new test failures in BatchLogManagerTest. I’ll  push a fx for them asap.",,,17:252 - 17:360,1,arjan
26:148,snazy,CASSANDRA-6717,snazy,,Comment,17:367 - 17:371,1,arjan
26:93,+1 on the UDF changes (2bb207c83f105779e2dd974c49896c0acf82824e),CASSANDRA-6717,+1 on the UDF changes (2bb207c83f105779e2dd974c49896c0acf82824e),,Architectural solution benefits and drawbacks,17:374 - 17:437,1,arjan
26:94,(There are a couple more unit test failures - many (esp. the pig tests…,CASSANDRA-6717,"(There are a couple more unit test failures - many (esp. the pig tests) probably related to  the new driver version.
",,,17:441 - 17:558,1,arjan
26:95,"I’ve fxed BatchLogManagerTest and a number of the thrift dtests. Also,…",CASSANDRA-6717,"I’ve fxed BatchLogManagerTest and a number of the thrift dtests. Also, updated the  bundled java driver with the latest from the [JAVA-875|https://datastax-oss.atlassian.net/browse/JAVA-  875] branch and the bundled python driver with the latest from [PYTHON-276|https://datastax-  oss.atlassian.net/browse/PYTHON-276]. I’ll commit to 3.0 when cassci is happy.
For future reference, the command to build a source dist of the python driver for inter-  nal use during dev is  1 \newline%  2 %  3 \item%  4 \textbf{samt: }committed the 2i changes to 3.0 in \{\{06  c130e3cb85577041b475084400c08c505d8f9e\}\}. The {[}latest|http://cassci.
datastax.com/view/Dev/view/beobal/job/beobal{-}6717{-}testall/  lastCompletedBuild/testReport/{]} {[}cassci|http://cassci.datastax.com/view/Dev  /view/beobal/job/beobal{-}6717{-}dtest/lastCompletedBuild/testReport/{]} runs  look ok, as in mostly the failures are also present on 3.0/trunk. The exception  is \{\{schema\_metadata\_test:TestSchemaMetadata.indexes\_test\}\} which  passes when run with the latest driver changes (which {[}\textasciitilde{}  aholmber{]} has kindly merged to the \{\{cassandra{-}test\}\} branch now).\  newline%  5 %  6 \item%  7 \textbf{aleksey: }Well done.\newline%  8 \newline%  9 Assigning the issue back to self, and relabeling as beta 2. There is one change  remaining that we want to squeeze in before GA, and that is storing column/  argument types as their CQL representation, instead of FQDN class names.\  newline%  10 \newline%  11 Plus, addressing some of the original remaining feedback from Tyler and Robert (in  particular making all collections frozen).%  12 \item%  13 \textbf{nutbunnies: }There appears to be a couple issues with UDT and UDF migration  from 2.2{-}>3.0. Both seem to be related to the number of nodes in the  cluster during the upgrade. More nodes cause more duplication of field data  but it’s inconsistent and can range from the correct value to the number of  nodes. I havenâ˘ A´ Zt been able reproduce on single or 2 node clusters. Iâ˘ A´ Zve  verified that the metadata returned from the driver does match the reality of  the system\_schema.functions and system\_schema.user\_types tables.\newline%  14 \newline%  15 I’ve extracted the failures from the upgrade test to simplify and remove other test  influences.\newline%  16 UDT:field\_names duplication can be reproduced with this {[}gist|https://gist.
github.com/nutbunnies/4d1dcfe96556d0218b15{]}UDF:argument\_names duplication  can be reproduced with this {[}gist|https://gist.github.com/nutbunnies/51  b61d245f00106b1641{]}\newline%  17 \newline%  18 Both can also be reproduced by enabling the establish/verify methods in the upgrade  dtest in this {[}PR|https://github.com/riptano/cassandra{-}dtest/pull/447{]}.\  newline%  19 \newline%  20 This was done with C* at \{\{06c130e3cb85577041b475084400c08c505d8f9e\}\} and the  python{-}driver at \{\{caf58cc5e72afe664759b50dbcc92993902beb3e\}\}\newline%  16
21 %  22 \item%  23 \textbf{aleksey: }{[}\textasciitilde{}snazy{]} Could you please have a look at  \^{}? Thanks.%  24 \item%  25 \textbf{snazy: }Can reproduce the behaviour using the following commands:\newline%  26 \newline%  27 \begin{spverbatim}  28 ccm create -s -n 4 -v 2.2 --vnodes c22_upgrade  29 ccm node1 cqlsh  30 create keyspace foo with replication = {’class’:’SimpleStrategy’, ’  replication_factor’:1};  31 create TYPE foo.bla(a int, b text);  32 ccm node1 stop  33 ccm node1 setdir -v 3.0  34 ccm node1 start  35  36 ccm node1 cqlsh  37 select * from system_schema.types ;  38 \end{spverbatim}\ \newline%  39 \newline%  40 \begin{spverbatim}  41 select * from system_schema.types ;  42  43 keyspace_name | type_name | field_names | field_types  44 ---------------+-----------+-------------+--------------------------------------------------------------  45 foo | bla | [’a’, ’b’] | [’org.apache.cassandra.db.marshal.
Int32Type’, ’org.apache.cassandra.db.marshal.UTF8Type’]  46 \end{spverbatim}\ \newline%  47 \newline%  48 \begin{spverbatim}  49 ccm node2 stop  50 ccm node2 setdir -v 3.0  51 ccm node2 start  52 \end{spverbatim}\ \newline%  53 \newline%  54 \begin{spverbatim}  55 ccm node1 cqlsh  56 select * from system_schema.types ;  57 ccm node2 cqlsh  58 select * from system_schema.types ;  59 \end{spverbatim}\ \newline%  60 \newline%  61 \begin{spverbatim}  62 select * from system_schema.types ;  63  64 keyspace_name | type_name | field_names | field_types  65 ---------------+-----------+----------------------+-----------------------------------------------------  66 foo | bla | [’a’, ’b’, ’a’, ’b’] | [’org.apache.cassandra.db.
marshal.Int32Type’, ’org.apache.cassandra.db.marshal.UTF8Type’, ’org  .apache.cassandra.db.marshal.Int32Type’, ’org.apache.cassandra.db.
marshal.UTF8Type’]  67 \end{spverbatim}\ \newline%  68 \newline%  69 \begin{spverbatim}  70 ccm node3 stop  71 ccm node3 setdir -v 3.0  72 ccm node3 start  73 \end{spverbatim}\ \newline%  74 \newline%  75 \begin{spverbatim}  76 ccm node1 cqlsh  77 select * from system_schema.types ;  78 ccm node2 cqlsh  79 select * from system_schema.types ;  17
80 ccm node3 cqlsh  81 select * from system_schema.types ;  82 \end{spverbatim}\ \newline%  83 \newline%  84 \begin{spverbatim}  85 select * from system_schema.types ;  86  87 keyspace_name | type_name | field_names | field_types  88 ---------------+-----------+--------------------------------+-------------------------------------------  89 foo | bla | [’a’, ’b’, ’a’, ’b’, ’a’, ’b’] | [’org.apache.
cassandra.db.marshal.Int32Type’, ’org.apache.cassandra.db.marshal.
UTF8Type’, ’org.apache.cassandra.db.marshal.Int32Type’, ’org.apache.
cassandra.db.marshal.UTF8Type’, ’org.apache.cassandra.db.marshal.
Int32Type’, ’org.apache.cassandra.db.marshal.UTF8Type’]  90 \end{spverbatim}\ \newline%  91 %  92 \item%  93 \textbf{aleksey: }As Robert and I found out, the issue is that these are lists (duh  ), and we create them non{-}idempotently, even though with a deterministic  timestamp. One fix would be to switch to idempotent list entries, the other  would be to switch to frozen collections.\newline%  94 \newline%  95 Since the latter is what we’ve planned on doing all along, that’s what we are going  to do. Reassigning to Robert for now.%  96 \item%  97 \textbf{snazy: }Pushed migration to frozen collections in \{\{system\_schema\}\} to  my {[}3.0|https://github.com/snazy/cassandra/tree/6717{-}migrate{-}frozen  {-}3.0{]} and {[}trunk|https://github.com/snazy/cassandra/tree/6717{-}migrate  {-}frozen{-}trunk{]} branches.\newline%  98 {[}Cassci results|http://cassci.datastax.com/search/?q=snazy{-}6717{-}migrate{-}  frozen{-}{]} (post build \#1) should be fine.\newline%  99 %  100 \item%  101 \textbf{aleksey: }LGTM, +1%  102 \item%  103 \textbf{snazy: }Thanks. Change for system\_schema committed as  db782362aaf25214a94c393b20cdbade829c5291%  104 \item%  105 \textbf{snazy: }Ninja{-}fix for the UFPureScriptTest caused by the driver update is  here: https://gist.github.com/snazy/4c05fbd32307da68e1f6%  106 \item%  107 \textbf{aleksey: }{[}\textasciitilde{}snazy{]} go ahead%  108 \item%  109 \textbf{snazy: }fix committed as c997c08c47b049f4278a08b2d0ad9329fdf4a455%  110 \item%  111 \textbf{aholmber: }{[}\textasciitilde{}iamaleksey{]} updates for your latest  commits on 6717{-}3.0 are available on {[}python{-}drvier/276|https://github.
com/datastax/python{-}driver/tree/276{]} at db87202.%  112 \item%  113 \textbf{aleksey: }{[}\textasciitilde{}beobal{]} could you please review/commit the  changes I made in https://github.com/iamaleksey/cassandra/commits/6717{-}3.0  plus the related drivers?\newline%  114 \newline%  115 Thank you.%  116 \item%  117 \textbf{adutra: }{[}\textasciitilde{}beobal{]} updates for Aleksey’s latest commits  on 6717{-}3.0 are available {[}here|https://github.com/datastax/java{-}driver/  tree/java912{]}.%  118 \item%  119 \textbf{samt: }LGTM, there was one place that needed fixing up in \{\{  LegacySchemaMigrator::createColumnFromColumnRow\}\}, but nothing else.\newline%  120 \newline%  121 Committed to 3.0 in \{\{01f374aef59a0edde63252ffb75f40c446a0ffac\}\}, including new  versions of the bundled python \& java drivers, built from \{\{2429ba3\}\}\  newline%  122 and \{\{55db84c\}\} respectively.%  18
123 \item%  124 \textbf{aleksey: }Thank you. This leaves just one thing remaining {-} storing data  types in schema as their CQL representations instead of class names.%  125 \item%  126 \textbf{aleksey: }Pushed another two commits to the {[}6717 branch|https://github.
com/iamaleksey/cassandra/commits/6717{-}3.0{]}.\newline%  127 \newline%  128 The first one makes it so that we no longer store \{\{ReversedType\}\} in \{\{  system\_schema.columns\}\} \{\{type\}\} column. Instead, clustering order is  now a separate column {-} \{\{clustering\_order\}\} {-} \{\{asc\}\}, \{\{desc  \}\}, or \{\{none\}\} {-} for non{-}clustering columns.\newline%  129 \newline%  130 The second commit switches internal type representation everywhere to CQL names  instead of using internal class names. It also removes \{\{argument\_types\}\}  columns from both functions’ and aggregates’ tables, since that now would  completely duplicate \{\{sinature\}\} column’s content.\newline%  131 \newline%  132 Be aware that if you use UDTs anywhere, including in other UDTs’ definitions, it  will not currently work {-} I haven’t gotten to it yet. But you can create UDTs  that aren’t used, or don’t include other UDTs in them, at the moment.\newline%  133 \newline%  134 The branch is complete enough for {[}\textasciitilde{}aholmber{]} and {[}\  textasciitilde{}adutra{]} to be able to make all the necessary changes to the  python{-} and java{-}drivers while I’m finishing the work on UDTs. Just expect  some test failures where UDTs are involved, at the moment. Please treat this  with very high priority.%  135 \item%  136 \textbf{adutra: }{[}\textasciitilde{}iamaleksey{]} and {[}\textasciitilde{}beobal  {]} Updated java driver branch {[}here|https://github.com/datastax/java{-}  driver/pull/455{]}.\newline%  137 \newline%  138 Apart from UDTs not working, we are seeing a couple of errors when reading metadata  : some columns report \{\{’org.apache.cassandra.db.marshal.EmptyType’\}\} as  their CQL types (happens when reading \{\{system.IndexInfo\}\} metadata AFAICT)  .\newline%  139 \newline%  140 Also when creating dense tables, the server replies with this error:\newline%  141 \newline%  142 \begin{lstlisting}  143 java.lang.IllegalArgumentException: No enum constant org.apache.cassandra.cql3.
CQL3Type.Native.’ORG.APACHE.CASSANDRA.DB.MARSHAL.EMPTYTYPE’)",,,17:569 - 20:2355,1,arjan
26:149,aleksey,CASSANDRA-6717,aleksey,,Comment,20:2362 - 20:2368,1,arjan
26:96,"[~adutra] Force-pushed an extra commit to the same branch, added {{EMP…",CASSANDRA-6717,"[~adutra] Force-pushed an extra commit to the same branch, added {{EMPTY}}  to the enum. Can you verify if it works now? Thanks.
",,Architectural component behavior and structure,20:2371 - 20:2500,1,arjan
26:150,adutra,CASSANDRA-6717,adutra,,Comment,20:2505 - 20:2510,1,arjan
26:97,"[~iamaleksey] Unfortunately not, I’m still getting the same error. FYI…",CASSANDRA-6717,"[~iamaleksey] Unfortunately not, I’m still getting the same error. FYI the {{CRE-  ATE TABLE}} statement that fails is:  1 CREATE TABLE dense (  2 k int,  3 c int,  4 PRIMARY KEY (k, c)  5 ) WITH COMPACT STORAGE;",,Motivation of design issue,20:2513 - 20:2724,1,arjan
26:151,aleksey,CASSANDRA-6717,aleksey,,Comment,20:2731 - 20:2737,1,arjan
26:98,My bad. Didn’t override {{EmptyType::asCQL3Type}}. Should work fne now…,CASSANDRA-6717,"My bad. Didn’t override {{EmptyType::asCQL3Type}}. Should work fne now -  at least does locally for me.
",,Architectural component behavior and structure,20:2740 - 20:2844,1,arjan
26:99,[~iamaleksey] Thanks it’s working now. The [Java driver branch|https:/…,CASSANDRA-6717,"[~iamaleksey] Thanks it’s working now. The [Java driver branch|https://github.com/datastax/java-  driver/pull/455] has been updated accordingly.
",,,20:2857 - 20:3002,1,arjan
26:152,aholmber,CASSANDRA-6717,aholmber,,Comment,20:3007 - 20:3014,1,arjan
26:100,Python driver working branch [here|https://github.com/datastax/python-…,CASSANDRA-6717,"Python driver working branch [here|https://github.com/datastax/python-driver/tree/402].
",,,20:3017 - 20:3105,1,arjan
26:101,No attempt to support parsing UDTs. 19I’m a little concerned about thi…,CASSANDRA-6717,"No attempt to support parsing UDTs.
19
I’m a little concerned about this direction concerning UDTs. Parsing CQL types referring  to UDTs will require a complete view of UDTs for a keyspace. This should be attainable  by reordering metadata processing accordingly, but it feels like a fragile mechanism to me.",,"Architectural design configuration
Architectural solution benefits and drawbacks",20:3106 - 21:269,2,arjan
26:102,"With that in mind, I would prefer not to parse CQL back to CassTypes,…",CASSANDRA-6717,"With that in mind, I would prefer not to parse CQL back to CassTypes, but my hands are  tied by cqlsh, which expects column types to be modeled as complete Cassandra Types. I  would like to change cqlsh to use results metadata instead of depending on this model API,  but it’s probably not in the cards for this release.
",,Architectural design configuration,21:272 - 21:593,1,arjan
26:153,aleksey,CASSANDRA-6717,aleksey,,Comment,21:598 - 21:604,1,arjan
26:103,"Ok. The last change is not exactly trivial, and I don’t want to risk i…",CASSANDRA-6717,"Ok. The last change is not exactly trivial, and I don’t want to risk instability just  before rc1.
",,Trade-offs,21:607 - 21:706,1,arjan
26:104,[~aholmber] [~adutra] Can you create a branch that adds support for [t…,CASSANDRA-6717,"[~aholmber] [~adutra] Can you create a branch that adds support for [the frst commit|https://github.com/iamaleksey  only, for now?
If it turns out that we’ll have rc2 before 3.0.0, I’ll try to put the fnal (type serializing)  changes there, but if not, well, it’s not the end of the world.
",,,21:707 - 21:997,1,arjan
26:154,adutra,CASSANDRA-6717,adutra,,Comment,21:1003 - 21:1008,1,arjan
26:105,[~iamaleksey] I must say I share [~aholmber]’s concerns: having only t…,CASSANDRA-6717,"[~iamaleksey] I must say I share [~aholmber]’s concerns: having only the UDT  name in that column would mean that the driver would have to inspect its own metadata to  fnd its full defnition, but given that this metadata is updated asynchronously, the defnition  might or might not be found, and might or might not be stale.
",,Architectural solution benefits and drawbacks,21:1011 - 21:1336,1,arjan
26:106,"Anyway, a new java driver branch as requested can be found [here|https…",CASSANDRA-6717,"Anyway, a new java driver branch as requested can be found [here|https://github.com/datastax/java-  driver/pull/458]",,,21:1337 - 21:1452,1,arjan
26:155,samt,CASSANDRA-6717,samt,,Comment,21:1459 - 21:1462,1,arjan
26:107,+1 from me on the [clustering order commit|https://github.com/iamaleks…,CASSANDRA-6717,+1 from me on the [clustering order commit|https://github.com/iamaleksey/cassandra/commit/04d31cb5a92,,Architectural solution benefits and drawbacks,21:1465 - 21:1565,1,arjan
26:108,[~aholmber] Can you make a branch that only has support for that one c…,CASSANDRA-6717,"[~aholmber] Can you make a branch that only has support for that one commit,  without the type changes? Thanks.
",,,21:1581 - 21:1693,1,arjan
26:109,Python driver supporting clustering_order update [here|https://github.…,CASSANDRA-6717," Python driver supporting clustering_order update [here|https://github.com/datastax/python-  driver/tree/402-clustering-order].
",,,21:1707 - 21:1835,1,arjan
26:156,aholmber,CASSANDRA-6717,aholmber,,Comment,21:1840 - 21:1847,1,arjan
26:110,"I want to expound a little on my concern, which you have summarized ac…",CASSANDRA-6717," I want to expound a little on my concern, which you have summarized accu-  rately. Put another way, if we needed to parse CQL types, this would be the frst metadata  that would require a consistent view of some set of metadata, in order to correctly parse  other entities.
",,Architectural design configuration,21:1849 - 21:2123,1,arjan
26:111,"While that was my concern, I am still in favor of this new type repres…",CASSANDRA-6717,"While that was my concern, I am still in favor of this new type representation. What I  was hoping to avoid was the very need to parse it back to Cassandra Types. I *thought*  this would be necessary to support cqlsh integration, but further investigation was shown  this is not the case. Therefore, I would be changing the metadata API to model all types as  CQL strings, and there would be no need to transform to Cassandra Types in that context.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",21:2124 - 21:2573,2,arjan
26:112,"Thank you, committed as [2db8370fdff7353a8f12e75c47cc1e80eee1e9a|https…",CASSANDRA-6717,"Thank you, committed as [2db8370fdff7353a8f12e75c47cc1e80eee1e9a|https://github.com/apache/cassand  to cassandra-3.0 and merged into trunk.
I’m going to close this ticket, and move out the promised [to Tyler] bits into separate tickets  (mostly tests-related). And move out the type discussion into a new one, that we may or  may not end up doing.
",,,21:2587 - 21:2936,1,arjan
26:113,Follow up tickets: CASSANDRA-10364 and CASSANDRA-10365.,CASSANDRA-6717,"Follow up tickets: CASSANDRA-10364 and CASSANDRA-10365.
",,,21:2950 - 21:3006,1,arjan
26:114,"[~iamaleksey] for {{system_schema.indexes}} why is ""target"" a map entr…",CASSANDRA-6717,"[~iamaleksey] for {{system_schema.indexes}} why is ""target"" a map entry in  the ""options"" column instead of having a dedicated ""target"" column? Isn’t an index target  20
non-optional because an index has to index something (even if that target is something other  than a single column)?
",,,21:3020 - 22:118,1,arjan
26:157,thobbs,CASSANDRA-6717,thobbs,,Comment,22:123 - 22:128,1,arjan
26:115,Presumably that’s due to per-row secondary indexes (i.e. CASSANDRA-101…,CASSANDRA-6717,"Presumably that’s due to per-row secondary indexes (i.e. CASSANDRA-10124).
",,Architectural component behavior and structure,22:131 - 22:206,1,arjan
26:116,Thanks. That makes sense.,CASSANDRA-6717,"Thanks. That makes sense.
",,,22:220 - 22:246,1,arjan
26:158,tomas0413,CASSANDRA-6717,tomas0413,,Comment,22:251 - 22:259,1,arjan
26:117,"Hello, I raised a new bug. I think it’s related to changes moving syst…",CASSANDRA-6717,"Hello, I raised a new bug. I think it’s related to changes moving system.schema_keyspaces  to system_schema.keyspaces - CASSANDRA-10841",,"Assumptions
Motivation of design issue",22:262 - 22:396,2,arjan
27:3,Use Unsafe Mutations Where Possible in Unit Tests,CASSANDRA-6969,Use Unsafe Mutations Where Possible in Unit Tests,,Architectural component behavior and structure,3:52 - 3:100,1,arjan
27:1,"Since the test confg uses the ""batch"" mode for the commitlog, safe wri…",CASSANDRA-6969,"Since the test confg uses the ""batch"" mode for the commitlog, safe writes are quite slow.",,Run-time quality issues,3:120 - 3:208,1,arjan
27:2,"In tests  that don’t rely on safe writes, we should use unsafe writes.…",CASSANDRA-6969,"In tests  that don’t rely on safe writes, we should use unsafe writes. This mostly consists of converting  {{RowMutation.apply()}} calls into {{RowMutation.applyUnsafe()}} calls.
",,Architectural component behavior and structure,3:210 - 3:389,1,arjan
27:15,benedict,CASSANDRA-6969,benedict,,Comment,3:440 - 3:447,1,arjan
27:4,"If this is the plan, why not just convert to periodic CL?",CASSANDRA-6969,"If this is the plan, why not just convert to periodic CL?",,Architectural component behavior and structure,3:450 - 3:506,1,arjan
27:5,I thought the reason  we used Batch CL in unit tests was to give it a…,CASSANDRA-6969," I thought the reason  we used Batch CL in unit tests was to give it a bit of a run in case it happens to catch  something? (Admittedly not the most scientifc of reasons, but if we’re planning on disabling  it everywhere, it does seem like using Batch doesn’t buy us much)",,Architectural solution benefits and drawbacks,3:507 - 3:778,1,arjan
27:16,thobbs,CASSANDRA-6969,thobbs,,Comment,3:784 - 3:789,1,arjan
27:6,I’m not sure why we use batch CL for the tests.,CASSANDRA-6969, I’m not sure why we use batch CL for the tests. ,,Architectural solution benefits and drawbacks,3:791 - 3:839,1,arjan
27:7,"If you’re correct and the purpose  is to exercise batch CL, we should…",CASSANDRA-6969,"If you’re correct and the purpose  is to exercise batch CL, we should just make sure it’s properly tested elsewhere. I’d argue  that having slow unit tests is hurting our stability more than not using batch CL for unit  tests would.
",,Architectural solution benefits and drawbacks,3:840 - 3:1073,1,arjan
27:17,jbellis,CASSANDRA-6969,jbellis,,Comment,3:1077 - 3:1083,1,arjan
27:8,"That was the idea -- not many people run Batch in the wild, so let’s m…",CASSANDRA-6969,"That was the idea -- not many people run Batch in the wild, so let’s make sure it  at least gets tested in the lab.
",,Architectural solution benefits and drawbacks,3:1086 - 3:1202,1,arjan
27:9,Could we make a dtest profle using batch instead?,CASSANDRA-6969,"Could we make a dtest profle using batch instead?
",,Architectural component behavior and structure,3:1203 - 3:1253,1,arjan
27:18,jbellis,CASSANDRA-6969,jbellis,,Comment,3:1257 - 3:1263,1,arjan
27:10,"We should look at it after CASSANDRA-6968, but for now batch CL doesn’…",CASSANDRA-6969,"We should look at it after CASSANDRA-6968, but for now batch CL doesn’t look  like a big contributor to the slowness. On my machine it’s 12:25 with batch and 12:02 with  periodic.
",,,3:1266 - 3:1446,1,arjan
27:19,lyubent,CASSANDRA-6969,lyubent,,Comment,3:1450 - 3:1456,1,arjan
27:11,Attaching a patch to use unsafe mutations. To sum it up unsafe mutatio…,CASSANDRA-6969,"Attaching a patch to use unsafe mutations. To sum it up unsafe mutations were  applied to all unit tests except the 4 below (due to causing errors):  # ReadMessageTest  2
# RecoveryManagerTest  # RecoveryManager2Test  # RecoveryManager3Test",,Architectural component behavior and structure,3:1459 - 4:69,1,arjan
27:12,What improvement do you see on your box from this?,CASSANDRA-6969,"What improvement do you see on your box from this?
",,,4:84 - 4:135,1,arjan
27:13,[~jbellis] {{20 sec}} improvement when running without extra runners:…,CASSANDRA-6969, [~jbellis] {{20 sec}} improvement when running without extra runners:  pre: BUILD SUCCESSFUL Total time: 8 minutes 2 seconds  post: BUILD SUCCESSFUL Total time: 7 minutes 43 seconds  {{8 sec}} when running with 8 runners:  pre: BUILD SUCCESSFUL Total time: 3 minutes 27 seconds  post: BUILD SUCCESSFUL Total time: 3 minutes 19 seconds,,,4:147 - 4:481,1,arjan
27:20,thobbs,CASSANDRA-6969,thobbs,,Comment,4:487 - 4:492,1,arjan
27:14,+1 and committed to trunk. Thanks!,CASSANDRA-6969,"+1 and committed to trunk. Thanks!
",,Architectural solution benefits and drawbacks,4:495 - 4:529,1,arjan
28:3,Refactor and modernize the storage engine,CASSANDRA-8099,Refactor and modernize the storage engine,,Architectural design configuration,3:52 - 3:92,1,arjan
28:1,The current storage engine (which for this ticket I’ll loosely defne a…,CASSANDRA-8099,"The current storage engine (which for this ticket I’ll loosely defne as ""the code implementing the  read/write path"") is sufering from old age. One of the main problem is that the only structure  it deals with is the cell, which completely ignores the more high level CQL structure that groups  cell into (CQL) rows.
This leads to many inefciencies, like the fact that during a reads we have to group cells multiple  times (to count on replica, then to count on the coordinator, then to produce the CQL resultset)  because we forget about the grouping right away each time (so lots of useless cell names com-  parisons in particular). But outside inefciencies, having to manually recreate the CQL structure  every time we need it for something is hindering new features and makes the code more complex  that it should be.
",,Run-time quality issues,3:112 - 3:935,1,arjan
28:2,Said storage engine also has tons of technical debt. To pick an exampl…,CASSANDRA-8099,"Said storage engine also has tons of technical debt. To pick an example, the fact that during  range queries we update {{SliceQueryFilter.count}} is pretty hacky and error prone. Or the  overly complex ways {{AbstractQueryPager}} has to go into to simply ""remove the last query  result"".
",,Technical debt,3:936 - 3:1224,1,arjan
28:4,# Make the storage engine more aware of the CQL structure. In practice…,CASSANDRA-8099,"# Make the storage engine more aware of the CQL structure. In practice, instead of having  partitions be a simple iterable map of cells, it should be an iterable list of row (each being itself  composed of per-column cells, though obviously not exactly the same kind of cell we have today).
",,Architectural component behavior and structure,3:1321 - 3:1612,1,arjan
28:5,# Make the engine more iterative. What I mean here is that in the read…,CASSANDRA-8099,"# Make the engine more iterative. What I mean here is that in the read path, we end up reading  all cells in memory (we put them in a ColumnFamily object), but there is really no reason to.
",,Run-time quality issues,3:1613 - 3:1803,1,arjan
28:6,"If instead we were working with iterators all the way through, we coul…",CASSANDRA-8099,"If instead we were working with iterators all the way through, we could get to a point where  we’re basically transferring data from disk to the network, and we should be able to reduce GC  substantially.
",,"Architectural component behavior and structure
Architectural tactics",3:1804 - 3:2008,2,arjan
28:7,Please note that such refactor should provide some performance improve…,CASSANDRA-8099,"Please note that such refactor should provide some performance improvements right of the bat  but it’s not its primary goal either. Its primary goal is to simplify the storage engine and adds  abstraction that are better suited to further optimizations.
",,"Architectural solution benefits and drawbacks
Architectural tactics",3:2010 - 3:2264,2,arjan
28:8,"For information, and to hopefully clarify a bit more what I’d like to…",CASSANDRA-8099,"For information, and to hopefully clarify a bit more what I’d like to do here, I’ve  push my WIP branch for this [here|https://github.com/pcmanus/cassandra/tree/8099_engine_refactor].
It’s nowhere near complete, nothing is defnitive and it’s not even close of compiling. But it  should hopefully have enough meat already to give a sense of the direction this is taking.
",,,4:92 - 4:463,1,arjan
28:9,/cc [~jasobrown] [~xedin] [~iamaleksey] [~krummas] [~kohlisankalp] [~t…,CASSANDRA-8099,/cc [~jasobrown] [~xedin] [~iamaleksey] [~krummas] [~kohlisankalp] [~tjake],,,4:476 - 4:550,1,arjan
28:165,xedin,CASSANDRA-8099,xedin,,Comment,4:556 - 4:560,1,arjan
28:10,"_No-no-no, I think we should go all the way and re-write everything, g…",CASSANDRA-8099,"_No-no-no, I think we should go all the way and re-write everything, gives us all the benefts  in the single shot, plus who cares about supporting all the features anyway, right?_",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",4:576 - 4:754,3,arjan
28:11,"Seriously tho, this sounds like a good frst step.",CASSANDRA-8099,"Seriously tho, this sounds like a good frst step.
",,Architectural solution benefits and drawbacks,4:766 - 4:816,1,arjan
28:166,jasobrown,CASSANDRA-8099,jasobrown,,Comment,4:820 - 4:828,1,arjan
28:12,"I’m +1 on the idea. I poked through the code quickly, and it seemed in…",CASSANDRA-8099,"I’m +1 on the idea. I poked through the code quickly, and it seemed in the  right direction - although I’d have to read more carefully/think more wrt to some of my  earlier thoughts about (pluggable) storage engines. Also, I see that ’Column’ has made a  comeback :)",,Architectural solution benefits and drawbacks,4:831 - 4:1096,1,arjan
28:167,aleksey,CASSANDRA-8099,aleksey,,Comment,4:1102 - 4:1108,1,arjan
28:13,"As I’ve said before, yeah, we should do this.",CASSANDRA-8099,"As I’ve said before, yeah, we should do this.",,Architectural solution benefits and drawbacks,4:1111 - 4:1155,1,arjan
28:14,"Preferably spreading the whole thing  over 3.x series though, limiting…",CASSANDRA-8099,"Preferably spreading the whole thing  over 3.x series though, limiting the amount of per-release changes, wherever it makes sense.
",,,4:1157 - 4:1288,1,arjan
28:15,How is this looking two weeks later? Any potential blockers come up?,CASSANDRA-8099,"How is this looking two weeks later? Any potential blockers come up?
",,,4:1301 - 4:1370,1,arjan
28:16,Prettier but not really near completion I’m afraid.,CASSANDRA-8099,"Prettier but not really near completion I’m afraid.
",,,4:1427 - 4:1479,1,arjan
28:17,"Not really blockers, but I’ll admit that this is bigger/longer that I…",CASSANDRA-8099,"Not really blockers, but I’ll admit that this is bigger/longer that I though.
",,,4:1517 - 4:1595,1,arjan
28:168,slebresne,CASSANDRA-8099,slebresne,,Comment,4:1599 - 4:1607,1,arjan
28:18,As an update on this I’ve (force) pushed to [the branch|https://github…,CASSANDRA-8099,As an update on this I’ve (force) pushed to [the branch|https://github.com/pcmanus/cassandra/tree/809,,,4:1610 - 4:1710,1,arjan
28:22,"This is still not done but it compiles, run and work for basic queries…",CASSANDRA-8099,"This is still not done but it compiles, run and work for basic queries. That said, at least  reverse, distinct and 2ndary index queries (and a bunch of other smaller details) are known  not to work (but that should change relatively soon). Also, I’ll still need to work on thrift  support and general backward compatibility for rolling upgrades. Nonetheless, the general  design is here and shouldn’t change drastically. Plus it’s barely tested at this point, I need  to add more comments.
",,,4:1713 - 4:2203,1,arjan
28:21,This is a huge patch. And while this doesn’t change how Cassandra work…,CASSANDRA-8099,"This is a huge patch. And while this doesn’t change how Cassandra works in any fuda-  mental way, this can’t really be called a small incremental change. I’m the frst to admit  that those are not good things in theory, but to be honest, as this tries to clean up the  3
abstractions that are at the core of the storage engine, I don’t see how this could be done  a whole lot more incrementally.",,,4:2204 - 5:124,1,arjan
28:19,I do am convinced that this will make implementing tons  of outstandin…,CASSANDRA-8099,I do am convinced that this will make implementing tons  of outstanding features a lot more easy and is worth it just for that.,,Architectural solution benefits and drawbacks,5:126 - 5:252,1,arjan
28:20,"Anyway, that’s my  (lame) excuse for this. Also, it’s in a single big…",CASSANDRA-8099,"Anyway, that’s my  (lame) excuse for this. Also, it’s in a single big commit because I had a lot of back and forth  while implementing so that my wip commits were more misleading than anything. At at  latter point, if that’s deemed better for review, I could try to split it in smaller commits of  somewhat-related code (though I’m not entirely sure it will help tremendously).
",,,5:254 - 5:632,1,arjan
28:169,benedict,CASSANDRA-8099,benedict,,Comment,5:636 - 5:643,1,arjan
28:23,"A small thing I noticed, that this nicely helps tidy up something that…",CASSANDRA-8099,"A small thing I noticed, that this nicely helps tidy up something that’s bugged  me before and can (and should) be cleaned up with this IMO: all of the sub-comparators in  ClusteringComparator can be removed, and the class itself can simply implement Compara-  tor<Clusterable>, since all of the things that can be compared now implement Clusterable  (perhaps one sub-comparator could be used if directly comparing ClusteringPrefx is very  common in high-trafc code paths, but it’s probably not necessary).
.rowComparator can be removed already and .atomComparator can be removed by only  making MergeIterator accept <? super In> instead of <In>.
clusterableComparator would then be subsumed by the enclosing class; everywhere it’s re-  ferred to you can simply delete "".clusteringComparator"" and it will work.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:646 - 5:1459,2,arjan
28:24,"I’m sure it’s out of date now, but I’ve posted the dif anyway. The sum…",CASSANDRA-8099,"I’m sure it’s out of date now, but I’ve posted the dif anyway. The summary is:  src/java/org/apache/cassandra/db/ClusteringComparator.java  | 33 ++++++---------------------------  src/java/org/apache/cassandra/db/atoms/AtomIterators.java  | 2 +-  src/java/org/apache/cassandra/db/filters/NamesPartitionFilter.java  | 2 +-  src/java/org/apache/cassandra/db/partitions/AtomicBTreePartition.java  | 4 ++--  src/java/org/apache/cassandra/utils/MergeIterator.java  | 10 +++++-----  5 files changed, 15 insertions(+), 36 deletions(-)",,,5:1460 - 5:1986,1,arjan
28:170,benedict,CASSANDRA-8099,benedict,,Comment,5:1993 - 5:2000,1,arjan
28:25,"Also, I’m sure you’re on top of this already, but this could do with a…",CASSANDRA-8099,"Also, I’m sure you’re on top of this already, but this could do with a lot more  commenting. Little things like what is meant by a ""complex"" feld - with a bit of digging  you can determine this is related to collections, but you have to jump to declaration quite  a few times before establishing this. Simple descriptions of classes like ""ComplexCellBlock""  and what a class is used for, like in ""CellWriter"".
It would really help to reduce the mystery that has surrounded some of the internal func-  tionality. Right now I don’t think anybody is fully conversant with even the current (post  CASSANDRA-5417) functionality besides yourself",,,5:2003 - 5:2642,1,arjan
28:26,"I know this rewrite will help a lot, but  I doubt it will fx the probl…",CASSANDRA-8099,"I know this rewrite will help a lot, but  I doubt it will fx the problem entirely. There’s a lot of legacy cruft to deal with still, that  makes things complicated, and this rewrite will put almost everyone back to square one.
",,Architectural solution benefits and drawbacks,5:2645 - 5:2872,1,arjan
28:171,slebresne,CASSANDRA-8099,slebresne,,Comment,5:2877 - 5:2885,1,arjan
28:27,"I’ll incorporate that, thanks. I wanted to do it but I still had some…",CASSANDRA-8099,"I’ll incorporate that, thanks. I wanted to do it but I still had some crappy dependen-  cies in the initial versions and didn’t looked back at it after that was cleaned up.
",,Architectural solution benefits and drawbacks,5:3027 - 5:3200,1,arjan
28:28,I couldn’t agree more and plan on addressing that rather soon. My bad…,CASSANDRA-8099,"I couldn’t agree more and plan on addressing that rather soon. My bad excuse for not  doing it right away is that I had a lot of back and forth on the exact abstraction to make  everything fts and didn’t wanted to lose time commenting stufs that might go away the  next day. But I have a ""got over it all and comment the shit out of it"" task on my todo list.
",,,6:1 - 6:360,1,arjan
28:29,I think it’s a shame this patch wasn’t attempted at least a little mor…,CASSANDRA-8099,"I think it’s a shame this patch wasn’t attempted at least a little more incre-  mentally. It looks to me that changing the serialization formats, memtables and iterator  implementations could have been done in diferent patches at least, and it might have made  review safer and easier, and given us more time to digest the changes. I understand that  this might have introduced some extra development burden, although that might have been  reaped back in many fewer days spent rebasing. Having an initial patch to change the ab-  stractions I think would have helped to reduce the burden on the rest of the project, and  perhaps helped parallelize the work as well.
I’m a little concerned that the result is that we won’t give each of the pretty major de-  cisions that have been made the time they need to be assessed properly, especially now we’re  ramping up for release (and hence low on time). I’m not necessarily suggesting we split it,  as I can imagine that would be soul crushingly unpleasant for [~slebresne] and introduce a  delay, but I am generally ill at ease with the scope of the changes and our ability to vet them.
I’m also worried I’m fnding myself saying ""too close to release to question this decision"" -  which seems a problematic mode to be merging any patch under.
",,,6:375 - 6:1666,1,arjan
28:172,slebresne,CASSANDRA-8099,slebresne,,Comment,6:1671 - 6:1679,1,arjan
28:30,"I certainly understand the criticism, this is defnitively not as incre…",CASSANDRA-8099,"I certainly understand the criticism, this is defnitively not as incremental as it should be.
My lame ""defence"" is that since this structurally changes the main abstraction used by the  storage engine, it quickly trickles down to everything else, so that I just wasn’t sure how to  attack this more incrementally in practice. For the serialization formats, I could indeed have  stick to serializing to the old format, but given the mismatch between the old format and the  new abstractions, it was actually simpler to just write in a meaningful format right away (it  allowed me to get something working faster). And since the new serialization format details  are fairly well encapsulated (mostly in {{AtomSerializer.java}}), I’ll admit it didn’t felt like  a huge deal overall. But in any case, I probably haven’t tried hard enough and/or I’m not  smart enough to have fgured out how to make that happen more incrementally and for that,  I apologize.
",,,6:1775 - 6:2729,1,arjan
28:31,I agree that not questioning a decision that you think is worth questi…,CASSANDRA-8099,"I agree that not questioning a decision that you think is worth questioning should be avoided,  but I also don’t think that this needs to be the case. If you think a decision make things  worth than it is in current trunk, then by all mean, let’s bring it. If there is enough such  concerns voiced that makes us think this patch won’t be a net improvement over the status  quo and there is no time to address those concerns, then I’ll be the frst to suggest that,  as sad as that would make me, we should consider pushing it after 3.0 (but I do have the  weakness to think that the patch is a net improvement).
Now, I don’t pretend that every choice made here is absolutely optimal (I’m afraid I’m  not that smart) so there will things that can be improved (and maybe some will require sub-  sequent changes). But as long as something doesn’t make things worth than they currently  are, I’d suggest is probably ok to just create tickets for those improvements.",,,6:2829 - 6:3789,1,arjan
28:32,"After all, this  isn’t meant at all to be the defnitive version of Cas…",CASSANDRA-8099,"After all, this  isn’t meant at all to be the defnitive version of Cassandra ode, it just pretend to be cleaner  grounds to improve upon than we currently have.
",,Architectural solution benefits and drawbacks,6:3791 - 6:3952,1,arjan
28:33,"Don’t get me wrong, I’m not trying to say that such a big patch is ide…",CASSANDRA-8099,"Don’t get me wrong, I’m not trying to say that such a big patch is ideal, it’s not. I just  didn’t fgured out how to do better.
",,,7:1 - 7:129,1,arjan
28:173,slebresne,CASSANDRA-8099,slebresne,,Comment,7:134 - 7:142,1,arjan
28:34,I’ve just rebased and (force) pushed the current version of the patch…,CASSANDRA-8099, I’ve just rebased and (force) pushed the current version of the patch to [the  usual branch|https://github.com/pcmanus/cassandra/tree/8099_engine_refactor]. It still  doesn’t handle thrift and misses backward compatibility code for the internal messages (and  I’ll start working on those) but it’s basically complete otherwise. ,,Architectural design configuration,7:144 - 7:472,1,arjan
28:35,It passes all the CQL tests  (unit and dtests) we have in particular.…,CASSANDRA-8099,"It passes all the CQL tests  (unit and dtests) we have in particular. Also seems to be passing other dtests (that don’t use  thrift) but I’ll admit I haven’t had the patience to run them all locally and jenkins since to  be in a bad mood recently, so a couple might require attention but that’s likely minor. Also,  I haven’t taken the time to upgrade most of our unit tests and this will be done next with  the help of some others, but hopefully the CQL tests and dtests exercise the code changed  enough that they shouldn’t be major surprises.
",,,7:473 - 7:1019,1,arjan
28:36,Overall the missing parts are sufciently isolated that I think initial…,CASSANDRA-8099,"Overall the missing parts are sufciently isolated that I think initial review can be started.
I’ve actually written [here|https://github.com/pcmanus/cassandra/blob/8099_engine_refactor/guide_8099.md]  some kind of overview/guide for the sake of making diving into the patch easier. I’ll be happy  to update it if there is something missing that would help.
",,,7:1020 - 7:1378,1,arjan
28:174,benedict,CASSANDRA-8099,benedict,,Comment,7:1383 - 7:1390,1,arjan
28:38,"Like I said, it’s a shame; I lament not having longer to criticise the…",CASSANDRA-8099," Like I said, it’s a shame; I lament not having longer to criticise the less optimal  decisions. That’s not at all to suggest they will cumulatively sabotage this patch to worse  than the status quo. But the bar for improvement is much higher once a round of changes  goes in (not least because the efort of maintaining compatibility each time, but also because  it has to be justifed afresh, and be worth the risk, argumentation, redevelopment, etc.),  and so we will fnd ourselves settling more readily than had we considered our options more  carefully up front, especially when there are so many aspects to discuss. I don’t think there  is much to be done about it now, though, given the time constraints, and we will simply  have to do our best.
Anyway, I’ll try to properly digest the patch over the next week or so, so I can give some  actual concrete feedback.",,,7:1392 - 7:2260,1,arjan
28:37,"On the whole I _do_ think it is a huge step forward (well, per-  haps…",CASSANDRA-8099,"On the whole I _do_ think it is a huge step forward (well, per-  haps not the naming :))",,Architectural solution benefits and drawbacks,7:2262 - 7:2349,1,arjan
28:39,"I just wish we weren’t rushing this part after waiting so long for it,…",CASSANDRA-8099,"I just wish we weren’t rushing this part after waiting so long for it,  and that we had at least discussed some of the more concrete aspects of the design in advance.
The concern I have about the scope being too large to vet efectively is somewhat un-  correlated, but I don’t have a good answer for that either. My experience is that review’s  capacity for fnding problems doesn’t scale linearly with the scope and complexity of a patch,  and I don’t think we’ve ever had a patch as large as this (it’s basically a whole version jump  on its own). Of course, if you’re planing to break 3.0 just to make me feel better about  breaking 2.1, I’m cool with that :)",,,7:2352 - 7:3013,1,arjan
28:175,snazy,CASSANDRA-8099,snazy,,Comment,7:3020 - 7:3024,1,arjan
28:40,As you say in [the doc|https://issues.apache.org/jira/browse/CASSANDRA…,CASSANDRA-8099,"As you say in [the doc|https://issues.apache.org/jira/browse/CASSANDRA-8971],  naming of _atom_ is really bad and should be changed IMO. Some proposals:  * -{{Cluster}} - it’s like that - but _cluster_ is an occupied term-  * {{Line}} (slightly similar to _row_)  * {{Assembly}}  * or maybe just {{RawRow}}  {{NamesPartitionFilter}} - not sure whether _names_ is a good word here. Propose {{Clus-  teringPartitionFilter}} or {{ClusteredPartitionFilter}}",,,7:3027 - 7:3479,1,arjan
28:41,Good idea to make {{CachePartition}} an interface!,CASSANDRA-8099,"Good idea to make {{CachePartition}} an interface!
",,Architectural solution benefits and drawbacks,7:3482 - 7:3533,1,arjan
28:42,BTW: interesting to see that the term _DoppelgÃďnger_ is known in Engl…,CASSANDRA-8099,BTW: interesting to see that the term _DoppelgÃďnger_ is known in English ;),,,8:1 - 8:76,1,arjan
28:43,"I’d like Aleksey to be ""chief reviewer"" with input from (at least) Ben…",CASSANDRA-8099," I’d like Aleksey to be ""chief reviewer"" with input from (at least) Benedict and  Benjamin.
",,,8:91 - 8:183,1,arjan
28:44,"For the purposes of bug fxing and testing we ""reviewers/helpers"" shoul…",CASSANDRA-8099," For the purposes of bug fxing and testing we ""reviewers/helpers"" should submit pull  requests to Sylvain’s github branch for inclusion. With the fnal merged version of his branch  being committed.
",,,8:194 - 8:392,1,arjan
28:176,blerer,CASSANDRA-8099,blerer,,Comment,8:397 - 8:402,1,arjan
28:45,As the patch is relatively large I have choose to split my review of t…,CASSANDRA-8099,"As the patch is relatively large I have choose to split my review of the CQL layer  into chunks and give my comments for each chunk as soon as I have fnished reviewing it. I  think it will make the things more manageable for Sylvain and me.
",,,8:405 - 8:646,1,arjan
28:46,I am not a big fan of big class hierachies,CASSANDRA-8099,I am not a big fan of big class hierachies,,Architectural solution benefits and drawbacks,8:704 - 8:745,1,arjan
28:47,but I wonder if it will not be better to have  two sub-classes for {{P…,CASSANDRA-8099,"but I wonder if it will not be better to have  two sub-classes for {{PrimaryKeyRestrictionSet}} one for the partition key and one for the  clustering columns rather than having a boolean variable.
",,"Architectural design configuration
Assumptions",8:747 - 8:944,2,arjan
28:48,In {{PrimaryKeyRestrictionSet}} the method {{addColumnFilterTo}} can b…,CASSANDRA-8099,"In {{PrimaryKeyRestrictionSet}} the method {{addColumnFilterTo}} can be simplifed  based on the fact that we know if the restrictions are on the partition key components or on  the clustering key columns.
* The {{AbstractPrimaryKeyRestrictions.toByteBufers}} method can be moved down as it  is only used in {{PrimaryKeyRestrictionSet}}* In {{MultiColumnRestriction}} the method  {{isPartitionKey()}} is not used (in case you have forgotten: {{MultiColumnRestriction}}  only apply to clustering key columns).* I understand why you renamed {{?Restriction.Slice}}  to {{?Restriction.SliceRestriction}} but now the class names look a bit inconsistent. May  be we should rename the other classes too.
* In {{ColumnFilter}} the {{add(Expression expression)}} method is not used.
* In {{Operator}} the {{reverse}} method is not needed anymore and can be removed.
* In {{StatementRestrictions}} I do not understand the use of {{useFiltering}}. My under-  standing was that we should return an error message specifying that {{ALLOW FILTER-  ING}} is required and that this problem should have been handled by {{checkNeedsFilter-  ing}} in {{SelectStatement}}. Could you explain?
* In {{StatementRestrictions}} the {{nonPKRestrictedColumns}} method look wrong to  me as it can return some primary key columns.
",,,8:947 - 8:2252,1,arjan
28:177,slebresne,CASSANDRA-8099,slebresne,,Comment,8:2257 - 8:2265,1,arjan
28:49,Thanks for some initial review. I’ve pushed a commit for most of the r…,CASSANDRA-8099,"Thanks for some initial review. I’ve pushed a commit for most of the remarks.
I answer the rest below:",,,8:2268 - 8:2370,1,arjan
28:50,"I don’t disagree, but think we should generally clean the handling of…",CASSANDRA-8099,"I don’t disagree, but think we should generally clean the handling of partition keys so it  doesn’t ""pretend"" to be clustering columns (which will imply separating into 2 classes). And  so I’d like to do that properly as a followup since it’s not essential to this ticket (and I’m  sure we can agree it’s big enough as is).
",,"Architectural design configuration
Architectural solution benefits and drawbacks
Assumptions",8:2572 - 8:2896,3,arjan
28:51,If you have restriction on an indexed column but that restriction is n…,CASSANDRA-8099,"If you have restriction on an indexed column but that restriction is no ""queriable"" (not  an equality), we actually always reject the query (as in, even with {{ALLOW FILTER-  ING}}) with an error message that says we can’t fnd a usable 2ndary index. I’m not saying  7
this is a good thing, it’s really just historical and we should fx it, but this ticket is arguably  not the right place for this (CASSANDRA-4987 would typically be a better place for that).
We also don’t even call {{needsFiltering}} if the query is not a range one (because we  don’t support {{ALLOW FILTERING}} there yet, which is CASSANDRA-6377), but we  should still reject the queries desribed above (restriction on an indexed column but not one  usable by the index) for single partition queries.
Another way to put it is that the added validation is just the validation that is done on  trunk in {{SecondaryIndexManager.validateIndexSearchersForQuery}} (and so was not han-  dled by {{checkNeedsFiltering}}) which I moved in {{StatementRestrictions}} because that  was convenient for the patch. TL;DR, we should clean all this in follow-ups, but I’d rather  keep it simple for this ticket.
",,,8:3193 - 9:899,1,arjan
28:178,snazy,CASSANDRA-8099,snazy,,Comment,9:904 - 9:908,1,arjan
28:52,"Altogether I have to say, that CASSANDRA-8099 is a great step forward!…",CASSANDRA-8099,"Altogether I have to say, that CASSANDRA-8099 is a great step forward! It simplifes  a lot of areas in the code, explains a lot of things in javadoc and makes it a lot easier to  follow the travelled code path using (mostly ;) ) appropriate nomenclature.
",,Architectural solution benefits and drawbacks,9:957 - 9:1212,1,arjan
28:53,*NITs*  * {{org.apache.cassandra.db.ReadQuery}} can be an interface (o…,CASSANDRA-8099,"*NITs*  * {{org.apache.cassandra.db.ReadQuery}} can be an interface (only abstract methods) and  is mentioned as an interface in the javadoc ;)  * {{org.apache.cassandra.confg.CFMetaData#columnMetadata}} can be fnal  * {{org.apache.cassandra.confg.CFMetaData#getDefaultIndexName}}, {{#isNameValid}},  {{#isIndexNameValid}} use non-compiled regexp  I didnâĂŹt create a pull-req since all fndings above are just nits and could only make  fnal rebasing harder.
*Nomenclature*  The name {{ColumnFilter}} is a bit misleading. From the frst impression I thought itâĂŹs  a flter that flters CQL columns - but itâĂŹs used to to a 2i lookup.
Can you rename {{NamesPartitionFilter}} to something with _clustering key_ in it? I  know that the term _name_ is used elsewhere for clustering key.
{{CBuilder}}/{{MultiCBuilder}} could be more expressive as {{ClusteringBuilder}}/{{MultipleClusteringsBuilder}  *Misc*  The frst time I ran into a situation where {{cluster_name}} and {{host_id}} were null  in {{system.local}}. But had no luck reproducing this (IâĂŹm sure I did a {{ant realclean  jar}} and {{rm -rf data/*}} before). So just take this as a note - not something worth to  discuss.
I did a quick&dirty prototype of CASSANDRA-7396 based on 8099 and it looks much easier  (without the slicing stuf).
",,,9:1213 - 9:2513,1,arjan
28:54,Here is my second chunk of feedbacks on the CQL layer:  * In {{Selecti…,CASSANDRA-8099,"Here is my second chunk of feedbacks on the CQL layer:  * In {{Selection}} the method {{containsPartitionKeyColumns}} is not used.
* The class {{ReadQuery}} does not contains any implementation, so it should probably be  an interface.
8
* {{PartitionFilter}}, {{NamesPartitionFilter}} and {{SlicePartitionFilter}} contains some  commented code that should probably be removed.
* In {{NamesPartitionFilter}} and {{SlicePartitionFilter}} the {{toCQLString}} methods  contains some duplicate code for the {{ORDER BY}} that can be extracted and put in  {{AbstractPartitionFilter}} * In {{SelectStatement}}:  ** in the {{gatherQueriedColumns}} method the {{PartitionColumns.Builder.addAll}} method  could be used to simplify the code  ** in the {{process(DataIterator)}} method the {{options}} variable could be inlined  ** the method {{getSliceCommands}} should return a {{ReadQuery}} as it will help to  simplify the {{getQuery}} method  ** {{nowInSec}} should be generated in {{getQuery}} instead of being provided as argu-  ment  ** the {{logger}} variable is not used  ** I wonder if it will not be cleaner to have an empty {{ReadQuery}} than to deal with  {{null}}  * In {{BatchStatement}} {{conditionColumns}} does not seems to be read  * In {{QueryPager}}:  ** the {{pager(ReadQuery, ConsistencyLevel, ClientState)}} method is not used  ** there are some commented code with a TODO which provide no information  ** instead of using {{instanceof}} the code of {{pager(ReadQuery, ConsistencyLevel, ClientState,  boolean, PagingState)}} should probably use polymorphism",,,9:2526 - 10:1333,1,arjan
28:179,benedict,CASSANDRA-8099,benedict,,Comment,10:1340 - 10:1347,1,arjan
28:56,So I’m still trying to digest the entirety of the patch (amongst other…,CASSANDRA-8099,"So I’m still trying to digest the entirety of the patch (amongst other things), and  have been reticent to give feedback in advance of this. Since being fully conversant is likely  a way of, I fgure I should highlight earlier the biggest (labour-wise) concern I have.
",,,10:1350 - 10:1618,1,arjan
28:55,"Flyweights. They complicate the code, introducing a lot of extra imple…",CASSANDRA-8099,"Flyweights. They complicate the code, introducing a lot of extra implementations of classes.
This is both a cognitive burden, but also an issue for the optimizer. As an example, Clus-  tering looks like it could likely get away with just a single implementation, or perhaps two,  as opposed to the current eight. Since these classes are accessed _everywhere_, and often,  having efcient method despatch is important. But also classes like Sorting would be un-  necessary, and we could depend on Java sorting, and things like the RowDataBlock would  not need to have such complexity for overloading of behaviour to support both rows and  collections of rows.
The upside of the fyweights AFAICT is very slim. There is only a very tiny amount of  only temporary heap space saved, since the vast majority of the data (the ByteBufer ob-  jects) are still foating around for every value. I would be surprised if we measurably reduced  GC burden, and in fact since their lifetimes are often longer they may be promoted with  higher likelihood. Of course, I may be missing some major benefcial case that is important,  but either way I fgure we should start a discussion, sooner than later, on whether or not it  is worth retaining them in this patch. It is possible that the abstraction may be useful in  future, but I don’t think it is right now, and I would prefer to introduce it if and when we’re  confdent it will be of use, and to benchmark it independently of these other complex changes.
",,Trade-offs,10:1619 - 10:3110,1,arjan
28:180,slebresne,CASSANDRA-8099,slebresne,,Comment,10:3115 - 10:3123,1,arjan
28:57,I kind of agree. I went with them because there was a desire to use fo…,CASSANDRA-8099,"I kind of agree. I went with them because there was a desire to use for a while on  CASSANDRA-5019 and it felt that using them from day one might not be that hard. And  I kind of went with it because I wanted to fnish with the APIs and the code that use them  before thinking too much about the more internal implementations.
9
But you’re right, it does make some things more complex than they have to be, and the  gains are unclear at best (as in, it might hurt more than it helps). Hopefully though, the  APIs don’t really depend on them and so changing this shouldn’t be too hard. ",,Architectural solution benefits and drawbacks,10:3143 - 11:256,1,arjan
28:58,I want to fn-  ish the last outstanding parts: thrift (which is coming…,CASSANDRA-8099,"I want to fn-  ish the last outstanding parts: thrift (which is coming along) and read old formats, but then  I’ll have a look at removing the fyweights, at least the main ones, and simplify accordingly.
",,,11:257 - 11:461,1,arjan
28:59,"FTR, I plan to leave review of the Partition hierarchy (in particular…",CASSANDRA-8099,"FTR, I plan to leave review of the Partition hierarchy (in particular the memtable  stuf) until after that refactor, but am attempting to tackle the rest of the code in the  meantime.
As I do this, I will arrange pull requests (as I have done just now). I will only post updates  here if the pull request is in any way substantial, so that they can be discussed on the  permanent record. I think this will be more efcient than my posting suggestions/criticisms,  since you only have so much time on your hands, and this permits a degree of parallelization  that may help us reach a better end state in the time available.
",,,11:476 - 11:1099,1,arjan
28:181,tjake,CASSANDRA-8099,tjake,,Comment,11:1104 - 11:1108,1,arjan
28:60,After some time spent with the new API my biggest concern is using OpO…,CASSANDRA-8099,After some time spent with the new API my biggest concern is using OpOrder in iterators  is unsafe.,,Architectural solution benefits and drawbacks,11:1112 - 11:1210,1,arjan
28:61,To address this we talked about adding code analysis to fnd improper u…,CASSANDRA-8099,To address this we talked about adding code analysis to fnd improper use of  auto-closable,,Architectural design configuration,11:1212 - 11:1301,1,arjan
28:62,"but ideally we should replace this with something safer, like ref coun…",CASSANDRA-8099,"but ideally we should replace this with something safer, like ref counting the  op order so it will get cleaned up worst case by leak detector.
",,"Architectural design configuration
Architectural solution benefits and drawbacks",11:1304 - 11:1448,2,arjan
28:182,benedict,CASSANDRA-8099,benedict,,Comment,11:1453 - 11:1460,1,arjan
28:63,I agree with this being dangerous,CASSANDRA-8099,I agree with this being dangerous,,Architectural solution benefits and drawbacks,11:1527 - 11:1559,1,arjan
28:64,but I would prefer not to rush into using Ref. it isn’t  intended for…,CASSANDRA-8099,"but I would prefer not to rush into using Ref. it isn’t  intended for use on a critical path. We at least need to address CASSANDRA-9379, but  even then I would prefer to only use a Ref in situations where the iterator will go out  of scope. i.e. where we cannot use it in a try/fnally block. ",,Architectural solution benefits and drawbacks,11:1562 - 11:1854,1,arjan
28:65,"In this case, we can just ex-  plicitly wrap it in a Ref object, and a…",CASSANDRA-8099,"In this case, we can just ex-  plicitly wrap it in a Ref object, and always access it via the Ref, so it’s clear we’re being safe.
",,Architectural component behavior and structure,11:1855 - 11:1986,1,arjan
28:66,We should perhaps try and rustle up some static analysis to tell us wh…,CASSANDRA-8099,"We should perhaps try and rustle up some static analysis to tell us where we do not use a  try/fnally, and fail the compile if we don’t use a Ref there",,Architectural design configuration,11:1987 - 11:2137,1,arjan
28:67,If this is too difcult then I am  with [~tjake] and would prefer to er…,CASSANDRA-8099,"If this is too difcult then I am  with [~tjake] and would prefer to err on the side of caution, by introducing CASSANDRA-  9379 and always wrapping the OpOrder in a Ref.
",,Architectural design configuration,11:2140 - 11:2310,1,arjan
28:183,benedict,CASSANDRA-8099,benedict,,Comment,11:2315 - 11:2322,1,arjan
28:68,[It looks like this is easier than expected|http://help.eclipse.org/lu…,CASSANDRA-8099,"[It looks like this is easier than expected|http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.jdt  preferences-errors-warnings.htm]:  {quote}  Resource not managed via try-with-resource (1.7 or higher)  When enabled, the compiler will issue an error or a warning if a local variable holds a value  of type ’java.lang.AutoCloseable’, and if the method ’close()’ is explicitly invoked on that  resource, but the resource is not managed by a try-with-resources block.
{quote}",,Architectural solution benefits and drawbacks,11:2325 - 11:2807,1,arjan
28:184,tjake,CASSANDRA-8099,tjake,,Comment,11:2814 - 11:2818,1,arjan
28:69,"Hmm, this is eclipse only?",CASSANDRA-8099,"Hmm, this is eclipse only?
",,Architectural solution benefits and drawbacks,11:2821 - 11:2848,1,arjan
28:185,benedict,CASSANDRA-8099,benedict,,Comment,11:2853 - 11:2860,1,arjan
28:70,"Yeah. It would mean setting up ecj as another target, unfortunately, b…",CASSANDRA-8099,"Yeah. It would mean setting up ecj as another target, unfortunately, but that is  probably worth the efort.
",,Trade-offs,11:2863 - 11:2970,1,arjan
28:71,31. tjake: I see. I think [~snazy] would know how todo this from CASSA…,CASSANDRA-8099,"31. tjake: I see. I think [~snazy] would know how todo this from CASSANDRA-8241?
32. snazy: Do you think of using ecj in build.xml or in IDEA?
33. benedict: I’ve fled CASSANDRA-9431 to continue this discussion to avoid polluting this  ticket",,,11:2972 - 11:3214,1,arjan
28:186,blambov,CASSANDRA-8099,blambov,,Comment,12:5 - 12:11,1,arjan
28:74,"I doubt index update belongs here, as side efect of iteration. Ideally…",CASSANDRA-8099,"I doubt index update belongs here, as side efect of iteration. Ideally index should be col-  lected, not updated.",,Architectural solution benefits and drawbacks,12:272 - 12:384,1,arjan
28:73,Presumably mergedCell is already being added by writer,CASSANDRA-8099,Presumably mergedCell is already being added by writer,,Architectural component behavior and structure,12:386 - 12:439,1,arjan
28:72,perhaps  cleaning other entries there is a better way to go.,CASSANDRA-8099," perhaps  cleaning other entries there is a better way to go.
",,Architectural component behavior and structure,12:441 - 12:502,1,arjan
28:75,Another side efect of iteration that preferably should be handled by w…,CASSANDRA-8099,"Another side efect of iteration that preferably should be handled by writer.
",,Architectural component behavior and structure,12:612 - 12:689,1,arjan
28:76,Validation compaction now uses {{CompactionIterable}} and thus has sid…,CASSANDRA-8099,"Validation compaction now uses {{CompactionIterable}} and thus has side efects (index  & cache removal).
",,Architectural component behavior and structure,12:693 - 12:798,1,arjan
28:77,-- [CompactionManager 900|https://github.com/pcmanus/cassandra/blob/75…,CASSANDRA-8099,"-- [CompactionManager 900|https://github.com/pcmanus/cassandra/blob/75b98620e30b5df31431618cc21e090481f3  Several issues:  --* {{partition}} can be used after it is closed.
--* {{partition}} is not always closed: this closes it, but 895 and 870 don’t.
--* Why is the iterator closed here rather than in the scope that opened it?
--* Please use explicit close of {{partition}}. This is an abuse of the try syntax (not obvious  behavior, hidden from view).
-- [CompactionManager 1052|https://github.com/pcmanus/cassandra/blob/75b98620e30b5df31431618cc21e090481f  [1160|https://github.com/pcmanus/cassandra/blob/75b98620e30b5df31431618cc21e090481f33967/src/java/org/apa  Partition is not closed.
- Stuf that could be confusing:  -- In {{guide_8099}}, description of {{RangeTombstoneMarkers}}: add that there is never  content between two corresponding tombstone markers on any iterator. {{PurgingPartition-  Iterator}} for one relies on this.
-- [CompactionIterable 83|https://github.com/pcmanus/cassandra/blob/75b98620e30b5df31431618cc21e090481f339  Are we interested in highest-index nowInSec() only? Not max/min? Could you add an ex-  planation in comment if that’s the case?
-- [CompactionIterable 47|https://github.com/pcmanus/cassandra/blob/75b98620e30b5df31431618cc21e090481f339  AtomicInteger unnecessary-- remove as it could be understood to mean thread-safety where  there’s none.
-- \[Abstract]CompactionIterable are misnamed. They are now iterators.
- Nits:  -- [CompactionIterable 48|https://github.com/pcmanus/cassandra/blob/75b98620e30b5df31431618cc21e090481f339  {{format}} is never used.
-- [CompactionIterable 100|https://github.com/pcmanus/cassandra/blob/75b98620e30b5df31431618cc21e090481f33  {{column}} is not used.
-- [CompactionManager 785|https://github.com/pcmanus/cassandra/blob/75b98620e30b5df31431618cc21e090481f3  Revert Collections.singleton(sstable) to sstableSet  -- [CompactionManager 943|https://github.com/pcmanus/cassandra/blob/75b98620e30b5df31431618cc21e090481f3  Revert removal of {{break}}.
-- Imports could be cleaned.
",,,12:820 - 12:2889,1,arjan
28:78,but I have strong objections to using iterators as the representations…,CASSANDRA-8099,but I have strong objections to using iterators as the representations  of tables and partitions in the abstraction,,Architectural solution benefits and drawbacks,12:3108 - 12:3222,1,arjan
28:79,These objects should be Iterable instead. Having that would give clear…,CASSANDRA-8099,"These objects should be Iterable instead. Having that would give clear separation  between the iteration process and the entity-level data and behaviour which is currently a  11
cause of multiple problems, including the top two categories above.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",12:3375 - 13:69,2,arjan
28:80,I also think {{OpOrder.Group.close()}} does not belong in an iterator…,CASSANDRA-8099,I also think {{OpOrder.Group.close()}} does not belong in an iterator close.,,Architectural solution benefits and drawbacks,13:70 - 13:145,1,arjan
28:81,"To minimize  the potential for trouble, grouping/locking should be exp…",CASSANDRA-8099,"To minimize  the potential for trouble, grouping/locking should be explicit in the user of the iterator/en-  tity. For the instances where this is not feasible, perhaps the initiating methods could be  called ""openX"" or ""startX"" vs ""X"" (e.g. openSearch vs search).
",,"Architectural design configuration
Architectural solution benefits and drawbacks",13:147 - 13:412,2,arjan
28:187,benedict,CASSANDRA-8099,benedict,,Comment,13:417 - 13:424,1,arjan
28:82,This issue is actually much more problematic than I had realised. Ther…,CASSANDRA-8099,"This issue is actually much more problematic than I had realised. There are at least two  places in the code already where we explicitly hold onto the OpOrder across operations of  indeterminate length (disk IO, or peer query responses). During 2i rebuild we (I am told)  also hold onto it for the entire duration of a single partition. During a normal read request,  if we time out, as far as I can tell we don’t even close the Iterator (so we already have a  serious bug).
",,Motivation of design issue,13:505 - 13:980,1,arjan
28:83,OpOrder is explicitly not designed for any of these scenarios. Even wi…,CASSANDRA-8099,"OpOrder is explicitly not designed for any of these scenarios. Even without the bug, this  can cause the entire cluster to lock up for a period because one node is down (and hasn’t  yet been marked such), or for a node to lock itself up because of either low disk throughput,  or one of a rash of bugs we have had recently with tombstone bookkeeping causing heavy  CPU consumption, for instance.
As such I am now totally -1 on leaving OpOrder inside the iterator. ",,Architectural solution benefits and drawbacks,13:981 - 13:1445,1,arjan
28:84,Before 3.0 we need  to ensure that we eagerly copy any contents we req…,CASSANDRA-8099,"Before 3.0 we need  to ensure that we eagerly copy any contents we require from the memtable.
",,Architectural design configuration,13:1446 - 13:1540,1,arjan
28:188,benedict,CASSANDRA-8099,benedict,,Comment,13:1545 - 13:1552,1,arjan
28:85,# In the case of a single data request (and it being local): immediate…,CASSANDRA-8099,"# In the case of a single data request (and it being local): immediately transform to the  resultset, and store the digest for corroboration;  # In the case of a read-repair (or other multiple data requests), delay performing the local  read operation until the remote replies have already arrived. This may marginally increase  latency, but only on an uncommon codepath.
",,Architectural component behavior and structure,13:1634 - 13:2006,1,arjan
28:86,"This may marginally increase  latency, but only on an uncommon codepat…",CASSANDRA-8099,"This may marginally increase  latency, but only on an uncommon codepath.",,Architectural solution benefits and drawbacks,13:1933 - 13:2004,1,arjan
28:189,blerer,CASSANDRA-8099,blerer,,Comment,13:2011 - 13:2016,1,arjan
28:87,Reviewed paging (except for the secondary index). It looks good to me.,CASSANDRA-8099,"Reviewed paging (except for the secondary index). It looks good to me.
",,Architectural solution benefits and drawbacks,13:2019 - 13:2089,1,arjan
28:88,"Just for the record, there is a bug with paging on secondary index que…",CASSANDRA-8099,"Just for the record, there is a bug with paging on secondary index queries, for which  I have a patch. I’ll make sure the relevant tests are all passing and submit a PR before the  end of the week.
",,,13:2101 - 13:2299,1,arjan
28:190,aleksey,CASSANDRA-8099,aleksey,,Comment,13:2304 - 13:2310,1,arjan
28:89,"Higher level API for Thrift, coordination, counters, read commands is…",CASSANDRA-8099,"Higher level API for Thrift, coordination, counters, read commands is go from me  for the purposes of committing this to trunk (OpOrder issues, already mentioned elsewhere,  aside).
",,Architectural solution benefits and drawbacks,13:2313 - 13:2495,1,arjan
28:91,"Will open separate tickets for minor issues, and for the pony lambda/s…",CASSANDRA-8099,"Will open separate tickets for minor issues, and for the pony lambda/streams proposal.
",,,13:2496 - 13:2583,1,arjan
28:90,"Otherwise consider it a high-level +1-ish, and I suggest committing th…",CASSANDRA-8099,"Otherwise consider it a high-level +1-ish, and I suggest committing this to trunk as soon as  backward compatibility code is done (without closing the ticket itself just yet).
",,Architectural solution benefits and drawbacks,13:2584 - 13:2760,1,arjan
28:92,"Haven’t looked deeply at schema/metadata changes, however, for CASSAND…",CASSANDRA-8099,"Haven’t looked deeply at schema/metadata changes, however, for CASSANDRA-  6717 reasons.",,,13:2774 - 13:2861,1,arjan
28:191,benedict,CASSANDRA-8099,benedict,,Comment,13:2868 - 13:2875,1,arjan
28:93,I’ve pushed a small semantic-changing suggestion for serialization and…,CASSANDRA-8099,I’ve pushed a small semantic-changing suggestion for serialization and merging  of RTs [here|https://github.com/belliottsmith/cassandra/tree/8099-RTMarker],,,13:2878 - 13:3032,1,arjan
28:95,I’m happy to split this (and further changes) out into a separate tick…,CASSANDRA-8099,"I’m happy to split this (and further changes) out into a separate ticket, but while this does  12
cross the threshold for discussion/mention, it’s actually a pretty small/contained change.
",,,13:3035 - 14:92,1,arjan
28:94,"Basically, on a RT boundary, instead of issuing a close _and_ open mar…",CASSANDRA-8099,"Basically, on a RT boundary, instead of issuing a close _and_ open marker, we just is-  sue the new open marker - both during merge and serialization. On read, encountering an  open marker when we _already_ have one open for that iterator is treated is a close/open  pair. This both reduces storage on disk, especially for large records (where RT markers  are both more frequent and, obviously, larger), but also gets rid of the UnflteredRowItera-  tors.MergedUnfltered ugliness.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",14:93 - 14:573,2,arjan
28:192,slebresne,CASSANDRA-8099,slebresne,,Comment,14:578 - 14:586,1,arjan
28:96,Some update on this. I’ve pushed a rebased (and squashed because that…,CASSANDRA-8099,"Some update on this. I’ve pushed a rebased (and squashed because that made it  a *lot* easier to rebase) version in [my 8099 branch|https://github.com/pcmanus/cassandra/tree/8099].
",,,14:589 - 14:770,1,arjan
28:97,It’s still missing wire backward compatibility ([~thobbs] is fnishing…,CASSANDRA-8099,"It’s still missing wire backward compatibility ([~thobbs] is fnishing this so this should be  ready hopefully soon). Regarding tests:  * unit tests are almost green: mostly it remains some failures in the hadoop tests. I could  actually use the experience of someone that knows these tests and the code involved as it’s  not immediately clear to me what this is even doing.
* dtests still have a fair amount of failure but I’ve only look at them recently and it’s getting  down quickly.
",,,14:771 - 14:1259,1,arjan
28:98,I think the main problem was that a local read (done through {{SP.Loca…,CASSANDRA-8099,"I think the main problem was that a local read (done through {{SP.LocalReadRunnable}})  was potentially keeping a group ""open"" while waiting on other nodes. I also realized this  path meant local reads (the actual read of sstables) were done outside of the {{Storage-  Proxy} methods, and so 1) not on the thread they were supposed to be on and 2) outside of  the ""timeout"" check. I changed this so that a local response actually materialize everything  upfront (similarly to what we do today), solving the problems above. This is not perfect and  I’m sure we’ll improve on this in the future, but that feels like a good enough option initially.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",14:1273 - 14:1919,2,arjan
28:99,"Regarding moving {{OpOrder}} out of {{close}}, the only way to do that…",CASSANDRA-8099,"Regarding moving {{OpOrder}} out of {{close}}, the only way to do that I can see is be to  move it up the stack, in {{ReadCommandVerbHandler}} and {{SP.LocalReadRunnable}}  (as suggested by Brananir above). I’m working on that (I just started and might not have  the time to fnish today, but it’ll be done early monday for sure).
",,Architectural component behavior and structure,14:1920 - 14:2250,1,arjan
28:100,"Though I don’t disagree on principle, this is not diferent from how it…",CASSANDRA-8099,"Though I don’t disagree on principle, this is not diferent from how it’s done currently  (it’s done the same in {{LazilyCompactRow}}, but it just happens that the old {{Lazily-  CompactedRow}} has been merged to {{CompactionIterable}} (now {{CompactionItera-  tor}}) because simplifcations of the patch made it unnecessary to have separate classes).
",,Architectural solution benefits and drawbacks,14:2577 - 14:2927,1,arjan
28:101,"Maybe, but it’s not that simple. Merging (which is done directly by th…",CASSANDRA-8099,"Maybe, but it’s not that simple. Merging (which is done directly by the {{Compaction-  Iterator}}) gets rid of empty partitions and more generally we get rid of them as soon as  13
possible. I think that it’s the right thing to do as it’s easier for the rest of the code, but that  means we have to do invalidation in {{CompactionIterator}}. Of course, we could special  case {{CompactionIterator}} to not remove empty partitions and do cache invalidation ex-  ternally, but I’m not sure it would be cleaner overall (it would somewhat more error-prone).
Besides, I could argue that cache invalidation is very much a product of compaction and  having it in {{CompactionIterator}} is not that bad.
",,Trade-offs,14:3240 - 15:517,1,arjan
28:102,"I’ve fxed that but I’ll note for posterity that as far as I can tell,…",CASSANDRA-8099,"I’ve fxed that but I’ll note for posterity that as far as I can tell, index removal is done  for validation compaction on trunk (and all previous version) due to the use of {{Lazily-  CompactedRow}}. I’ve still disabled it (for anything that wasn’t a true compaction) because  I think that’s the right thing to do, but that’s a diference of this ticket.
",,Architectural solution benefits and drawbacks,15:624 - 15:978,1,arjan
28:103,"Yes, it would be cleaner from that standpoint. And the use of iterator…",CASSANDRA-8099,"Yes, it would be cleaner from that standpoint. And the use of iterators in the frst place is  indeed largely carried from the existing code, I just hadn’t really though of the alternative  tbh. I’ll try to check next week how easily such change is. That said, I’m not sure the use of  iterators directly is that confusing either, so if it turns hairy, I don’t think it’s worth blocking  on this (that is, we can very well change that later).
",,Architectural solution benefits and drawbacks,15:1501 - 15:1943,1,arjan
28:193,slebresne,CASSANDRA-8099,slebresne,,Comment,15:1948 - 15:1956,1,arjan
28:104,Thanks. I hesitated doing this initially and don’t remember why I didn…,CASSANDRA-8099,Thanks. I hesitated doing this initially and don’t remember why I didn’t. But this does  clean up things a bit,,Architectural solution benefits and drawbacks,15:2052 - 15:2161,1,arjan
28:194,benedict,CASSANDRA-8099,benedict,,Comment,15:2279 - 15:2286,1,arjan
28:105,"It does change the semantics quite a bit, since the state needed for i…",CASSANDRA-8099,"It does change the semantics quite a bit, since the state needed for iterating must be con-  structed again each time, and is likely constructed in the caller of .iterator(). This has both  advantages and disadvantages. One advantage of an Iterator, though, is that you cannot  (easily) iterate over its contents twice. I’m personally not so upset at the use of Iterator,  since it’s a continuation of the existing approach, and Java 8 makes working with iterators a  little easier.",,Architectural solution benefits and drawbacks,15:2736 - 15:3217,1,arjan
28:106,"We can, for instance, make use of the forEachRemaining() method",CASSANDRA-8099,"We can, for instance, make use of the forEachRemaining() method",,Architectural component behavior and structure,15:3219 - 15:3281,1,arjan
28:107,or otherwise  transform the iterator.,CASSANDRA-8099,or otherwise  transform the iterator.,,Architectural component behavior and structure,15:3284 - 15:3320,1,arjan
28:108,I don’t think there’s any increased ugliness inherent in exposing the…,CASSANDRA-8099,"I don’t think there’s any increased ugliness inherent in exposing the  higher-level information in the Iterator, though.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",15:3322 - 15:3443,3,arjan
28:109,I believe [~iamaleksey] is working on a way to integrate the Java Stre…,CASSANDRA-8099,"I believe [~iamaleksey] is working on a way to integrate the Java Streams API at some  point in the future, which may lead to other benefts that Iterable cannot deliver.
",,Architectural design configuration,15:3444 - 15:3614,1,arjan
28:110,"Either way, I think getting this ticket in sooner than later is better…",CASSANDRA-8099,"Either way, I think getting this ticket in sooner than later is better, and we can focus on  how we might make the Iterator abstraction a little nicer in a follow up.
",,,16:1 - 16:168,1,arjan
28:195,blambov,CASSANDRA-8099,blambov,,Comment,16:173 - 16:179,1,arjan
28:111,"The changes look good,",CASSANDRA-8099,"The changes look good,",,Architectural solution benefits and drawbacks,16:182 - 16:203,1,arjan
28:112,I accept that clarifying the side efects and switching to  Iterable is…,CASSANDRA-8099,"I accept that clarifying the side efects and switching to  Iterable is not something that needs to be taken care of as part of this ticket.
On the range tombstones doc, I’m sorry, I totally failed to explain what I had in mind.
I was looking for a statement in {{### Dealing with tombstones and shadowed cells}}  that says an open marker is immediately followed by the corresponding close marker. This  is a simple and easy to check statement which is equivalent to having both ""does not shadow  its own data"" (pt 1) and ""there is at most one active tombstone at any point"" (pt 4).
However, to clarify this I went and looked further into how tombstones work in the new code  and after looking at it I do not think the merging code could work correctly. To make certain I  wrote a [partition merge test|https://github.com/apache/cassandra/commit/36709f4f8f81125def076c91ac8dfae2fdf7  The test results are very broken, for example:  1 Merging  2 6<=[34] <8 8 19<=[99] <=36 40 47 50<[56] <66 67 68 72<=[26] <=73 89<=[97]  <972<=[66] <19 19 34<=[58] <=35 36 40<[94] <41 42<[26] <=48 55<=[35] <=57 58 83  885 8 19 31<=[49] <=31 37<=[70] <=44 46<[79] <55 65 72<[57] <85 92<[45] <93 93  results in  3 2<=[66] <19 19<=[99] <=36 37<=[70] 40<[94] 41<=[70] 41<=[70] 44<=[26] 44<=[26]  46<[79] 55<=[56] 55<=[56] <66 67 68 72<=[26] 72<[57  4 ] <85 88 89<=[97] <97java.lang.AssertionError: 40<[94] follows another open marker  37<=[70]  5 java.lang.AssertionError: Duplicate marker 41<=[70]  6 java.lang.AssertionError: Deletion time mismatch for position 44 expected:<  deletedAt=70, localDeletion=70> but was:<deletedAt=26, localDeletion=26>  1 Merging  2 4 6 13<=[62] <=26 34<=[89] <=34 47 48<[99] <52 54<=[37] <=57 78<[6] <=83 85  88<=[34] <910 20 33<=[58] <=33 37<=[84] <40 52 57 77 77 88<[14] <91 92<[15]  <961 8 31 41<[17] <43 62<=[25] <=67 85 87 88 92 97results in  3 0 1 4 6 8 13<=[62] <=26 31 33<=[58] <=33 34<=[89] <=34 37<=[84] <40 41<[17] <43 47  48<[99] <52 52 54<=[37] <=57 62<=[25] <=67 77 77 78<[6] <=83 87 88<=[34] <91  4 <91 92 92<[15] <96 97java.lang.AssertionError: <91 should be preceded by open  marker, found <91  5 java.lang.AssertionError: Deletion time mismatch for open 88<=[34] and close <91  expected:<deletedAt=34, localDeletion=34> but was:<deletedAt=14, localDeletion  =14>  (where {{x>\[z\]}} means tombstone open marker at {{x}} with time {{z}} and {{<y}}  stands for close marker at {{y}}).
This is also broken with Benedict’s implicit close markers, and his patch is not sufcient  to fx it. The test does not even go far enough, as it does not include rows that are within  the span of a tombstone but newer (as far as I can tell such a row should expand into three  Unfltered’s: a close marker, row with deletion time, and open marker).
Am I somehow completely misunderstanding or missing some assumptions about the way  tombstone ranges are supposed to work? Is there something very wrong in the way I’m doing  this test?
",,,16:205 - 16:3157,2,arjan
28:196,slebresne,CASSANDRA-8099,slebresne,,Comment,17:5 - 17:13,1,arjan
28:114,I’ll look more closely at your test and fx any brokenness: it does see…,CASSANDRA-8099,"I’ll look more closely at your test and fx any brokenness: it does seem the  results are not what they are supposed to be.
",,,17:16 - 17:139,1,arjan
28:113,"For the record however, I’ll note that it’s not true that ""an open mar…",CASSANDRA-8099,"For the record however, I’ll note that it’s not true that ""an open marker is immediately  followed by the corresponding close marker"", there can be some rows between an open and  a close marker. However, the guarantee that iterators should provide is that those rows  between an open and close marker are not deleted by the range tombstone (this doesn’t  make the tests result above any more right, but wanted to clarify).
",,Existing system architecture description,17:140 - 17:563,1,arjan
28:115,It would be great to have this clarifcation in the doc. This is a poin…,CASSANDRA-8099,"It would be great to have this clarifcation in the doc. This is a point that I was miss-  ing; I will post a new version of the test that takes this into account.
",,,17:886 - 17:1049,1,arjan
28:197,blambov,CASSANDRA-8099,blambov,,Comment,17:1054 - 17:1060,1,arjan
28:117,I pushed the updated test in [this branch|https://github.com/pcmanus/c…,CASSANDRA-8099,"I pushed the updated test in [this branch|https://github.com/pcmanus/cassandra/compare/8099...blamb  tombstone#dif-4a40432057755a558fb22339cec9b266], adding a test of more that one merge  iteration. The branch also includes Benedict’s implicit close markers patch and [a small  fx|https://github.com/pcmanus/cassandra/compare/8099...blambov:8099-tombstone#dif-4a40432057755a558fb22  that makes it pass most of the validation. ",,,17:1063 - 17:1488,1,arjan
28:116,"One problem left is that the merge produces du-  plicate open markers,…",CASSANDRA-8099,"One problem left is that the merge produces du-  plicate open markers, which with the right interpretation could be acceptable after a single  step, but will cause problems after multiple compaction iterations.
",,Motivation of design issue,17:1489 - 17:1700,1,arjan
28:198,slebresne,CASSANDRA-8099,slebresne,,Comment,17:1705 - 17:1713,1,arjan
28:118,"As shown by Branimir’s test, range tombstone merging was indeed broken…",CASSANDRA-8099,"As shown by Branimir’s test, range tombstone merging was indeed broken and  I’ve pushed the fx for that. I’ve included the old version test in question (with some ugly  modifcation so it tests the reverse case), but I’ll look at updating it for the more generic  version unless you want to have a shot at it.
",,,17:1716 - 17:2025,1,arjan
28:119,"Yes, sorry about that. I’ve tried to clarify and add to the comment in…",CASSANDRA-8099,"Yes, sorry about that. I’ve tried to clarify and add to the comment in the code to start  with. I’ll update the ""guide"" to make that clearer when I have a bit more time.
",,,17:2087 - 17:2257,1,arjan
28:120,The problem is reverse queries: we need to be able to merge iterator i…,CASSANDRA-8099,"The problem is reverse queries: we need to be able to merge iterator in reverse order. And if  we re-use a ""start"" marker as ""updates"" of the deletion, we won’t know when reversed and we  see a ""start"" marker if that’s a real start or an update. Plus we do need both deletion time at  a range boundary (the one of the range we left for reverse queries, and the one of the range  we enter for forward ones). In all fairness though, I did had forgotten to actually handle  the reverse case in the merger, so I’ve fxed that, but said fx is trivial in the current approach.
",,Architectural design configuration,17:2449 - 17:3019,1,arjan
28:121,"Now, there is obviously possible alternatives for dealing with RTs, bu…",CASSANDRA-8099,"Now, there is obviously possible alternatives for dealing with RTs, but I feel that the current  approach has a bunch of good properties:  # it’s a simple model: every RT has a begining followed by an end and that’s it (no over-  lapping, no inclusions of ranges, very predictible).
# it works in both forward and reverse order, and in an obvious way.
16
# it makes the purging of gcable RTs trivial (you just blindly collect any gcable marker).
This is something that was broken by the alternative patch in particular and would require  some care.
# it reuse slice bounds without adding a new concept, which is nice I think.
So while other options are up for discussions, I think there is enough parameters to consider  that I’d prefer such potential discussion to happen in a separate ticket.
",,Architectural solution benefits and drawbacks,17:3020 - 18:444,1,arjan
28:122,"I’ll note that the ""re-imaging"" of markers at the beginning of index b…",CASSANDRA-8099,"I’ll note that the ""re-imaging"" of markers at the beginning of index blocks is actually not  necessary and something I forgot to remove. We now store in each index block if there is  an open marker at the end of that block (primary so that we can decide if a sstable don’t  have any data for a given slice just from the index) making this redundant. So I’ve removed it.
",,Architectural component behavior and structure,18:445 - 18:815,1,arjan
28:123,"Lastly, I fully agree that {{UnflteredRowIterators.MergedUnfltered}} i…",CASSANDRA-8099,"Lastly, I fully agree that {{UnflteredRowIterators.MergedUnfltered}} is ugly and I meant  it as a simple temporary solution:",,Architectural solution benefits and drawbacks,18:816 - 18:939,1,arjan
28:124,I’m sure we can fnd cleaner alternatives (maybe through  some modifcat…,CASSANDRA-8099," I’m sure we can fnd cleaner alternatives (maybe through  some modifcation of the MergeIterator API so it’s easy to produce more than one result for  a given key).
",,"Architectural design configuration
Architectural solution benefits and drawbacks",18:940 - 18:1104,2,arjan
28:199,benedict,CASSANDRA-8099,benedict,,Comment,18:1109 - 18:1116,1,arjan
28:125,Do we have test coverage of these? I didn’t notice them breaking :(,CASSANDRA-8099,Do we have test coverage of these? I didn’t notice them breaking :(,,,18:1302 - 18:1368,1,arjan
28:127,"From a nomenclature standpoint, I would like to suggest we relabel the…",CASSANDRA-8099,"From a nomenclature standpoint, I would like to suggest we relabel the marker types to  (something like) {{UPPER/LOWER}}, so that _internally_ we can refer to either as an  open marker without confusion. Right now, the concept is blurred, because we treat close  markers as open markers when operating in reverse, and IMO this hinders clarity.
",,,18:1371 - 18:1715,1,arjan
28:126,However to improve the ugliness of {{MergedUnfltered}} and remove the…,CASSANDRA-8099,"However to improve the ugliness of {{MergedUnfltered}} and remove the double persis-  tence, why not introduce a special kind of RTM, of type {{BOUNDARY}}, which just has  two timestamps. That’s basically what the {{MergedUnfltered}} is, so why not save space  and improve clarity by promoting it to a frst class concept? Unpicking them at merge when  performing GC shouldn’t be onerous.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",18:1809 - 18:2197,2,arjan
28:128,I’m dubious about introducing more method calls to be invoked on every…,CASSANDRA-8099,"I’m dubious about introducing more method calls to be invoked on every Cell, to permit the  rare case of two atoms after one merge result. That’s a code complexity and execution cost  incurred for the uncommon case, but paid by all.
",,Architectural solution benefits and drawbacks,18:2198 - 18:2431,1,arjan
28:200,slebresne,CASSANDRA-8099,slebresne,,Comment,18:2436 - 18:2444,1,arjan
28:129,"Because that doesn’t really ft the part about reusing ""slice bounds wi…",CASSANDRA-8099,"Because that doesn’t really ft the part about reusing ""slice bounds without adding a new  concept"".",,Architectural solution benefits and drawbacks,18:2510 - 18:2608,1,arjan
28:130,"A RT is a slice of deletion, and I think that’s rather clean.",CASSANDRA-8099,"A RT is a slice of deletion, and I think that’s rather clean. ",,"Architectural solution benefits and drawbacks
Assumptions",18:2610 - 18:2671,2,arjan
28:131,"I strongly suspect that  either not reusing slice for RTs, adding a {{…",CASSANDRA-8099,"I strongly suspect that  either not reusing slice for RTs, adding a {{BOUNDARY}} concept to {{Slice.BOUND}}  (which doesn’t really make sense for slices per-se), or some other hack to work around this  will make things more confusing/complex, and is thus not worth a minor optimization of  a probably pretty rare situation in practice. Feel free to give the changes a shot though if  you’re convinced otherwise, and we can have a more informed discussion on the result.
",,"Architectural solution benefits and drawbacks
Assumptions",18:2672 - 18:3142,2,arjan
28:132,We have generally poor coverage of range tombstone usage (though I’ve…,CASSANDRA-8099,"We have generally poor coverage of range tombstone usage (though I’ve modifed Branamir’s  test to test the reverse case too, so we have one test for that now at least). We have some  basic tests, but nothing fancy enough. I’ve created CASSANDRA-9617 to improve this.
",,,18:3183 - 18:3450,1,arjan
28:133,"We can, though due to the point above that means also renaming it for…",CASSANDRA-8099,"We can, though due to the point above that means also renaming it for slices in general.
Which is not crazy per-se in that we do scan slices from end to start for reverse queries so  they are equivalent in that respect, it’s just that it’s a departure of the existing nomenclature  (which I don’t personally mind).
",,,19:94 - 19:410,1,arjan
28:201,blambov,CASSANDRA-8099,blambov,,Comment,19:415 - 19:421,1,arjan
28:135,Pushed [updated test|https://github.com/pcmanus/cassandra/compare/8099…,CASSANDRA-8099,"Pushed [updated test|https://github.com/pcmanus/cassandra/compare/8099...blambov:8099-  fx]. The code is much better now, the equivalence test passes even for larger tests.",,,19:424 - 19:595,2,arjan
28:134,"There’s  one more problem to fx, though, it generates invalid empty ra…",CASSANDRA-8099,"There’s  one more problem to fx, though, it generates invalid empty ranges violating the ordering of  the iterator, for example:  1 Seed 10  2 Merging  3 14<=[8] <15[8] 23 46 56<=[93] <69[93] 80 81 88<=[70] <90[70] 90 93<=[72] <=95[72]  9710 12 33 37<=[71] <39[71] 39<=[8] <=44[8] 55<[14] <=57[14] 68 92<=[45]  <98[45] 98<=[80] <=98[80] 992 8 24 33<=[7] <45[7] 51 62 63 63 79<=[71] <=79[71]  81<=[16] <=81[16]results in  4 2 8 10 12 14<=[8] <15[8] 23 24 33<=[7] 33 <37[7] 37<=[71] <39[71] 39<=[7] <39[7]  39<=[8] <=44[8] 44<[7  5 ] <45[7] 46 51 55<[14] <56[14] 56<=[93] 68 <69[93] 79<=[71] <=79[71] 80 81<=[16]  <=81[16] 88<=[70] <90[70] 90 92<=[45] <93[45] 93<=[72] <=95[72] 95<[45] <98[45]  98<=[80] <=98[80] 99java.lang.AssertionError: 39<=[7] not ordered before  <39[7]",,Motivation of design issue,19:597 - 19:1369,1,arjan
28:202,blambov,CASSANDRA-8099,blambov,,Comment,19:1376 - 19:1382,1,arjan
28:136,"Thinking about this a bit more, I see that this is very difcult to fx.…",CASSANDRA-8099,"Thinking about this a bit more, I see that this is very difcult to fx. When  the reducer issues a pair one of the markers is out of its place in the stream, thus we would  need to delay the stream to be able to place it correctly. This would have a non-trivial  performance impact.
",,Motivation of design issue,19:1385 - 19:1667,1,arjan
28:137,"Instead, I think we should ofcially permit this kind of disorder (e.g.…",CASSANDRA-8099,"Instead, I think we should ofcially permit this kind of disorder (e.g. {{<39\[71\] 39<=\[7\]  <39\[7\] 39<=\[8\]}} from above where {{39<=\[7\] <39\[7\]}} is invalid and covered by  the outer pair of markers) in the unfltered stream and remove the invalid ranges in the com-  paction writer. The merge algorithm is able to deal with such ranges correctly and fltering  just removes them. We have to document it well and make sure the relevant code is tested  with examples of this.
",,"Architectural component behavior and structure
Assumptions",19:1668 - 19:2150,2,arjan
28:203,slebresne,CASSANDRA-8099,slebresne,,Comment,19:2413 - 19:2421,1,arjan
28:138,"However, allowing such disorder ""of-  cially"" crosses the boundaries o…",CASSANDRA-8099,"However, allowing such disorder ""of-  cially"" crosses the boundaries of my comfort zone, even if it could work as of the current code.
",,Architectural solution benefits and drawbacks,19:2466 - 19:2601,1,arjan
28:139,"So I’m starting to warm up to the idea of introducing new ""boundary"" t…",CASSANDRA-8099,"So I’m starting to warm up to the idea of introducing new ""boundary"" types of marker  (which we’ll need 2 of: excl_close-incl_open and incl_close-excl_close). Provided we make  sure iterators *must* use those boundary when appropriate, I think we dodge that problem.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Assumptions",19:2602 - 19:2869,3,arjan
28:140,It will complicate things somewhat but giving the other benefts discus…,CASSANDRA-8099,"It will complicate things somewhat but giving the other benefts discussed above, maybe  that’s the better solution.
",,Trade-offs,19:2870 - 19:2986,1,arjan
28:141,"Continuing my review with the {{db.flter}} package, apart from {{Colum…",CASSANDRA-8099,"Continuing my review with the {{db.flter}} package, apart from {{Column-  Filter.Expression.Serializer.serializedSize}} which appears to be missing a byte when the  messaging version is 3.0, I see no correctness problems with the code. More unit testing  would defnitely help, though. Below are some suggestions that should not be treated as  blocking commit.
18
{{PartitionFilter}}:  * The name implies it is something that flters partitions, in fact it applies to rows within  partition. I’d rename this to {{RowFilter}} or, if there’s a reason to keep partition in its  name, {{PartitionContentFilter}}.
* {{forPaging}} javadoc is contradictory-- on one hand strictly after, on the other could be  inclusive. Please clarify.
* {{flter(UnflteredRowIterator)}} is risky, people will call the wrong flter overload by mis-  take. Rename?
* {{flter(SliceableUnflteredRowIterator)}} does not seem to apply {{queriedColumns}} in  either {{NamesPartitionFilter}} or {{SlicePartitionFilter}}. Is this on purpose? If it is, the  method above is not its counterpart. Please document.
{{NamesPartitionFilter}}:  * {{clusterings}} should be {{NavigableSet}} to enable reverse traversal without duplication  ({{TreeSet}} implements that too). This simplifes other code in fle.
* {{toString}} misses a closing bracket.
{{SliceableUnflteredRowIterator}}:  * JavaDoc: what is ’seekTo’? ’slice’?
{{ColumnSubselection}}:  * ELT_SELECTION is not easily decipherable. Why not just ELEMENT instead? And  ’element’ elsewhere? (elt also)  {{ColumnSelection}}:  * {{includes/newTester}}: It appears these should only be called if the columns flter is al-  ready applied. This is not obvious; I’d state it in JavaDoc and/or assert that {{columns.contains(cell.column())}}.
{{DataLimits}}:  * {{DISTINCT_NONE}} is not the same as {{CQLLimits.distinct(MAX_VALUE)}}. Would  you add a comment to say why it is so?
* {{countCells}} should be {{countsCells}}.
* {{CQLLimits.isDistinct}} does not appear to be used for anything.
Throughout, there are lots of easy-to-fx (just add <?>) raw type warnings. I would also use  a virtual method instead of an instance feld for {{kind}} everywhere, as done in {{Column-  Subselection}}.
",,,19:3000 - 20:1849,1,arjan
28:142,[Here|https://github.com/pcmanus/cassandra/compare/8099...blambov:8099…,CASSANDRA-8099,[Here|https://github.com/pcmanus/cassandra/compare/8099...blambov:8099-db-flter-suggestions]  I’ve uploaded a branch that includes fxes to a few of the above.,,,20:1850 - 20:2007,1,arjan
28:143,"fyi, this change is included in CASSANDRA-9471, along with the necessa…",CASSANDRA-8099,"fyi, this change is included in CASSANDRA-9471, along with the necessary propagation  of the type change outwards. No harm in doing it in advance of that, but it can also be left  until then.
",,,20:2180 - 20:2372,1,arjan
28:144,57. benedict: [~slebresne]: what’s the state of play with the refactor…,CASSANDRA-8099,"57. benedict: [~slebresne]: what’s the state of play with the refactor work? Is it being done  in the near future? Trying to fgure out if/when I should start making pull requests for the  new memtable hierarchy.
(If it isn’t in progress, I’ll see about starting the refactor myself and having you vet it  instead)  19
58. slebresne: I’ve started it and plan on focusing on it more exclusively this week. I’ll add  that I’m quite keen on fnishing giving it this frst short myself.
59. benedict: That’s all I needed to hear. Thanks",,,20:2373 - 21:212,1,arjan
28:204,slebresne,CASSANDRA-8099,slebresne,,Comment,21:220 - 21:228,1,arjan
28:147,I’ve force-pushed a rebased version of the branch (still [here|https:/…,CASSANDRA-8099, I’ve force-pushed a rebased version of the branch (still [here|https://github.com/pcmanus/cassandra/tre,,,21:230 - 21:333,1,arjan
28:146,"Since my last update, on top of a number of fxes, I’ve fnished moved t…",CASSANDRA-8099,"Since my last update, on top of a number of fxes, I’ve fnished moved the {{OpOrder}} out  of the iterators close and I’ve update the range tombstone code to used specifc boundaries  marker as discussed above (I’ve also included Branamir’s branch with it’s ""nits"" and fxed  most others). I haven’t had the time to upgrade Branamir’s test however and so for the  sake of compilation I’ve currently removed it. If you could have a look at rebasing you test  [~blambov], that would be very greatly appreciated as you’re more familiar with it.
",,Architectural design configuration,21:336 - 21:875,1,arjan
28:148,"There is still a number of work to be done on this ticket, but the bul…",CASSANDRA-8099,"There is still a number of work to be done on this ticket, but the bulk of it is reason-  ably stable, and outside of some of the backward compatibility code the branch is generally  functional. And we’re starting to have tickets that are based on this and are ready (or almost  are), tickets that won’t be impacted too much by the remaining parts of this (which include  the refactoring of the fyweight-based implementation that I’m going to focus on now, the  wire backward compatibility code Tyler is working on and some general testing/bug fxing).
So, based on some ofine discussion, I suggest committing the current branch to trunk.
I won’t close this ticket just yet and continue fxing the remaining things, but it’ll allow  other tickets to synchronize on this and will generally help get more eyes on this by necessity.
And I’m planning to commit this tomorrow-ish (my european tomorrow), so if you have  a strong objection to this (again, we’re not closing the ticket and committing it don’t mean  it can’t change), please speak quickly.
",,,21:876 - 21:1926,1,arjan
28:149,"So as mentioned yesterday, I’ve merged the current branch on trunk, so…",CASSANDRA-8099,"So as mentioned yesterday, I’ve merged the current branch on trunk, so further  development will happen there.
",,,21:1942 - 21:2053,1,arjan
28:150,{quote}  {{PartitionFilter}}:  * The name implies it is something that…,CASSANDRA-8099,"{quote}  {{PartitionFilter}}:  * The name implies it is something that flters partitions, in fact it applies to rows within  partition. I’d rename this to {{RowFilter}} or, if there’s a reason to keep partition in its  name, {{PartitionContentFilter}}.
{quote}  I agree that the naming ain’t perfect here. And it’s a bit more messy than that, in the  sense that the current {{ColumnFilter}} really also flter rows and should be called {{Row-  Filter}}, the diference of the {{PartitionFilter}} being that it’s the part of the fltering that  can be handled by the  ""clustering index"". Anyway, I’ve cleaned this up through the follow renames:  # {{PartitionFilter}} to {{ClusteringIndexFilter}}: I’m sure there is other option here, and  if someone has a strong preference for an alternative I’m happy to discuss it, but I think it  captures pretty well the point of the class.
# {{ColumnFilter}} to {{RowFilter}}, as this the closest thing we have a general flter on  rows.
# {{ColumnSelection}} to {{ColumnFilter}}, since after all, that is our true flter on  columns.
I think this is a lot more consistent and precise.
",,,21:2054 - 21:3178,1,arjan
28:205,blambov,CASSANDRA-8099,blambov,,Comment,21:3183 - 21:3189,1,arjan
28:151,The rebased test is [here|https://github.com/blambov/cassandra/tree/80…,CASSANDRA-8099,"The rebased test is [here|https://github.com/blambov/cassandra/tree/8099-merge-  test]. The test does not fag the disorder/duplication problem, but I’m afraid we still have  20
it (see {{testDuplicateRangeCase}}).
",,,21:3192 - 22:38,2,arjan
28:152,"We need a bit more work to fully fx it, by making complementing open/c…",CASSANDRA-8099,"We need a bit more work to fully fx it, by making complementing open/close/boundary  markers equal rather than ordered and making sure there’s only one present in each stream.
",,Architectural component behavior and structure,22:39 - 22:215,1,arjan
28:153,I intend to take care of this in one of the next couple of days.,CASSANDRA-8099,"I intend to take care of this in one of the next couple of days.
",,,22:216 - 22:280,1,arjan
28:154,"I was already partly making that, but for some reason I hadn’t made al…",CASSANDRA-8099,"I was already partly making that, but for some reason I hadn’t made all the bounds that  should be equal, actually equal. But then changing the last bits was actually reasonably sim-  ple so I took the liberty to take a quick shot at it (hopefully you haven’t started working on  it yourself yet). The result is [here|https://github.com/pcmanus/cassandra/commits/8099-  RT-fx] and it actually somewhat simplify the merging. I’ve included your test on the branch  and re-enabled the assertion that was failing and {{testDuplicateRangeCase}} passes but I  noticed 2 things with that test:  # it actually generate somewhat invalid inputs in that it can generate duplicate rows. That  is, the frst ""order violation"" assumption of {{verifyValid}} should really use a strict inequal-  ity, but this currently break due to rows (doesn’t invalidate the testing of range tombstones,  but would be nice to fx it since the tests is more of a general merge test).
# {{testInvalidRangeInput}} fails but that seems expected to me. I suppose the test is  meant to check {{verifyValid}} does what it should?
",,,22:434 - 22:1527,1,arjan
28:206,blambov,CASSANDRA-8099,blambov,,Comment,22:1532 - 22:1538,1,arjan
28:155,"Excellent, the problem is now solved.",CASSANDRA-8099,"Excellent, the problem is now solved.",,Architectural solution benefits and drawbacks,22:1541 - 22:1577,1,arjan
28:156,Update of the test that removes the no  longer necessary {{testInvalid…,CASSANDRA-8099,"Update of the test that removes the no  longer necessary {{testInvalidRangeInput}}, avoids duplicate rows and checks strict inequal-  ity is uploaded [here|https://github.com/blambov/cassandra/tree/8099-RT-fx], rebased on  trunk.
65. slebresne: [~blambov] I was about to commit the patch with your test, but it seems the  last commit (the one with the test) include a number of unrelated changes (probably from  rebase), and I’m not entirely comfortable committing those parts.
66. blambov: Sorry, these changes were indeed wrong. Uploaded fx to the same [branch|https://github.com/blambov/c  RT-fx].
67. slebresne: Thanks for the update [~blambov]. Since we’re good on that I’ve committed it  to trunk, but from now on I’ll stick to opening subtasks for things related to this ticket (but  will keep this open until we’re done with all the subtasks).
68. tzach: looks like this change undoes the fx for CASSANDRA-4858.Is this correct? inten-  tional?
69. slebresne: It is certainly not the intention to undo CASSANDRA-4858, but I could use  some more details on why you think this has been undone. A priori the code from that  ticket, which basically merge ranges that can be merged together, is still there in {{Stor-  ageProxy.RangeMerger}}. So did you experimentally noticed that this wasn’t working as  intended anymore? And if so, can you share your experiment?
",,,22:1579 - 22:2952,2,arjan
28:158,"70. tzach: Thanks Sylvain, I missed that. 71. rustyrazorblade: Is ther…",CASSANDRA-8099,"70. tzach: Thanks Sylvain, I missed that.
71. rustyrazorblade: Is there a spec, written in a single location, that describes the layout of  the new sstable structure? Currently it feels like you have to jump between quite a few fles  to determine how everything laid out.
I’ve seen the guide here: https://github.com/apache/cassandra/blob/trunk/guide_8099.md#storage-  format-on-disk-and-on-wire but it doesn’t address at a byte level how things are stored.
21
It doesn’t have to be as intense as http://nmap.org/book/images/hdr/MJB-TCP-Header-  800x564.png but I think to allow other people to make meaningful contributions it would be  nice to have a doc describing things.
72. pierz: Yes it would be great to have a full specifcation now cassandra has a new sstable  format.
73. jbellis: That’s on Sylvain’s list when he gets back in two weeks.
74. aleksey: The code’s been in for a while now, and many of the issues have been resolved as  separate tickets. Some issues and optimizations haven been fles as separate tickets, but not  resolved yet.
",,,22:2953 - 23:594,1,arjan
28:207,aleksey,CASSANDRA-8099,aleksey,,Comment,23:395 - 23:401,1,arjan
28:160,"As far as this parent ticket goes, with CASSANDRA-9704 inclusion, +1 f…",CASSANDRA-8099,"As far as this parent ticket goes, with CASSANDRA-9704 inclusion, +1 from me.
",,Architectural solution benefits and drawbacks,23:595 - 23:673,1,arjan
28:161,75. rajath26: Is there any specifcation online with a detailed descrip…,CASSANDRA-8099,"75. rajath26: Is there any specifcation online with a detailed description of the new SSTable  format byte by byte ? It would be really useful. Right now, it seems like multiple fles have  to be gone through to completely understand the new format.
76. slebresne: bq. Is there any specifcation online with a detailed description of the new  SSTable format byte by byte ?
There isn’t, and as much as I would be the frst to love seeing that exist, I doubt I’ll  fnd the time to provide it myself any time soon. Of course, it’s open source, so anyone with  some free time and willingness could use the code to kick-start such documentation on the  wiki. Which would be very much appreciated.
",,,23:674 - 23:1365,1,arjan
28:208,tsteinmaurer,CASSANDRA-8099,tsteinmaurer,,Comment,23:1370 - 23:1381,1,arjan
28:162,Are there any benchmarks V2.1 vs. V3.0 focusing on GC (object churn)?…,CASSANDRA-8099,"Are there any benchmarks V2.1 vs. V3.0 focusing on GC (object churn)?
In our 9 node loadtest environment, after upgrading from 2.1.18 to 3.0.14, same load, same  infrastructure, same heap sizing etc., *GC suspension has doubled* (+ correlating CPU in-  crease). According to JFR, allocation rate top class is {{org.apache.cassandra.utils.btree.BTreeSearchIterator}},  especially in context of compactions, e.g. for {{Rows.collectStats}}.
Checked out the code and I see e.g. commits 2457599427d361314dce4833abeb5cd4915d0b06  (some simplifcations) and also 639d4b240c084900b6589222a0984babfc1890b1 (switch to BTree).
While the storage engine might now be more modern and code being most likely easier  to read, we got a really bad initial impression when switching from 2.1.18. It would be great if  someone can share benchmarks focusing GC/CPU or if https://issues.apache.org/jira/browse/CASSANDRA-  13900 gets proper attention. Thanks a lot.
",,Run-time quality issues,23:1384 - 23:2329,1,arjan
28:209,tjake,CASSANDRA-8099,tjake,,Comment,23:2334 - 23:2338,1,arjan
28:163,[~tsteinmaurer] A number of GC problems were addressed in CASSANDRA-12…,CASSANDRA-8099,[~tsteinmaurer] A number of GC problems were addressed in CASSANDRA-12269,,Run-time quality issues,23:2341 - 23:2413,1,arjan
28:210,tsteinmaurer,CASSANDRA-8099,tsteinmaurer,,Comment,23:2420 - 23:2431,1,arjan
28:164,"[~tjake], thanks. Sounds exactly what we are facing with 3.0.",CASSANDRA-8099,"[~tjake], thanks. Sounds exactly what we are facing with 3.0.
",,Run-time quality issues,23:2434 - 23:2496,1,arjan
29:3,Schema Improvements,CASSANDRA-9424,Schema Improvements,,Architectural component behavior and structure,3:52 - 3:70,1,arjan
29:1,C* schema code is both more brittle and less efcient than I’d like it…,CASSANDRA-9424,C* schema code is both more brittle and less efcient than I’d like it to be. ,,Run-time quality issues,3:90 - 3:166,1,arjan
29:2,This ticket will  aggregate the improvement tickets to go into 3.X and…,CASSANDRA-9424,"This ticket will  aggregate the improvement tickets to go into 3.X and 4.X to improve the situation.
",,,3:167 - 3:268,1,arjan
29:12,sebastian.estevez@datastax.com,CASSANDRA-9424,sebastian.estevez@datastax.com,,Comment,3:352 - 3:381,1,arjan
29:4,Can we make it so this includes changing to a more  strongly consisten…,CASSANDRA-9424,"Can we make it so this includes changing to a more  strongly consistent schema (maybe using cas)? This would be to avoid back to back create  statements from generating the exact same table with two cf id’s when the schema hasn’t  settled.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",3:384 - 3:624,2,arjan
29:13,aleksey,CASSANDRA-9424,aleksey,,Comment,3:628 - 3:634,1,arjan
29:5,"Yes, that’s the plan. There are per-requisites to be satisfed frst, ho…",CASSANDRA-9424,"Yes, that’s the plan. There are per-requisites to be satisfed frst, however.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",3:881 - 3:958,2,arjan
29:14,yukim,CASSANDRA-9424,yukim,,Comment,3:962 - 3:966,1,arjan
29:6,"Is it possible to make ofcial way(API) to load schema ofine? That is,…",CASSANDRA-9424,"Is it possible to make ofcial way(API) to load schema ofine? That is, the ability to read  schema from stored SSTables without waking up unnecessary server components.
",,Architectural design configuration,3:1005 - 3:1173,1,arjan
29:7,"Right now, {{Schema#loadFromDisk(false)}} is used across ofine tools,…",CASSANDRA-9424,"Right now, {{Schema#loadFromDisk(false)}} is used across ofine tools, but due to the  way it touches things, it creates Memtable, CommitLog, some Executors, etc, etc.
Most of the tools just need to get {{CFMetaData}} to open SSTables.
",,Run-time quality issues,3:1174 - 3:1410,1,arjan
29:15,slebresne,CASSANDRA-9424,slebresne,,Comment,4:4 - 4:12,1,arjan
29:8,I agree we should get this ultimately.,CASSANDRA-9424,I agree we should get this ultimately.,,Architectural solution benefits and drawbacks,4:191 - 4:228,1,arjan
29:9,What I’d suggest is to serialize the schema as a  sstable metadata com…,CASSANDRA-9424,"What I’d suggest is to serialize the schema as a  sstable metadata component (only the table the sstable is of of course). This would be  useful for ofine tools, but I’ve wanted that for debugging more than once too.",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",4:230 - 4:445,2,arjan
29:10,"Bumping to fx version 4.x, as 3.11.0 is a bug-fx only release. ref htt…",CASSANDRA-9424,"Bumping to fx version 4.x, as 3.11.0 is a bug-fx only release.
ref https://s.apache.org/EHBy",,,4:501 - 4:593,1,arjan
30:2,Improve Hinted Handof,CASSANDRA-9427,Improve Hinted Handof,,Architectural design configuration,3:52 - 3:72,1,arjan
30:1,There are multiple issues with the way we currently handle hints. Havi…,CASSANDRA-9427,"There are multiple issues with the way we currently handle hints. Having them saved in a regular  Cassandra table, and implementing the queue anti-pattern, is just one of them.
",,Run-time quality issues,3:92 - 3:269,1,arjan
30:3,This ticket will aggregate the planned improvements for 3.X.,CASSANDRA-9427,This ticket will aggregate the planned improvements for 3.X.,,,3:270 - 3:329,1,arjan
31:10,jbellis,CASSANDRA-3671,jbellis,,Comment,3:636 - 3:642,1,arjan
31:1,Would this be a good place to start using the Coda Metrics library?,CASSANDRA-3671,"Would this be a good place to start using the Coda Metrics library?
",,Architectural design configuration,3:645 - 3:713,1,arjan
31:11,scode,CASSANDRA-3671,scode,,Comment,3:717 - 3:721,1,arjan
31:2,"Yes, probably.",CASSANDRA-3671,"Yes, probably.
",,"Architectural solution benefits and drawbacks
Assumptions",3:724 - 3:739,2,arjan
31:3,"So here’s the deal: Other than running into CASSANDRA-3797, there is t…",CASSANDRA-3671,"So here’s the deal: Other than running into CASSANDRA-3797, there is the problem that  we cannot have both the Coda Metrics and our own MBean:s publish under the same class  name (StorageProxy in this case).",,Architectural solution benefits and drawbacks,3:740 - 3:946,1,arjan
31:4,"I considered various options, and decided to at least submit for consi…",CASSANDRA-3671,"I considered various options, and decided to at least submit for consideration something  that might be controversial:",,Architectural solution benefits and drawbacks,4:1 - 4:118,1,arjan
31:5,"I have created an org.apache.cassandra.metrics package, con-  taining…",CASSANDRA-3671,"I have created an org.apache.cassandra.metrics package, con-  taining a ClientRequestMetrics class which has these metrics. The idea is that if we are  going to need to adjust naming conventions anyway, let’s move to a naming convention  which makes sense to the user/system administrator, rather than the implementor (""Stor-  ageProxy"" means very little to most people who don’t know the code, I would suspect).
",,Architectural component behavior and structure,4:120 - 4:533,1,arjan
31:6,"It does create a split-world syndrome of ""new style"" vs. ""old style"" m…",CASSANDRA-3671,"It does create a split-world syndrome of ""new style"" vs. ""old style"" metrics though. I’d  love input.
",,Architectural solution benefits and drawbacks,4:534 - 4:636,1,arjan
31:12,scode,CASSANDRA-3671,scode,,Comment,4:879 - 4:883,1,arjan
31:7,We could also convert everything in StorageProxy to metrics and leave…,CASSANDRA-3671,"We could also convert everything in StorageProxy to metrics and leave naming  unaltered, assuming metrics can express everything we currently have in the MBean, which  I’m skeptical of. Haven’t checked, but other than data types like arrays, we provide methods  for invocation which is not a metric at all.
",,Architectural component behavior and structure,4:886 - 4:1193,1,arjan
31:13,brandon.williams,CASSANDRA-3671,brandon.williams,,Comment,4:1280 - 4:1295,1,arjan
31:8,"I’m +1 on this approach, because we need to keep things backwards-comp…",CASSANDRA-3671,"I’m +1 on this approach, because we need to keep things backwards-compatible for ex-  isting monitoring solutions, but ultimately I’m unhappy with the current state of JMX and  starting fresh like you have here is a good way to solve it. Fleshing out o.a.c.metrics looks  like the future to me.
",,Architectural solution benefits and drawbacks,4:1405 - 4:1700,1,arjan
31:14,urandom,CASSANDRA-3671,urandom,,Comment,4:2349 - 4:2355,1,arjan
31:9,"Otherwise, +1 from me.",CASSANDRA-3671,"Otherwise, +1 from me.
",,Architectural solution benefits and drawbacks,5:125 - 5:148,1,arjan
48:1,Store types by their CQL names in schema tables instead of fully-quali…,CASSANDRA-10365,Store types by their CQL names in schema tables instead of fully-qualifed internal class names,,Architectural component behavior and structure,3:53 - 3:146,1,arjan
48:2,"Consider saving CQL types names for column, UDF/UDA arguments and retu…",CASSANDRA-10365,"Consider saving CQL types names for column, UDF/UDA arguments and return types, and UDT  components.
",,Architectural component behavior and structure,3:166 - 3:267,1,arjan
48:155,snazy,CASSANDRA-10365,snazy,,Comment,3:399 - 3:403,1,arjan
48:3,"I’d appreciate this very much as we ""convert"" a lot between CQL types…",CASSANDRA-10365," I’d appreciate this very much as we ""convert"" a lot between CQL types and _Ab-  stractType_.
IMO we have to do this anyway in the (more or less) near future - and this (as schema tables  are changed for 3.0) is a good chance to do it.
",,Architectural solution benefits and drawbacks,3:405 - 3:642,1,arjan
48:4,"As soon as AbstractType is no longer used in the schema tables, we are…",CASSANDRA-10365,"As soon as AbstractType is no longer used in the schema tables, we are free to ""streamline""  the code and remove AbstractType completely (as soon as Thrift is gone).
",,Architectural design configuration,3:643 - 3:809,1,arjan
48:154,aholmber,CASSANDRA-10365,aholmber,,Comment,3:813 - 3:820,1,arjan
48:5,I think this would be a welcome improvement to the metadata model,CASSANDRA-10365, I think this would be a welcome improvement to the metadata model,,"Architectural solution benefits and drawbacks
Assumptions",3:822 - 3:887,2,arjan
48:6,"Would  be interested in getting it in ahead of 3.0 GA, as it may warra…",CASSANDRA-10365,"Would  be interested in getting it in ahead of 3.0 GA, as it may warrant metadata API changes in  the driver release.
",,Architectural design configuration,3:890 - 3:1008,1,arjan
48:153,avalanche123,CASSANDRA-10365,avalanche123,,Comment,3:1012 - 3:1023,1,arjan
48:7,I think this is a very useful metadata to include.,CASSANDRA-10365, I think this is a very useful metadata to include.,,"Architectural solution benefits and drawbacks
Assumptions",3:1025 - 3:1075,2,arjan
48:8,My only suggestion is to  keep the old representation (fqcn) as well.,CASSANDRA-10365,My only suggestion is to  keep the old representation (fqcn) as well.,,Architectural design configuration,3:1077 - 3:1145,1,arjan
48:9,Currently drivers use this representation to detect  type information.…,CASSANDRA-10365,"Currently drivers use this representation to detect  type information. Parsing CQL-only representation might not be robust for the reasons men-  tioned in https://issues.apache.org/jira/browse/CASSANDRA-6717#comment-14791788.
",,Architectural solution benefits and drawbacks,3:1147 - 3:1373,1,arjan
48:152,snazy,CASSANDRA-10365,snazy,,Comment,4:4 - 4:8,1,arjan
48:10,"if I got your point, you suspect that UDT and UDF/UDA depen-  dencies…",CASSANDRA-10365," if I got your point, you suspect that UDT and UDF/UDA depen-  dencies might cause problems resolving dependencies (and thus resulting in unresolved/stale  types/UDAs), right?",,"Architectural component behavior and structure
Assumptions",4:26 - 4:200,2,arjan
48:11,IMO this (having unresolvable types/UDFs/UDAs) is not related to  whet…,CASSANDRA-10365," IMO this (having unresolvable types/UDFs/UDAs) is not related to  whether type information is stored using class names or CQL type signatures.
",,"Architectural component behavior and structure
Assumptions",4:201 - 4:345,2,arjan
48:12,"Generally, the situation is the same for the drivers and for C* intern…",CASSANDRA-10365,"Generally, the situation is the same for the drivers and for C* internally. AFAIR [~aholm-  ber]’s point was about parsing CQL types *back* to class-names (_AbstractType_).
",,Architectural component behavior and structure,4:346 - 4:519,1,arjan
48:13,"Of course, this change is not a trivial thing - neither for C* nor for…",CASSANDRA-10365,"Of course, this change is not a trivial thing - neither for C* nor for the drivers.
",,Architectural solution benefits and drawbacks,4:520 - 4:604,1,arjan
48:151,avalanche123,CASSANDRA-10365,avalanche123,,Comment,4:718 - 4:729,1,arjan
48:14,"Just to clarify, the issue is that when we see a ""org.apache.cassandra…",CASSANDRA-10365," Just to clarify, the issue is that when we see a ""org.apache.cassandra.db.marshal.UserType"",  it contains all information about its felds. Whereas when reading users.address, we will have  to lookup the defnition of that UDT separately, which may or may not be present in the  driver’s schema metadata. This might complicate the process of constructing schema meta-  data, especially considering that we still have to support previous versions of Cassandra that  used fqcn style types",,Technical debt,4:731 - 4:1215,1,arjan
48:15,I think it is doable,CASSANDRA-10365,I think it is doable,,"Architectural solution benefits and drawbacks
Assumptions",4:1218 - 4:1237,2,arjan
48:16,"if keeping both is possible,",CASSANDRA-10365,"if keeping both is possible,",,Architectural component behavior and structure,4:1244 - 4:1271,1,arjan
48:17,it’d make the driver  upgrades that much easier.,CASSANDRA-10365,"it’d make the driver  upgrades that much easier.
",,Architectural solution benefits and drawbacks,4:1273 - 4:1322,1,arjan
48:150,slebresne,CASSANDRA-10365,slebresne,,Comment,4:1326 - 4:1334,1,arjan
48:18,"I certainly understand that argument, but the fully-qualifed class nam…",CASSANDRA-10365,"I certainly understand that argument, but the fully-qualifed class names are also leaking  implementation details, namely which concrete classes are used server side. On the long  term, removing that leakage is probably a good idea and might allow some cleanups of type  classes at some point, and since we’ve redone the whole schema table, that sounds like a good  time to do so. So while I understand this is a bit more work for the drivers",,Architectural solution benefits and drawbacks,4:1446 - 4:1887,1,arjan
48:19,"mostly, you’d  have to either make sure you’re up-to-date on types bef…",CASSANDRA-10365,"mostly, you’d  have to either make sure you’re up-to-date on types before querying columns, or resolve the  types you don’t know about by querying afterwards",,Architectural component behavior and structure,4:1890 - 4:2046,1,arjan
48:20,I do feel that not conserving the fqcn  version in new tables is the r…,CASSANDRA-10365,"I do feel that not conserving the fqcn  version in new tables is the right thing to do.
",,Architectural solution benefits and drawbacks,4:2050 - 4:2138,1,arjan
48:149,aholmber,CASSANDRA-10365,aholmber,,Comment,4:2142 - 4:2149,1,arjan
48:21,"If the concern is about leaking implementation details,",CASSANDRA-10365,"If the concern is about leaking implementation details, ",,Architectural solution benefits and drawbacks,4:2152 - 4:2207,1,arjan
48:22,would it be reasonable  to instead store User Types as fully-specifed…,CASSANDRA-10365,would it be reasonable  to instead store User Types as fully-specifed abstract types as we do in the results encoding?,,"Architectural component behavior and structure
Assumptions",4:2208 - 4:2325,2,arjan
48:23,"I know this is not CQL, but it would avoid having to resolve inner typ…",CASSANDRA-10365,"I know this is not CQL, but it would avoid having to resolve inner types.
",,Architectural solution benefits and drawbacks,4:2414 - 4:2488,1,arjan
48:148,aleksey,CASSANDRA-10365,aleksey,,Comment,4:2493 - 4:2499,1,arjan
48:24,Repeated each time for each use of the UT everywhere?,CASSANDRA-10365,"Repeated each time for each use of the UT everywhere?
",,"Architectural component behavior and structure
Assumptions",4:2682 - 4:2736,2,arjan
48:147,aholmber,CASSANDRA-10365,aholmber,,Comment,4:2741 - 4:2748,1,arjan
48:25,"That was the thought, yes.",CASSANDRA-10365,"That was the thought, yes.",,Architectural component behavior and structure,4:2810 - 4:2835,1,arjan
48:26,From your response I gather that this suggestion does not  suit the in…,CASSANDRA-10365,"From your response I gather that this suggestion does not  suit the intent of the ticket. I’m not familiar with all the touch points, but I was hoping it  wouldn’t be much harder to maintain than the current cassandra type string, which fully  specifes the type. For example:  1 org.apache.cassandra.db.marshal.UserType(test,74797031,7630:org.apache.cassandra.db  .marshal.Int32Type,7631:org.apache.cassandra.db.marshal.UserType(test  ,74797030,7630:org.apache.cassandra.db.marshal.Int32Type,7631:org.apache.
cassandra.db.marshal.Int32Type))",,Architectural solution benefits and drawbacks,4:2837 - 4:3378,1,arjan
48:28,"I was wondering aloud if we could abstract that, but still have the ty…",CASSANDRA-10365,"I was wondering aloud if we could abstract that, but still have the type fully-specifed in place.
",,"Architectural component behavior and structure
Assumptions",5:1 - 5:99,2,arjan
48:27,The most obvious downside is that there would then be yet another stri…,CASSANDRA-10365,"The most obvious downside is that there would then be yet another string representation of  types.
",,Architectural solution benefits and drawbacks,5:100 - 5:199,1,arjan
48:146,aholmber,CASSANDRA-10365,aholmber,,Comment,5:204 - 5:211,1,arjan
48:29,"To be clear, I was thinking this would still be side-by-side with the…",CASSANDRA-10365,"To be clear, I was thinking this would still be side-by-side with the pure cql  representation",,Architectural design configuration,5:214 - 5:307,1,arjan
48:30,so hopefully the goal of server-side simplifcation could still be atta…,CASSANDRA-10365,so hopefully the goal of server-side simplifcation could still be attained. (?),,Architectural solution benefits and drawbacks,5:310 - 5:388,1,arjan
48:145,jorgebg,CASSANDRA-10365,jorgebg,,Comment,5:395 - 5:401,1,arjan
48:31,"I agree: if the goal is to hide implementation details,",CASSANDRA-10365,"I agree: if the goal is to hide implementation details,",,Architectural solution benefits and drawbacks,5:404 - 5:458,1,arjan
48:144,slebresne,CASSANDRA-10365,slebresne,,Comment,5:599 - 5:607,1,arjan
48:32,"It’s a goal, but avoiding too much unnecessary repeti-  tions is also…",CASSANDRA-10365,"It’s a goal, but avoiding too much unnecessary repeti-  tions is also a goal. Of course, not making too hard on client implementors is also a goal.
",,Architectural solution benefits and drawbacks,5:692 - 5:839,1,arjan
48:33,"That said, I’m still wondering what is so hard about resolving UDTs",CASSANDRA-10365,"That said, I’m still wondering what is so hard about resolving UDTs",,"Architectural solution benefits and drawbacks
Assumptions",5:841 - 5:907,2,arjan
48:34,"If you’re going to read  the columns defnition,",CASSANDRA-10365,"If you’re going to read  the columns defnition,",,Architectural component behavior and structure,5:910 - 5:956,1,arjan
48:35,what’s so hard about reading the type defnitions frst?,CASSANDRA-10365,what’s so hard about reading the type defnitions frst?,,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",5:958 - 5:1011,2,arjan
48:36,I understand  it’s slightly less convenient but coming up with a new a…,CASSANDRA-10365, I understand  it’s slightly less convenient but coming up with a new ad hoc notation just for that isn’t  terribly clean imo. ,,Architectural solution benefits and drawbacks,5:1012 - 5:1138,1,arjan
48:143,aholmber,CASSANDRA-10365,aholmber,,Comment,5:1200 - 5:1207,1,arjan
48:37,No one said hiding implementation was the only goal. I was simply addr…,CASSANDRA-10365,"No one said hiding implementation was the only goal. I was simply addressing  that point.
",,Architectural solution benefits and drawbacks,5:1210 - 5:1300,1,arjan
48:38,"My concern is that this changes the meta-  data model, possibly requir…",CASSANDRA-10365,"My concern is that this changes the meta-  data model, possibly requiring a complete view of all UDTs for resolving types in other  artifacts. It *should* be fne,",,Architectural solution benefits and drawbacks,5:1465 - 5:1626,1,arjan
48:39,but I think it makes the metadata model more brittle from the  client…,CASSANDRA-10365,"but I think it makes the metadata model more brittle from the  client perspective, considering that async schema change event propagation has been less  than perfect.",,"Architectural solution benefits and drawbacks
Assumptions",5:1628 - 5:1793,2,arjan
48:40,This will require us to deal with the fact that type resolution could…,CASSANDRA-10365,"This will require us to deal with the fact that type resolution could fail.
",,Architectural solution benefits and drawbacks,5:1795 - 5:1871,1,arjan
48:41,I might feel less strongly about this than some,CASSANDRA-10365,I might feel less strongly about this than some,,Architectural solution benefits and drawbacks,5:1872 - 5:1918,1,arjan
48:42,I think we have a way to avoid pars-  ing these CQL strings at all,CASSANDRA-10365,I think we have a way to avoid pars-  ing these CQL strings at all,,"Architectural component behavior and structure
Assumptions",5:1923 - 5:1988,2,arjan
48:43,"However, I know some drivers refer directly to these types in  the mod…",CASSANDRA-10365,"However, I know some drivers refer directly to these types in  the model when binding UDTs for execution. Those will require parsing and resolving, or  and API change to avoid it.
",,Architectural solution benefits and drawbacks,5:1991 - 5:2171,1,arjan
48:142,aholmber,CASSANDRA-10365,aholmber,,Comment,5:2176 - 5:2183,1,arjan
48:44,To be clear: I’m still in favor of this update.,CASSANDRA-10365,"To be clear: I’m still in favor of this update.
",,Architectural solution benefits and drawbacks,5:2186 - 5:2234,1,arjan
48:45,I simply wanted to explore the possibility to smooth things for some d…,CASSANDRA-10365,I simply wanted to explore the possibility to smooth things for some drivers,,Architectural solution benefits and drawbacks,5:2235 - 5:2310,1,arjan
48:46,by exposing  self-contained types along side the cql types.,CASSANDRA-10365,"by exposing  self-contained types along side the cql types.
",,Architectural design configuration,5:2312 - 5:2372,1,arjan
48:47,"If that’s not tenable, there is still a solution, and we still have pl…",CASSANDRA-10365,"If that’s not tenable, there is still a solution, and we still have plenty of time to integrate.
",,Architectural solution benefits and drawbacks,5:2373 - 5:2470,1,arjan
48:141,omichallat,CASSANDRA-10365,omichallat,,Comment,5:2475 - 5:2484,1,arjan
48:48,"The Java driver already has this kind of indirection, for example for…",CASSANDRA-10365,"The Java driver already has this kind of indirection, for example for state and  fnal functions in an aggregate’s metadata.",,"Architectural solution benefits and drawbacks
Technology solution",5:2487 - 5:2609,2,arjan
48:49,It will make things more brittle in the face of  potential event propa…,CASSANDRA-10365,"It will make things more brittle in the face of  potential event propagation bugs, but if it’s an assumed choice I’m fne with it.
",,Architectural solution benefits and drawbacks,5:2611 - 5:2741,1,arjan
48:140,aleksey,CASSANDRA-10365,aleksey,,Comment,5:2746 - 5:2752,1,arjan
48:50,The second commit switches reading schema to pure CQL vs. using comman…,CASSANDRA-10365,"The second commit switches reading schema to pure CQL vs. using commands directly,  as before, and rewrites the way merging of before/after is performed. With UDTs (soon)  referring other UDTs potentially, we can no longer perform the dif on row-by-row basis, and  4
instead *have to* perform it on full snapshot vs. full snapshot basis.
",,Architectural component behavior and structure,5:2987 - 6:72,1,arjan
48:139,aleksey,CASSANDRA-10365,aleksey,,Comment,6:106 - 6:112,1,arjan
48:51,The third (in-progress) commit switches types in schema tables to thei…,CASSANDRA-10365,"The third (in-progress) commit switches types in schema tables to their canoni-  cal CQL representation. That includes changes to ’functions’ and ’aggregates’ tables to no  longer keep a surrogate {{signature}} column.
",,Architectural component behavior and structure,6:115 - 6:334,1,arjan
48:138,aholmber,CASSANDRA-10365,aholmber,,Comment,6:678 - 6:685,1,arjan
48:52,Curious if you have given any thought to storing {{system_schema.aggre…,CASSANDRA-10365,Curious if you have given any thought to storing {{system_schema.aggregates.initcond}}  as a text CQL literal. ,,Architectural component behavior and structure,6:702 - 6:812,1,arjan
48:53,This is the only thing I have come across in my integration thus far…,CASSANDRA-10365,"This is the only thing I have come across in my integration thus far  that requires the client to parse types in order to reproduce DDL.
",,Architectural solution benefits and drawbacks,6:813 - 6:950,1,arjan
48:137,aleksey,CASSANDRA-10365,aleksey,,Comment,6:1270 - 6:1276,1,arjan
48:54,[~snazy] was kind enough to volunteer to deal with that bit of the tic…,CASSANDRA-10365,"[~snazy] was kind enough to volunteer to deal with that bit of the ticket - will most likely  be done tomorrow, no objections.
",,Architectural solution benefits and drawbacks,6:1528 - 6:1655,1,arjan
48:136,snazy,CASSANDRA-10365,snazy,,Comment,6:1923 - 6:1927,1,arjan
48:55,Pushed a commit that adds initcond literal to schema table,CASSANDRA-10365,Pushed a commit that adds initcond literal to schema table,,Architectural component behavior and structure,6:1930 - 6:1987,1,arjan
48:56,Specifcally the patch does:  * add {{initcond_literal}} column to {{sy…,CASSANDRA-10365,"Specifcally the patch does:  * add {{initcond_literal}} column to {{system_schema.aggregates}}, which contains the  literal from the _CREATE AGGREGATE_ statement  * add {{initcond_version}} column to {{system_schema.aggregates}}, which contains the  native protocol version used to serialize {{initcond}} value (to be able to read it in future  versions)  * add {{""tuple""}} case to {{CqlTypeParser}} (to get {{AggregationTest}} working)",,Architectural component behavior and structure,6:2048 - 6:2483,1,arjan
48:57,Unfortunately we cannot reliably re-construct the CQL literal for a nu…,CASSANDRA-10365,"Unfortunately we cannot reliably re-construct the CQL literal for a number of reasons:  * there are no {{TypeSerializer}} implementations for tuples/UDTs  * AbstractTextSerializer.getString() returns the non-quoted string  * TupleType/UserType return BytesSerializer - this means that nested type combinations  cannot be reliably stringifed (would return a hex representation instead of CQL tuple/UDT  5
literals)",,Motivation of design issue,6:2486 - 7:9,1,arjan
48:59,WRT this ticket - although it is not nice to not have the INITCOND lit…,CASSANDRA-10365,WRT this ticket - although it is not nice to not have the INITCOND literal in a _de-  scribeAggregate_ method for pre-3.0 UDAs,,Architectural solution benefits and drawbacks,7:12 - 7:137,1,arjan
48:58,"I *think* it’s ok, since UDFs and UDAs were  experimental in 2.2 and i…",CASSANDRA-10365,"I *think* it’s ok, since UDFs and UDAs were  experimental in 2.2 and it only afects a _describeAggregate_ method, if the driver is not  ""smart enough"" to reconstruct the literal itself from {{initcond}}.",,"Architectural solution benefits and drawbacks
Assumptions",7:140 - 7:342,2,arjan
48:60,So - for pre-3.0 UDAs  such a _describeAggregate_ would not work perfe…,CASSANDRA-10365,"So - for pre-3.0 UDAs  such a _describeAggregate_ would not work perfectly and might return some hint if {{init-  cond_literal}} column is {{null}}.
",,Architectural solution benefits and drawbacks,7:344 - 7:492,1,arjan
48:61,I’m not sure whether it’s worth to fx the AbstractType/TypeSerializer…,CASSANDRA-10365,I’m not sure whether it’s worth to fx the AbstractType/TypeSerializer getString/toString  functionality (for 3.0) since it’s a ’bit’ more code to change.,,Trade-offs,7:494 - 7:646,1,arjan
48:135,snazy,CASSANDRA-10365,snazy,,Comment,7:653 - 7:657,1,arjan
48:62,{{system_schema.aggregates.initcond}} is of type {{text}} and contains…,CASSANDRA-10365,{{system_schema.aggregates.initcond}} is of type {{text}} and contains the CQL term,,Architectural component behavior and structure,7:711 - 7:793,1,arjan
48:134,slebresne,CASSANDRA-10365,slebresne,,Comment,7:1040 - 7:1048,1,arjan
48:63,I tend to agree that the reloading in {{Keyspace.initCf}} shouldn’t be…,CASSANDRA-10365, I tend to agree that the reloading in {{Keyspace.initCf}} shouldn’t be necessary,,Architectural solution benefits and drawbacks,7:1333 - 7:1413,1,arjan
48:64,so I  would maybe prefer removing it rather that leaving a TODO that w…,CASSANDRA-10365,"so I  would maybe prefer removing it rather that leaving a TODO that will surely stay there a  long time.
",,Architectural design configuration,7:1415 - 7:1521,1,arjan
48:65,"In {{SchemaKeyspace.fetchKeyspacesOnly}}, the initial query looks unec…",CASSANDRA-10365," In {{SchemaKeyspace.fetchKeyspacesOnly}}, the initial query looks unecessary. ",,Architectural solution benefits and drawbacks,7:1523 - 7:1601,1,arjan
48:66,But it’s only used after having applied mutation that we knew applied…,CASSANDRA-10365, But it’s only used after having applied mutation that we knew applied to the keyspace  passed to this method,,Architectural component behavior and structure,7:1706 - 7:1814,1,arjan
48:67,"so really, I’m not convinced it’s useful.",CASSANDRA-10365,"so really, I’m not convinced it’s useful.
",,Architectural solution benefits and drawbacks,7:1817 - 7:1859,1,arjan
48:68,Any reason for removing the {{testConversionsInverses}} in {{CFMetadat…,CASSANDRA-10365, Any reason for removing the {{testConversionsInverses}} in {{CFMetadataTest}},,Architectural component behavior and structure,7:2419 - 7:2496,1,arjan
48:69,rather  than converting it to the new code?,CASSANDRA-10365,rather  than converting it to the new code?,,Architectural component behavior and structure,7:2498 - 7:2540,1,arjan
48:70,"e. At the very least,  the test was testing the inversion of hrift con…",CASSANDRA-10365,"e. At the very least,  the test was testing the inversion of hrift conversions which isn’t impacted by the patch and  should be preserved.
",,Architectural solution benefits and drawbacks,7:2579 - 7:2718,1,arjan
48:133,aleksey,CASSANDRA-10365,aleksey,,Comment,8:1761 - 8:1767,1,arjan
48:71,it’s still huge savings all over - now that we don’t need to read the…,CASSANDRA-10365," it’s still huge savings all over - now that we don’t need to read the previous state at  all, and with reload changes, but I’ll have a look.",,Architectural tactics,9:99 - 9:239,1,arjan
48:132,adutra,CASSANDRA-10365,adutra,,Comment,9:1969 - 9:1974,1,arjan
48:72,Up-to-date Java driver version [here|https://github.com/datastax/java-…,CASSANDRA-10365,"Up-to-date Java driver version [here|https://github.com/datastax/java-driver/pull/467].
",,Technology solution,9:1977 - 9:2065,1,arjan
48:131,slebresne,CASSANDRA-10365,slebresne,,Comment,9:2070 - 9:2078,1,arjan
48:73,"I don’t dispute that,",CASSANDRA-10365,"I don’t dispute that,",,Architectural tactics,9:2217 - 9:2237,1,arjan
48:74,"and while I suspect we might be able to avoid it, it actually doesn’t…",CASSANDRA-10365," and while I suspect we might be able to avoid it, it actually doesn’t  8
really bother me. ",,Architectural solution benefits and drawbacks,9:2238 - 10:18,1,arjan
48:130,slebresne,CASSANDRA-10365,slebresne,,Comment,10:110 - 10:118,1,arjan
48:75,The use of {{Types.none()}} in {{CQLSSTableWriter}} striked me as weir…,CASSANDRA-10365,"The use of {{Types.none()}} in {{CQLSSTableWriter}} striked me as weird. That made  realize however that I wasn’t sure if UDT were actually usable with {{CQLSSTableWriter}}  at all, and how if they are. ",,Architectural solution benefits and drawbacks,10:1068 - 10:1270,1,arjan
48:129,aleksey,CASSANDRA-10365,aleksey,,Comment,10:1376 - 10:1382,1,arjan
48:76,"They weren’t usable before, and I do not really care to fx it in this…",CASSANDRA-10365,"They weren’t usable before, and I do not really care to fx it in this ticket, so I just re-  tained the current behavior.
",,Architectural solution benefits and drawbacks,10:1533 - 10:1655,1,arjan
48:128,snazy,CASSANDRA-10365,snazy,,Comment,10:1660 - 10:1664,1,arjan
48:77,Yea - that’s completely broken (until CASSANDRA-10617),CASSANDRA-10365,Yea - that’s completely broken (until CASSANDRA-10617),,Architectural solution benefits and drawbacks,10:1667 - 10:1720,1,arjan
48:127,aholmber,CASSANDRA-10365,aholmber,,Comment,11:731 - 11:738,1,arjan
48:78,"Presently we consider the Python driver ready for integration, pending…",CASSANDRA-10365,"Presently we consider the Python driver ready for integration, pending two known issues:  1.) UDT quoting as mentioned by Sylvain  2.) Aggregate initcond to be stored as CQL literal  Once these items are addressed we should have a clean integration test suite.
Latest is still on the driver branch [here|https://github.com/datastax/python-driver/tree/422].
",,"Architectural solution benefits and drawbacks
Technology solution",11:764 - 11:1122,2,arjan
48:126,slebresne,CASSANDRA-10365,slebresne,,Comment,11:1436 - 11:1444,1,arjan
48:82,Why expose/use {{CQLTypeParser.parseRaw()}} instead of {{CQLTypeParse.…,CASSANDRA-10365,"Why expose/use {{CQLTypeParser.parseRaw()}} instead of {{CQLTypeParse.parse()}}  (In {{SchemaKeyspace.fetchTypes}}).
",,Architectural component behavior and structure,11:1498 - 11:1615,1,arjan
48:79,"I’d prefer keeping the {{Types}} map immutable (even if that means ""du…",CASSANDRA-10365,"I’d prefer keeping the {{Types}} map immutable (even if that means ""duplicating"" the map  in the ctor, and even if that’s theoretically done multiple time in {{Constructor.build()}}:",,Architectural component behavior and structure,11:1618 - 11:1799,1,arjan
48:80,and even if that’s theoretically done multiple time in {{Constructor.b…,CASSANDRA-10365,"and even if that’s theoretically done multiple time in {{Constructor.build()}}:  I can’t imagine this being a performance problem in practice).
",,Architectural solution benefits and drawbacks,11:1721 - 11:1865,1,arjan
48:125,aleksey,CASSANDRA-10365,aleksey,,Comment,11:2274 - 11:2280,1,arjan
48:81,That’s the only place we use it/need it. To fetch types themselves and…,CASSANDRA-10365,"That’s the only place we use it/need it. To fetch types themselves and resolve dependencies.
",,Architectural solution benefits and drawbacks,11:2485 - 11:2578,1,arjan
48:124,aholmber,CASSANDRA-10365,aholmber,,Comment,12:663 - 12:670,1,arjan
48:83,"Python integration test is good with latest push, with the exception o…",CASSANDRA-10365,"Python integration test is good with latest push, with the exception of the  broken {{initcond}} assumption.
",,Architectural solution benefits and drawbacks,12:673 - 12:782,1,arjan
48:123,slebresne,CASSANDRA-10365,slebresne,,Comment,12:1069 - 12:1077,1,arjan
48:84,I’m actually not that convinced it’s worth pulling a new dependency fo…,CASSANDRA-10365,"I’m actually not that convinced it’s worth pulling a new dependency for dealing with nested  UDT. Granted the previous method was brute-force, but it was simple and most likely good  enough for all practical purposes. In fact, I wouldn’t be that surprised to see the previous  method be faster than the new one on most common cases where you have a vast majority of  top-level UDT and a few 2-3 level deep ones. And none of this is in a very critical path any-  way. Avoiding the new {{jgrapht}} dependecy would avoid the questioning of the next point.
",,Architectural solution benefits and drawbacks,12:1128 - 12:1681,1,arjan
48:85,"{{jgrapht}} uses the ""Eclipse Public License"". It’s mentioned in http:…",CASSANDRA-10365,"{{jgrapht}} uses the ""Eclipse Public License"". It’s mentioned in http://www.apache.org/legal/resolved.html#categ  b: I’m not sure I understand all the requirements but at the very least we should add a  mention to the {{NOTICE}} fle with a link to the library web page. The page also talks  about ""requiring an explicit action by the user"" and I’m not sure about that. We might be  fne here but I can’t personally certify so with a high degree of confdence.
",,Architectural solution benefits and drawbacks,12:1684 - 12:2142,1,arjan
48:90,Could make {{Types.none()}} return the same singleton object since we…,CASSANDRA-10365," Could make {{Types.none()}} return the same singleton object since we do call it in a  bunch of places.
",,Architectural component behavior and structure,12:2144 - 12:2249,1,arjan
48:86,It sadens me that the type of the {{Types.types}} feld is not {{Immuta…,CASSANDRA-10365," It sadens me that the type of the {{Types.types}} feld is not {{ImmutableMap}} (the  reason seems to be to that the {{RawBuilder}} abuses {{Types}}).
",,Architectural solution benefits and drawbacks,12:2251 - 12:2402,1,arjan
48:87,the type of the {{Types.types}} feld is not {{ImmutableMap}},CASSANDRA-10365,the type of the {{Types.types}} feld is not {{ImmutableMap}},,Architectural component behavior and structure,12:2270 - 12:2329,1,arjan
48:88,"In {{SchemaKeyspace.fetchTypes}}, the use of {{Types}} have been expen…",CASSANDRA-10365," In {{SchemaKeyspace.fetchTypes}}, the use of {{Types}} have been expended to their fqn  ({{org.apache.cassandra.schema.Types}}).",,Architectural component behavior and structure,12:2404 - 12:2532,1,arjan
48:89,Not a big deal but I don’t think that’s necessary.,CASSANDRA-10365,"Not a big deal but I don’t think that’s necessary.
",,Architectural solution benefits and drawbacks,12:2534 - 12:2585,1,arjan
48:122,aleksey,CASSANDRA-10365,aleksey,,Comment,12:2590 - 12:2596,1,arjan
48:91,"It’s already being pulled by the driver, and we depend on that, so wha…",CASSANDRA-10365,"It’s already being pulled by the driver, and we depend on that, so whatevs.
",,Architectural solution benefits and drawbacks,12:2703 - 12:2779,1,arjan
48:121,aleksey,CASSANDRA-10365,aleksey,,Comment,12:2784 - 12:2790,1,arjan
48:92,"We have a bunch of libraries that do it so too (JDT, logback, maybe ot…",CASSANDRA-10365,"We have a bunch of libraries that do it so too (JDT, logback, maybe others), so this isn’t  an issue either.
",,Architectural solution benefits and drawbacks,12:2840 - 12:2949,1,arjan
48:120,aleksey,CASSANDRA-10365,aleksey,,Comment,12:2954 - 12:2960,1,arjan
48:93,Done.,CASSANDRA-10365,Done.,,Architectural solution benefits and drawbacks,12:3068 - 12:3072,1,arjan
48:94,Corrected.,CASSANDRA-10365,"Corrected.
",,Architectural solution benefits and drawbacks,13:90 - 13:101,1,arjan
48:95,Done,CASSANDRA-10365,Done,,Architectural solution benefits and drawbacks,13:204 - 13:207,1,arjan
48:96,"Given that it will always realistically be an ImmutableMap, I’m not ev…",CASSANDRA-10365,"Given that it will always realistically be an ImmutableMap, I’m not even saddened. Well,  just a little bit, but not it actually feels cleaner to me this way.
",,Architectural solution benefits and drawbacks,13:352 - 13:511,1,arjan
48:119,slebresne,CASSANDRA-10365,slebresne,,Comment,13:764 - 13:772,1,arjan
48:97,"Well, I would argue that it’s an even worth idea for the driver to pul…",CASSANDRA-10365,"Well, I would argue that it’s an even worth idea for the driver to pull a dependency just for  that, but I suppose it’s a separate subject. ",,Architectural solution benefits and drawbacks,13:843 - 13:982,1,arjan
48:98,"Anyway, I maintain that I prefer the old version:  the new one feels o…",CASSANDRA-10365,"Anyway, I maintain that I prefer the old version:  the new one feels overkill to me and since I’m not familiar with that new library, I actually  have less confdence in that new version. But it appears to work so you have my opinion  and I’ll let you make the fnal decision.
",,Architectural solution benefits and drawbacks,13:983 - 13:1258,1,arjan
48:99,The rest lgtm.,CASSANDRA-10365,"The rest lgtm.
",,Architectural solution benefits and drawbacks,13:1259 - 13:1274,1,arjan
48:118,aleksey,CASSANDRA-10365,aleksey,,Comment,13:1431 - 13:1437,1,arjan
48:100,"If you don’t really mind, I’ll leave it as is *for now*. tbh I just fn…",CASSANDRA-10365," If you don’t really mind, I’ll leave it as is *for now*. tbh I just fnd  v2 conceptually cleaner/simpler. And there might be some value in having similar logic on  both server and in the java-driver. That said, if drivers team decides to pull the dependency  and do something else - I’ll revert too. I’m perfectly fne with revisiting after 3.0.0, and I  know Alexandre is looking at an alternative option as well, so there is a high likelihood that  we will in fact ditch the dependency in both the driver and the server.
",,Architectural solution benefits and drawbacks,13:1452 - 13:1974,1,arjan
48:101,ditch the dependency in both the driver and the server,CASSANDRA-10365,ditch the dependency in both the driver and the server,,Architectural component behavior and structure,13:1919 - 13:1972,1,arjan
48:117,adutra,CASSANDRA-10365,adutra,,Comment,13:2396 - 13:2401,1,arjan
48:102,Pushed two new commits to the [current PR|https://github.com/datastax/…,CASSANDRA-10365,"Pushed two new commits to the [current PR|https://github.com/datastax/java-  driver/pull/467] for the Java driver. The frst one gets rid of the new dependency on jgrapht,  and implements topological sort from scratch (following Kahn’s algorithm); the second one  12
is of less interest for this ticket but for the record, it enables lazy resolution of UDTs when  the dependency graph is incomplete (which can happen when we refresh metadata for just  a subset of the entire schema).",,Architectural solution benefits and drawbacks,13:2404 - 14:216,1,arjan
48:116,slebresne,CASSANDRA-10365,slebresne,,Comment,14:387 - 14:395,1,arjan
48:105,"Well, there is a lot of failures. Some are due to tests needing to be…",CASSANDRA-10365,"Well, there is a lot of failures. Some are due to tests needing to be upgraded following  the change of driver version on cassci. But at least for the thrift tests (that are all failing),  it’s due to a genuine bug introduced by this patch. Thrift dtests are failing with the following  stack:",,Architectural solution benefits and drawbacks,14:454 - 14:746,1,arjan
48:103,"The reason is that super columns uses maps internally, and we allow co…",CASSANDRA-10365,"The reason is that super columns uses maps internally, and we allow counters in super  columns. We do indeed not allow counters in collections in CQL, but it’s not a problem  internally and we shouldn’t throw in {{CQL3Type.Raw.prepare}} in that case anymore.
",,Motivation of design issue,14:2301 - 14:2560,1,arjan
48:104,"Not entirely sure where to move that check however, so the simplest so…",CASSANDRA-10365,"Not entirely sure where to move that check however, so the simplest solution might be to  use a {{prepareInternal}} version using by schema handling that disable this check.
",,Architectural component behavior and structure,14:2561 - 14:2735,1,arjan
48:115,aleksey,CASSANDRA-10365,aleksey,,Comment,15:5 - 15:11,1,arjan
48:106,"Well, that’s annoying. {{prepareInternal}} it is then.",CASSANDRA-10365," Well, that’s annoying. {{prepareInternal}} it is then.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",15:13 - 15:69,2,arjan
48:114,aleksey,CASSANDRA-10365,aleksey,,Comment,15:74 - 15:80,1,arjan
48:108,simple fx [here|https://github.com/iamaleksey/cassandra/commits/10365-…,CASSANDRA-10365," simple fx [here|https://github.com/iamaleksey/cassandra/commits/10365-  counters-fx], does the minimal job to handle just supercolumns with counters, and doesn’t  go any further (and perhaps shouldn’t).
",,Architectural component behavior and structure,15:95 - 15:299,1,arjan
48:107,"Also, entirely unrelated, but it seems like we do allow counters as ma…",CASSANDRA-10365,"Also, entirely unrelated, but it seems like we do allow counters as map keys, or at least  don’t validate it {{RawCollection}}",,Existing system architecture description,15:300 - 15:425,1,arjan
48:113,slebresne,CASSANDRA-10365,slebresne,,Comment,15:460 - 15:468,1,arjan
48:109,That’s exactly what I had in mind so lgtm.,CASSANDRA-10365,"That’s exactly what I had in mind so lgtm.
",,Architectural solution benefits and drawbacks,15:556 - 15:599,1,arjan
48:110,Saw that too and not sure why that is. Seems like an oversight though…,CASSANDRA-10365,"Saw that too and not sure why that is. Seems like an oversight though maybe we check  some place else. We’ll have to check.
",,"Assumptions
Technical debt",15:704 - 15:828,2,arjan
48:112,aleksey,CASSANDRA-10365,aleksey,,Comment,15:2163 - 15:2169,1,arjan
48:111,"I think Paulo and I fxed most dtest issues, and none should be remaini…",CASSANDRA-10365," I think Paulo and I fxed most dtest issues, and none should be remaining that  are caused by this particular commit",,"Architectural solution benefits and drawbacks
Assumptions",15:2171 - 15:2286,2,arjan
57:1,Deprecate Pig support in 2.2 and remove it in 3.0,CASSANDRA-10542,Deprecate Pig support in 2.2 and remove it in 3.0,,Technology solution,3:53 - 3:101,1,arjan
57:2,"Nobody’s currently responsible for Pig code. As a result, there is nob…",CASSANDRA-10542,"Nobody’s currently responsible for Pig code. As a result, there is nobody to fx the issues, or  even fx the failing tests (of which we unfortunately have plenty). Those tests take time to run,  constantly hang, and fail with cryptic errors that we don’t know how to fx and don’t have enough  resources to investigate.
",,Architectural solution benefits and drawbacks,3:121 - 3:439,1,arjan
57:3,Thus I propose we deprecate Pig support in 2.2 and remove it in 3.0.,CASSANDRA-10542,"Thus I propose we deprecate Pig support in 2.2 and remove it in 3.0.
",,Technology solution,3:440 - 3:509,1,arjan
57:6,slebresne,CASSANDRA-10542,slebresne,,Comment,3:613 - 3:621,1,arjan
57:4,I agree. No one in the core maintainers has any expertise of Pig itsel…,CASSANDRA-10542," I agree. No one in the core maintainers has any expertise of Pig itself and our  Pig code in particular, and no one else has step up to maintain that code properly. And  it’s something that can totally live outside of the main project if others have willingness to  maintain it.
",,Architectural solution benefits and drawbacks,3:623 - 3:903,1,arjan
57:7,slebresne,CASSANDRA-10542,slebresne,,Comment,3:1040 - 3:1048,1,arjan
57:5,"Assuming nothing breaks in the unit test (for the 3.0 patch), +1 to bo…",CASSANDRA-10542,"Assuming nothing breaks in the unit test (for the 3.0 patch), +1 to both patches.
",,Architectural solution benefits and drawbacks,3:1051 - 3:1133,1,arjan
62:1,Use Cafeine (W-TinyLFU) for on-heap caches,CASSANDRA-10855,Use Cafeine (W-TinyLFU) for on-heap caches,,Technology solution,3:53 - 3:94,1,arjan
62:131,aweisberg,CASSANDRA-10855,aweisberg,,Comment,3:314 - 3:322,1,arjan
62:2,I don’t object to swapping CLHM with a new implementation. As a matter…,CASSANDRA-10855,"I don’t object to swapping CLHM with a new implementation. As a matter  of principle we should measure what impact this has so we can understand the yield of the  optimizations in tiny LFU. We shouldn’t be making changes for performance without mea-  suring,",,Architectural solution benefits and drawbacks,3:325 - 3:582,1,arjan
62:3,but also so we can inform the evolution of OHC,CASSANDRA-10855,but also so we can inform the evolution of OHC ,,Architectural design configuration,3:584 - 3:630,1,arjan
62:4,which solves the GC pressure issue.,CASSANDRA-10855,"which solves the GC pressure issue.
",,Architectural solution benefits and drawbacks,3:631 - 3:667,1,arjan
62:5,"I see on heap caches, memtables, and any other source of high volume s…",CASSANDRA-10855,"I see on heap caches, memtables, and any other source of high volume survivor copying  and promotion as a dead end.
",,Architectural solution benefits and drawbacks,3:668 - 3:784,1,arjan
62:6,We changed the format of the key cache for 3.0 so that it would be sui…,CASSANDRA-10855,"We changed the format of the key cache for 3.0 so that it would be suitable for memory  mapping, but didn’t get the change in to actually use a memory mapped access method.
Robert Stupp did write a lot of the code, but it was still using OHC as the cache.",,Existing system architecture description,3:785 - 3:1040,1,arjan
62:130,ben.manes,CASSANDRA-10855,ben.manes,,Comment,3:1267 - 3:1275,1,arjan
62:8,If the performance analysis is positive then it provides a strong moti…,CASSANDRA-10855,If the performance analysis is positive then it provides a strong motivation  to integrate W-TinyLFU into OHC.,,"Architectural solution benefits and drawbacks
Assumptions",3:1375 - 3:1484,2,arjan
62:9,"As Robert described it, the on-heap caches are low  hanging fruit wher…",CASSANDRA-10855,"As Robert described it, the on-heap caches are low  hanging fruit where the key cache is performance critical.",,Architectural component behavior and structure,3:1486 - 3:1595,1,arjan
62:10,"I’m a little disappointed that OHC didn’t borrow ideas from CLHM, as t…",CASSANDRA-10855,"I’m a little disappointed that OHC didn’t borrow ideas from CLHM, as the fundamentals  are transferable, ",,Architectural solution benefits and drawbacks,4:456 - 4:560,1,arjan
62:129,snazy,CASSANDRA-10855,snazy,,Comment,4:630 - 4:634,1,arjan
62:11,the results look good to me (i.e. no regression).,CASSANDRA-10855,"the results look good to me (i.e. no regression).
",,Architectural solution benefits and drawbacks,4:719 - 4:769,1,arjan
62:12,Unfortunately the cstar perf runs ([trades-fwd-lcs-nolz4|http://cstar.…,CASSANDRA-10855,"Unfortunately the cstar perf runs ([trades-fwd-lcs-nolz4|http://cstar.datastax.com/tests/id/6fcb6cbc-  aafa-11e5-947f-0256e416528f] and [cassci regression test r/w|http://cstar.datastax.com/tests/id/6b113b02-  aafa-11e5-947f-0256e416528f]) show that using Cafeine for the key cache slightly _degrades_  performance in terms of throughput and latencies. Some percentiles (mostly max latencies)  are slightly better, but the overall result is that performance degrades. The key-cache hit  rate is slightly better with Cafeine (trades-fwd-lcs-nolz4 showing slightly more than 10% hit  rate w/ Cafeine vs. slightly less than 10% w/o Cafeine).
",,Architectural solution benefits and drawbacks,4:770 - 4:1409,1,arjan
62:13,Cafeine for the key cache,CASSANDRA-10855,Cafeine for the key cache,,Technology solution,4:1026 - 4:1050,1,arjan
62:15,_trades-fwd-lcs-nolz4_ uses somewhat bigger partitions and flls the ke…,CASSANDRA-10855,"_trades-fwd-lcs-nolz4_ uses somewhat bigger partitions and flls the key cache completely.
",,Architectural solution benefits and drawbacks,4:1410 - 4:1500,1,arjan
62:17,_regression r/w_ uses small partitions and just uses roughly 10% of th…,CASSANDRA-10855,"_regression r/w_ uses small partitions and just uses roughly 10% of the key cache.
",,Architectural solution benefits and drawbacks,4:1501 - 4:1584,1,arjan
62:14,"From a _really quick & brief_ view at the Cafeine source, I *suspect*…",CASSANDRA-10855,"From a _really quick & brief_ view at the Cafeine source, I *suspect* that the worse  numbers are caused by the spinning loops. Also padding felds, which can behave com-  pletely diferent on NUMA than on singe-CPU systems, may have some bad infuence in this  test.
",,Motivation of design issue,4:1707 - 4:1972,1,arjan
62:128,ben.manes,CASSANDRA-10855,ben.manes,,Comment,4:1976 - 4:1984,1,arjan
62:18,It being low regardless of policy is  troubling.,CASSANDRA-10855,It being low regardless of policy is  troubling.,,Architectural solution benefits and drawbacks,4:2028 - 4:2075,1,arjan
62:19,So it seems important to fgure out why that is and what (if anything)…,CASSANDRA-10855,"So it seems important to fgure out why that is and what (if anything) can be  done to improve that.
An inefective cache impacts the design assumptions by making writes (not reads) the com-  mon case. The slightly heavier policy, default delegation to FJP, etc would all be more  noticeable when writes are the dominate behavior. I’m not sure of-hand why its worse, but  that seems secondary to fxing the hit rate problem.
",,Motivation of design issue,4:2077 - 4:2500,1,arjan
62:127,aweisberg,CASSANDRA-10855,aweisberg,,Comment,4:2504 - 4:2512,1,arjan
62:20,Is this testing with a uniform access distribution?,CASSANDRA-10855,Is this testing with a uniform access distribution?,,"Architectural design configuration
Assumptions",4:2515 - 4:2565,2,arjan
62:21,We keep doing that because  it’s the default and I think it’s a really…,CASSANDRA-10855,"We keep doing that because  it’s the default and I think it’s a really bad way to measure as a default since it’s the exception  not the common case.
",,"Architectural solution benefits and drawbacks
Assumptions",4:2567 - 4:2717,2,arjan
62:126,ben.manes,CASSANDRA-10855,ben.manes,,Comment,4:2721 - 4:2729,1,arjan
62:22,"Ariel’s comment explains the poor hit rate, as a uniform distribution…",CASSANDRA-10855,"Ariel’s comment explains the poor hit rate, as a uniform distribution will result in a fxed  and low hit rate regardless of policy. ",,Architectural solution benefits and drawbacks,4:2793 - 4:2924,1,arjan
62:23,uniform distribution,CASSANDRA-10855, uniform distribution ,,Architectural component behavior and structure,4:2841 - 4:2862,1,arjan
62:26,"An efective cache is often at around 85%, ideally in  the high 90s to…",CASSANDRA-10855,"An efective cache is often at around 85%, ideally in  the high 90s to make reads the dominant case, but even 65% is useful. Even when the hit  rate is maxed out, the efect of a better policy can be noticeable. In that case it reduces the  TCO by being able to achieve the same performance with smaller, cheaper machines.
Glancing at the uniform results the degredation is small enough to probably be within  the margin of error where the run and other system efects dominate.",,Motivation of design issue,4:2925 - 4:3400,1,arjan
62:24,In an update heavy  workload the new cache,CASSANDRA-10855,In an update heavy  workload the new cache,,Architectural component behavior and structure,4:3402 - 4:3443,1,arjan
62:25,should be faster due to synchronization having less penalty than  CAS…,CASSANDRA-10855,"should be faster due to synchronization having less penalty than  CAS storms. But on the perf test’s insertion heavy workload it is probably a little slower  3
due to features incurring more complexity.",,Architectural solution benefits and drawbacks,4:3445 - 5:42,1,arjan
62:27,[Zipf-like|http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.12.…,CASSANDRA-10855,"[Zipf-like|http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.12.2253&rank=1] distri-  butions are considered the most common workload patterns. Ideally we could capture a pro-  duction trace and simulate it, as the [database trace|https://github.com/ben-manes/cafeine/wiki/Efciency#databa  I use",,Architectural component behavior and structure,5:127 - 5:427,1,arjan
62:28,shows very promising results.,CASSANDRA-10855,"shows very promising results.
",,Architectural tactics,5:429 - 5:459,1,arjan
62:125,snazy,CASSANDRA-10855,snazy,,Comment,5:463 - 5:467,1,arjan
62:29,"BTW, I have to correct my last statement partly: _trades-fwd-lcs-nolz4…",CASSANDRA-10855,"BTW, I have to correct my last statement partly: _trades-fwd-lcs-nolz4_ has the 99.x%  key-cache hit ration (using 10% of the key cache’s capacity) ",,Architectural solution benefits and drawbacks,5:578 - 5:725,1,arjan
62:30,"_regression r/w_ has the  bad, ~10% hit ratio.",CASSANDRA-10855,"_regression r/w_ has the  bad, ~10% hit ratio.",,Architectural solution benefits and drawbacks,5:731 - 5:776,1,arjan
62:31,_trades-fwd-lcs-nolz4_ [Operation 1|http://cstar.datastax.com/graph?co…,CASSANDRA-10855,_trades-fwd-lcs-nolz4_ [Operation 1|http://cstar.datastax.com/graph?command=one_job&stats=6fcb6cbc-  aafa-11e5-947f-0256e416528f&metric=op_rate&operation=1_user&smoothing=1&show_aggregates=true&xmin=  (mixed writes+reads) gives a nice perf improvement during the frst seconds but then egalizes  with the existing implementation,,Architectural tactics,5:873 - 5:1199,1,arjan
62:32,[Operation 2|http://cstar.datastax.com/graph?command=one_job&stats=6fc…,CASSANDRA-10855,"[Operation 2|http://cstar.datastax.com/graph?command=one_job&stats=6fcb6c  aafa-11e5-947f-0256e416528f&metric=op_rate&operation=2_user&smoothing=1&show_aggregates=true&xmin=  4 and 6 (all just reads) show a slight regression or no diference.
",,Architectural solution benefits and drawbacks,5:1202 - 5:1444,1,arjan
62:33,OTOH _cassci regression test r/w_ shows the perf regression of about 5…,CASSANDRA-10855,"OTOH _cassci regression test r/w_ shows the perf regression of about 5%.
",,Architectural tactics,5:1445 - 5:1518,1,arjan
62:124,ben.manes,CASSANDRA-10855,ben.manes,,Comment,5:1522 - 5:1530,1,arjan
62:34,I use YCSB’s distributions for [synthetic|https://github.com/ben-manes…,CASSANDRA-10855,I use YCSB’s distributions for [synthetic|https://github.com/ben-manes/cafeine/blob/master/simulator/src/main/  workloads.,,Architectural component behavior and structure,5:1603 - 5:1724,1,arjan
62:35,If the cache doesn’t reach 50% capacity then Cafeine doesn’t even init…,CASSANDRA-10855,"If the cache doesn’t reach 50% capacity then Cafeine doesn’t even initialize the frequency  sketch to save memory (e.g. someone sets the max to a ridiculous threshold as a worst  case bound). It could probably also by avoid the LRU shufing, which would reduce the  maintenance penalty.
",,"Architectural solution benefits and drawbacks
Technology solution",5:1769 - 5:2055,2,arjan
62:123,ben.manes,CASSANDRA-10855,ben.manes,,Comment,5:2060 - 5:2068,1,arjan
62:36,Insertions now avoid an unnecessary lambda.,CASSANDRA-10855,Insertions now avoid an unnecessary lambda.,,Architectural component behavior and structure,5:2223 - 5:2265,1,arjan
62:37,"I suspect that will have a negligible bene-  ft, but its always good t…",CASSANDRA-10855,"I suspect that will have a negligible bene-  ft, but its always good to be more GC hygienic.
",,Architectural solution benefits and drawbacks,5:2267 - 5:2360,1,arjan
62:38,A cache below 50% capacity will skip read policy work.,CASSANDRA-10855,A cache below 50% capacity will skip read policy work.,,Architectural component behavior and structure,5:2361 - 5:2414,1,arjan
62:39,That means it won’t record the  access in ring bufers which reduces co…,CASSANDRA-10855,"That means it won’t record the  access in ring bufers which reduces contention. That also reduces the how often policy  the maintenance work is scheduled, as the bufers don’t need to be drained. A write will  still trigger a maintenance cycle, but that should be shorter by doing less. This result in  throughput close to a raw ConcurrentHashMap and then incurring the penalty when the  threshold is crossed. That should improve _trades-fwd-lcs-nolz4_ and anyone else’s usage  where the cache is merely a safety threshold but isn’t likely to grow close to the maximum.
",,Architectural solution benefits and drawbacks,5:2416 - 5:2985,1,arjan
62:122,jeromatron,CASSANDRA-10855,jeromatron,,Comment,5:2990 - 5:2999,1,arjan
62:40,"As part of testing, should we also fx cstar perf relating to cache to…",CASSANDRA-10855,"As part of testing, should we also fx cstar perf relating to cache to no longer  be uniform access distribution?",,Architectural component behavior and structure,5:3002 - 5:3113,1,arjan
62:41,"It seems like for this and future tests, that would give a  more real-…",CASSANDRA-10855,"It seems like for this and future tests, that would give a  more real-world result.
",,Architectural solution benefits and drawbacks,5:3115 - 5:3199,1,arjan
62:121,jbellis,CASSANDRA-10855,jbellis,,Comment,5:3204 - 5:3210,1,arjan
62:42,(cstar is back.),CASSANDRA-10855, (cstar is back.),,Architectural solution benefits and drawbacks,5:3212 - 5:3228,1,arjan
62:120,ben.manes,CASSANDRA-10855,ben.manes,,Comment,6:5 - 6:13,1,arjan
62:43,[2.1.0|https://github.com/ben-manes/cafeine/releases/tag/v2.1.0] was r…,CASSANDRA-10855, [2.1.0|https://github.com/ben-manes/cafeine/releases/tag/v2.1.0] was released,,Technology solution,6:15 - 6:92,1,arjan
62:44,which includes the above mentioned optimizations. So the cache should…,CASSANDRA-10855,which includes the above mentioned optimizations. So the cache should seem artifcially bet-  ter for an artifcial workload =),,Architectural solution benefits and drawbacks,6:95 - 6:219,1,arjan
62:45,"It  would be nice if we knew what real-world distributions were like,…",CASSANDRA-10855,"It  would be nice if we knew what real-world distributions were like, as Zipf-like is what re-  searchers published. From the traces I’ve experimented with, I am fairly confdent in a net  positive result.
",,Architectural solution benefits and drawbacks,6:304 - 6:509,1,arjan
62:119,aweisberg,CASSANDRA-10855,aweisberg,,Comment,6:655 - 6:663,1,arjan
62:46,so you shouldn’t need to do a code change to fnd an alternative to uni…,CASSANDRA-10855,so you shouldn’t need to do a code change to fnd an alternative to uniform.,,Architectural component behavior and structure,6:757 - 6:831,1,arjan
62:47,Not sure if  Weibull can fll the same niche as Zipf.,CASSANDRA-10855,"Not sure if  Weibull can fll the same niche as Zipf.
",,Architectural solution benefits and drawbacks,6:833 - 6:886,1,arjan
62:118,benedict,CASSANDRA-10855,benedict,,Comment,6:891 - 6:898,1,arjan
62:48,Zipf could easily be added.,CASSANDRA-10855, Zipf could easily be added.,,Architectural solution benefits and drawbacks,6:900 - 6:927,1,arjan
62:49,I added Weibull as the extreme value distribution  without thinking to…,CASSANDRA-10855,"I added Weibull as the extreme value distribution  without thinking too much about things at the time, and still don’t really understand (nor  have the time to) probability distributions. Both are used to model both incidence and  sizes, but in difering circumstances. Zipf originates from language, but Weibull distribution  apparently better models iconographic languages!
",,Architectural solution benefits and drawbacks,6:929 - 6:1304,1,arjan
62:50,It does seem that the literature standardizes on Zipf for incidence fo…,CASSANDRA-10855,It does seem that the literature standardizes on Zipf for incidence for things like access  patterns.,,Architectural solution benefits and drawbacks,6:1305 - 6:1405,1,arjan
62:51,"I’m pretty sure Weibull would also be fne, but it is perhaps better su…",CASSANDRA-10855,"I’m pretty sure Weibull would also be fne, but it is perhaps better suited for  generating extreme values (such as size of payload),",,Architectural solution benefits and drawbacks,6:1407 - 6:1538,1,arjan
62:52,"but even this could happily be dealt  with by Zipf,",CASSANDRA-10855,"but even this could happily be dealt  with by Zipf,",,Architectural solution benefits and drawbacks,6:1540 - 6:1590,1,arjan
62:53,so perhaps we should just switch out Weibull entirely.,CASSANDRA-10855,"so perhaps we should just switch out Weibull entirely.
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",6:1592 - 6:1647,2,arjan
62:117,ben.manes,CASSANDRA-10855,ben.manes,,Comment,6:1652 - 6:1660,1,arjan
62:54,"I think Weibull should be fne, too.",CASSANDRA-10855," I think Weibull should be fne, too.
",,Architectural solution benefits and drawbacks,6:1662 - 6:1699,1,arjan
62:55,My expectation is that in a scenario similar to a  realistic workload…,CASSANDRA-10855,"My expectation is that in a scenario similar to a  realistic workload there will be a less I/O due to fewer cache misses. If there is a slight  degredation (or gain) in other aspects of the new cache that should have a negligible impact,  as reduced I/O will be the dominant efect. This would then provide a good argument for  OHC to revisit its eviction policy.
",,Architectural solution benefits and drawbacks,6:1918 - 6:2281,1,arjan
62:116,ben.manes,CASSANDRA-10855,ben.manes,,Comment,6:2507 - 6:2515,1,arjan
62:56,It sounds like we all thought Weibull was a good choice.,CASSANDRA-10855, It sounds like we all thought Weibull was a good choice. ,,Architectural solution benefits and drawbacks,6:2517 - 6:2574,1,arjan
62:57,Another option is to  use [YCSB|https://github.com/brianfrankcooper/YC…,CASSANDRA-10855,Another option is to  use [YCSB|https://github.com/brianfrankcooper/YCSB] ,,Technology solution,6:2575 - 6:2648,1,arjan
62:58,which handles correlated omission  and is popular benchmark for compar…,CASSANDRA-10855,"which handles correlated omission  and is popular benchmark for comparing data stores.
",,Architectural solution benefits and drawbacks,6:2649 - 6:2736,1,arjan
62:115,benedict,CASSANDRA-10855,benedict,,Comment,6:3037 - 6:3044,1,arjan
62:59,The employment of probabilistic data structures for a cache is the obv…,CASSANDRA-10855,"The employment of probabilistic data structures for a cache is the obvious next step in  5
their evolution (something I had a hope to explore before Tiny-LFU showed up), and Tiny-  LFU being the frst such scheme should absolutely be considered *strongly*. It is simply  natural that a probabilistic approach should be capable of yielding better returns for a prob-  abilistic application (hit rate), and if anything I’m surprised the world has been so slow to  exploit this idea. Were I making the comment again today, I would have suggested that  Tiny-LFU be considered as the most sensible choice.
That goes doubly for the fact that any given _implementation_ is a stop-gap until the  transition to Thread-Per-Core completes and we can make all of our algorithms more mem-  ory (and execution) efcient. Since Tiny-LFU already exists, it does seem an obvious choice  on that front.
",,"Architectural solution benefits and drawbacks
Technology solution",6:3186 - 7:794,2,arjan
62:114,ben.manes,CASSANDRA-10855,ben.manes,,Comment,7:799 - 7:807,1,arjan
62:60,"When Cassandra moves to TPC, it should take less than a day to write a…",CASSANDRA-10855,"When Cassandra moves to TPC, it should take less than a day to write a  TinyLFU cache if you borrow my [4-bit CountMin sketch|https://github.com/ben-manes/cafeine/blob/master/cafe",,"Architectural component behavior and structure
Assumptions",7:810 - 7:988,2,arjan
62:61,The simulator includes a variant using incremental reset,CASSANDRA-10855,The simulator includes a variant using incremental reset ,,Architectural component behavior and structure,7:1091 - 7:1147,1,arjan
62:62,which would be my preference  for a TPC) and shows a negligible difere…,CASSANDRA-10855,which would be my preference  for a TPC) and shows a negligible diference in hit rates,,Architectural solution benefits and drawbacks,7:1149 - 7:1234,1,arjan
62:63,"Cafeine tackled the research and concurrency side, but no reason to ad…",CASSANDRA-10855,"Cafeine tackled the research and concurrency side, but no reason to adopt it once TPC.
Best to take ideas, leverage its simulator to fne tune, and share insights.
",,Architectural solution benefits and drawbacks,7:1362 - 7:1526,1,arjan
62:113,benedict,CASSANDRA-10855,benedict,,Comment,7:1531 - 7:1538,1,arjan
62:64,"Yes, I agree it would not be difcult, and the rest of my statement hol…",CASSANDRA-10855,"Yes, I agree it would not be difcult, and the rest of my statement holds for the  post-TPC world - I would still think Tiny-LFU likely the best choice. That aspect of my  comment was only meant to serve as an extra point in favour of a near-zero-cost solution in  the meantime, saving any development expenditure for the more long-term solution.
",,Architectural solution benefits and drawbacks,7:1541 - 7:1887,1,arjan
62:112,benedict,CASSANDRA-10855,benedict,,Comment,7:1892 - 7:1899,1,arjan
62:65,We should defnitely address Branimir’s [comment|https://issues.apache.…,CASSANDRA-10855,"We should defnitely address Branimir’s [comment|https://issues.apache.org/jira/browse/CASSANDRA  11452?focusedCommentId=15240789&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-  tabpanel#comment-15240789] before merging. As he says, this could theoretically com-  pletely eliminate the beneft of the cache in certain circumstances.
",,Architectural solution benefits and drawbacks,7:1902 - 7:2248,1,arjan
62:66,"I think both supporting larger hashes, and not comparing _only_ agains…",CASSANDRA-10855,"I think both supporting larger hashes, and not comparing _only_ against the main evic-  tion candidate for admission (e.g. comparing against a value with logarithmically random  distance from the eviction candidate)",,"Architectural component behavior and structure
Assumptions",7:2249 - 7:2463,2,arjan
62:67,are reasonably easy and should solve the problem,CASSANDRA-10855, are reasonably easy and should solve the problem,,Architectural solution benefits and drawbacks,7:2465 - 7:2513,1,arjan
62:111,ben.manes,CASSANDRA-10855,ben.manes,,Comment,7:2705 - 7:2713,1,arjan
62:68,[~blambov] [integrated | https://github.com/apache/cassandra/commit/30…,CASSANDRA-10855,[~blambov] [integrated | https://github.com/apache/cassandra/commit/30bb255ec9fb36ace2aab51474  Cafeine (v2.2.6) for the chunk cache ([CASSANDRA-5863 | https://issues.apache.org/jira/browse/CASSANDRA-  5863]). He included an analysis demonstrated good performance and hit rates.,,Architectural solution benefits and drawbacks,7:2716 - 7:2993,1,arjan
62:69,I am currently exploring an adaptive version  of the policy,CASSANDRA-10855,I am currently exploring an adaptive version  of the policy,,Architectural component behavior and structure,7:3135 - 7:3193,1,arjan
62:70,"that improves its hit rate for small, recency-skewed caches. This woul…",CASSANDRA-10855,"that improves its hit rate for small, recency-skewed caches. This would also  naturally resolve the attack without needing our protection scheme.
",,"Architectural solution benefits and drawbacks
Architectural tactics",7:3195 - 7:3341,2,arjan
62:71,While  there might be a performance gain of using ForkJoinPool#commonP…,CASSANDRA-10855,"While  there might be a performance gain of using ForkJoinPool#commonPool (default), this was  also a very wise choice. [Druid | http://druid.io/] was recently struck by [JDK-8078490 |  https://bugs.openjdk.java.net/browse/JDK-8078490] where a race in 8u40 - 8u60 causes the  pool to not execute the task.",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks
Architectural tactics
Assumptions",7:3423 - 7:3727,4,arjan
62:72,"With [~blambov]’s work proving the benefts, can we move this forward f…",CASSANDRA-10855,"With [~blambov]’s work proving the benefts, can we move this forward for the remain-  ing caches",,Architectural solution benefits and drawbacks,8:1 - 8:96,1,arjan
62:110,ben.manes,CASSANDRA-10855,ben.manes,,Comment,8:424 - 8:432,1,arjan
62:73,The upgrade is maintenance improvements since 2.2.6 in use.,CASSANDRA-10855,"The upgrade is maintenance improvements since 2.2.6 in use.
",,"Architectural solution benefits and drawbacks
Technology solution",8:521 - 8:581,2,arjan
62:109,ben.manes,CASSANDRA-10855,ben.manes,,Comment,8:1446 - 8:1454,1,arjan
62:74,The test failure might be due to delegating maintenance work (e.g. wri…,CASSANDRA-10855,"The test failure might be due to delegating maintenance work (e.g. writes  triggering an eviction) to an executor. CLHM and Guava amortized this on the calling  threads, whereas Cafeine tries to hide it on ForkJoinPool to minimize user-facing latencies.
",,Motivation of design issue,8:1457 - 8:1711,1,arjan
62:75,By setting Cafeine.executor(Runnable::run),CASSANDRA-10855,By setting Cafeine.executor(Runnable::run),,Technology solution,8:1712 - 8:1753,1,arjan
62:76,"t will behave similar to its predecessors, ideally  set only in tests…",CASSANDRA-10855,"t will behave similar to its predecessors, ideally  set only in tests for predictability.",,Architectural solution benefits and drawbacks,8:1756 - 8:1844,1,arjan
62:77,Alternatively calling cache.cleanUp() prior to inspecting,CASSANDRA-10855,Alternatively calling cache.cleanUp() prior to inspecting,,Architectural component behavior and structure,8:1846 - 8:1902,1,arjan
62:78,is another easy alternative.,CASSANDRA-10855,"is another easy alternative.
",,Architectural solution benefits and drawbacks,8:1905 - 8:1934,1,arjan
62:108,snazy,CASSANDRA-10855,snazy,,Comment,8:2241 - 8:2245,1,arjan
62:79,There are a couple of {{cache.asMap()}} calls,CASSANDRA-10855,There are a couple of {{cache.asMap()}} calls,,Architectural component behavior and structure,9:3 - 9:47,1,arjan
62:80,"Would it be an option to eagerly create the  {{AsMapView}}, {{Values}}…",CASSANDRA-10855,"Would it be an option to eagerly create the  {{AsMapView}}, {{Values}} and {{EntrySet}} instances in {{LocalAsyncLoadingCache}}  to get around the ternaries in {{asMap()}}, {{values()}}, {{entrySet()}} and {{keySet}}?
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",9:50 - 9:268,2,arjan
62:81,"Beside these, I’ve got no comments. Pretty straight forward change. Go…",CASSANDRA-10855,"Beside these, I’ve got no comments. Pretty straight forward change. Good work so far!
",,Architectural solution benefits and drawbacks,9:269 - 9:355,1,arjan
62:82,If [~benedict] (IIRC he already worked on Cafeine) says it buys us som…,CASSANDRA-10855,"If [~benedict] (IIRC he already worked on Cafeine) says it buys us something,  I’d be fne omitting the benchmarks.
",,Architectural solution benefits and drawbacks,9:519 - 9:634,1,arjan
62:107,ben.manes,CASSANDRA-10855,ben.manes,,Comment,9:890 - 9:898,1,arjan
62:83,This is good for unit tests to remove asynchronous behavior. My prefer…,CASSANDRA-10855,"This is good for unit tests to remove asynchronous behavior. My preference is to not use it  in production, especially where latencies matter, by not penalizing callers with maintenance  or removal notifcation work.",,Architectural solution benefits and drawbacks,9:1009 - 9:1223,1,arjan
62:84,Instead deferring that to FJP,CASSANDRA-10855,Instead deferring that to FJP ,,Architectural component behavior and structure,9:1225 - 9:1254,1,arjan
62:85,"should help minimize response  times, which I think would be your pref…",CASSANDRA-10855,"should help minimize response  times, which I think would be your preference too. ",,"Architectural solution benefits and drawbacks
Assumptions",9:1255 - 9:1336,2,arjan
62:86,{{LocalAsyncLoadingCache}} isn’t used by Cassandra (a cache that retur…,CASSANDRA-10855,"{{LocalAsyncLoadingCache}} isn’t used by Cassandra (a cache that returns {{Completable-  Future}}. Given the ternaries are null checks to lazily create views, as is common in the  Java Collections, I don’t think its a measurable penalty to keep.
",,"Architectural solution benefits and drawbacks
Assumptions",9:1753 - 9:1999,2,arjan
62:87,For concurrent throughput (JMH) see these [benchmarks|https://github.c…,CASSANDRA-10855,"For concurrent throughput (JMH) see these [benchmarks|https://github.com/ben-manes/cafeine/wiki/Benchmarks  They show a refnements over CLHM, with a primary beneft in write. Since the cache now  supports memoization, the Cassandra APIs might beneft from using",,Architectural solution benefits and drawbacks,9:2122 - 9:2380,1,arjan
62:88,a computation instead  of racy _get-load-put_ calls.,CASSANDRA-10855," a computation instead  of racy _get-load-put_ calls.
",,Architectural component behavior and structure,9:2381 - 9:2435,1,arjan
62:89,For hit rates see these [simulations|https://github.com/ben-manes/cafe…,CASSANDRA-10855,"For hit rates see these [simulations|https://github.com/ben-manes/cafeine/wiki/Efciency].
They show W-TinyLFU improves upon LRU by taking into account frequency.
",,Architectural solution benefits and drawbacks,9:2436 - 9:2599,1,arjan
62:106,snazy,CASSANDRA-10855,snazy,,Comment,9:2704 - 9:2708,1,arjan
62:90,"On an idle system FJP should give a  8latency improvement, if cost-of-…",CASSANDRA-10855," On an idle system FJP should give a  8
latency improvement, if cost-of-task is greater than cost-of-scheduling. On a loaded system  however, handing of work to a separate thread might add a penalty due to scheduling &  context switching. But that is probably a discussion that requires knowledge how Cafeine  works internally. I’m just cautious since I do not like to add more threads than necessary.
",,"Architectural solution benefits and drawbacks
Risks",9:2750 - 10:363,2,arjan
62:105,ben.manes,CASSANDRA-10855,ben.manes,,Comment,10:422 - 10:430,1,arjan
62:91,The penalty is small. In CLHM (and Guava) we didn’t have a system exec…,CASSANDRA-10855," The penalty is small. In CLHM (and Guava) we didn’t have a system executor  to exploit. The same approach is used of amortizing the maintenance work by bufering and  replaying operations, instead of locking to perform them immediately. There is a slightly  higher cost due to hashing for the {{CountMinSketch}} but overall its tiny. Using a direct  executor should be fne.
",,Architectural solution benefits and drawbacks,10:432 - 10:806,1,arjan
62:104,snazy,CASSANDRA-10855,snazy,,Comment,10:1120 - 10:1124,1,arjan
62:92,PR looks good,CASSANDRA-10855,PR looks good,,Architectural solution benefits and drawbacks,10:1127 - 10:1139,1,arjan
62:103,snazy,CASSANDRA-10855,snazy,,Comment,10:1244 - 10:1248,1,arjan
62:93,"Unit tests look good. However, a couple of dtests fail - unfortunately…",CASSANDRA-10855,"Unit tests look good. However, a couple of dtests fail - unfortunately a situation for  which we do not have a unit test.
",,Architectural solution benefits and drawbacks,10:1251 - 10:1373,1,arjan
62:94,Thing is that exception handing in cafeine is diferent now. It manifes…,CASSANDRA-10855,"Thing is that exception handing in cafeine is diferent now. It manifests for example in the  catch-clause in {{org.apache.cassandra.auth.PasswordAuthenticator#authenticate}}. The  loader calls {{queryHashedPassword}}, which throws {{org.apache.cassandra.auth.PasswordAuthenticator.NoSuchC  (extends {{RuntimeException}}). I assume that cafeine just ""passes"" REs and does not wrap  it in an some {{ExecutionException}}.
",,Technology solution,10:1374 - 10:1793,1,arjan
62:102,snazy,CASSANDRA-10855,snazy,,Comment,10:2889 - 10:2893,1,arjan
62:95,"Yes, that’s it. dtests & utests look good now.",CASSANDRA-10855,"Yes, that’s it. dtests & utests look good now.
",,Architectural solution benefits and drawbacks,10:2896 - 10:2943,1,arjan
62:96,I removed that {{No-  SuchCredentialsException}} altogether,CASSANDRA-10855,I removed that {{No-  SuchCredentialsException}} altogether ,,Architectural component behavior and structure,10:3009 - 10:3068,1,arjan
62:97,er necessary (we refactored {{Cassan-  9draException}} to extend {{Run…,CASSANDRA-10855,"er necessary (we refactored {{Cassan-  9
draException}} to extend {{RuntimeException}} just recently - that {{NoSuchCredential-  sException}} is older).
",,Architectural solution benefits and drawbacks,10:3084 - 11:113,1,arjan
62:101,ben.manes,CASSANDRA-10855,ben.manes,,Comment,11:118 - 11:126,1,arjan
62:98,LGTM,CASSANDRA-10855,LGTM,,Architectural solution benefits and drawbacks,11:129 - 11:132,1,arjan
62:100,snazy,CASSANDRA-10855,snazy,,Comment,11:139 - 11:143,1,arjan
62:99,"Alright, utests & dtests look good now.",CASSANDRA-10855," Alright, utests & dtests look good now.
",,Architectural solution benefits and drawbacks,11:145 - 11:186,1,arjan
84:1,Remove cassandra-cli in Cassandra 3.0,CASSANDRA-7920,Remove cassandra-cli in Cassandra 3.0,,Technology solution,3:52 - 3:88,1,arjan
84:2,"At this point, cassandra-cli has been deprecated for longer than a yea…",CASSANDRA-7920,"At this point, cassandra-cli has been deprecated for longer than a year (since 1.2) with a warning  that it would be removed in 3.0.
There are several tricky bugs and unsupported table options in it, so it’s out of date as well.",,Architectural solution benefits and drawbacks,3:108 - 3:336,1,arjan
84:3,"Even before that, we’ve been urging people to use cqlsh for a while.",CASSANDRA-7920,"Even before that, we’ve been urging people to use cqlsh for a while.
",,"Architectural solution benefits and drawbacks
Technology solution",3:339 - 3:408,2,arjan
84:5,"so to not do that redundant work,",CASSANDRA-7920,"so to not do that redundant work,",,Architectural solution benefits and drawbacks,3:504 - 3:536,1,arjan
84:4,I suggest we kill it early.,CASSANDRA-7920,"I suggest we kill it early.
",,Architectural design configuration,3:538 - 3:566,1,arjan
84:9,jasobrown,CASSANDRA-7920,jasobrown,,Comment,3:737 - 3:745,1,arjan
84:6,+1. woo-hoo!,CASSANDRA-7920," +1. woo-hoo!
",,Architectural solution benefits and drawbacks,3:747 - 3:761,1,arjan
84:8,brandon.williams,CASSANDRA-7920,brandon.williams,,Comment,3:765 - 3:780,1,arjan
84:7,+1,CASSANDRA-7920,+1,,Architectural solution benefits and drawbacks,3:783 - 3:784,1,arjan
89:1,row-cache: use preloaded jemalloc w/ Unsafe,CASSANDRA-8714,row-cache: use preloaded jemalloc w/ Unsafe,,Technology solution,3:52 - 3:94,1,arjan
89:2,Using jemalloc via Java’s {{Unsafe}},CASSANDRA-8714,Using jemalloc via Java’s {{Unsafe}},,Technology solution,3:114 - 3:149,1,arjan
89:3,is a better alternative on Linux than using,CASSANDRA-8714,is a better alternative on Linux than using,,Architectural solution benefits and drawbacks,3:151 - 3:193,1,arjan
89:4,jemalloc via JNA.,CASSANDRA-8714,"jemalloc via JNA.
",,Technology solution,3:195 - 3:213,1,arjan
89:78,snazy,CASSANDRA-8714,snazy,,Comment,3:339 - 3:343,1,arjan
89:5,Add patch that does two things:  # modify {{bin/cassandra}} to preload…,CASSANDRA-8714,Add patch that does two things:  # modify {{bin/cassandra}} to preload libjemalloc on Linux and OSX (and set OHC system  property)  # remove {{IAllocator}} abstraction in C* code,,Architectural design configuration,3:346 - 3:523,1,arjan
89:77,benedict,CASSANDRA-8714,benedict,,Comment,3:600 - 3:607,1,arjan
89:6,"I agree with the principle of switching to LD_PRELOAD, but I’m not so…",CASSANDRA-8714,"I agree with the principle of switching to LD_PRELOAD, but I’m not so sure  about switching the default allocator under everyone. We need to do some comprehensive  testing of the implications of that switch.",,Architectural solution benefits and drawbacks,3:610 - 3:816,1,arjan
89:76,snazy,CASSANDRA-8714,snazy,,Comment,4:4 - 4:8,1,arjan
89:7,"It contains measurements on* AMD CPU (6 cores, a bit old, but ok) / Li…",CASSANDRA-8714,"It contains measurements on* AMD CPU (6 cores, a bit old, but ok) / Linux  * Core i7 Ive Bridge (4 cores + HT), latest OS X  * m3.2xlarge (8 cores)  * c3.4xlarge (16 cores)  * c4.8xlarge (36 cores)  Some things to point out:  # jemalloc via JNA library can hit some ""busy deadlock"" that efectively leaves threads hang-  ing (and consuming some CPU - feels like a busy spin lock) - fled [JNA bug #396|https://github.com/twall/jna/issue  # jemalloc via JNA library is the slowest possible method on Linux and OS X  # jemalloc via JNA’s own malloc() + free() methods with jemalloc preloaded is the fastest  possible thing  # Unsafe with jemalloc preloaded is not bad, too",,Architectural solution benefits and drawbacks,4:175 - 4:842,1,arjan
89:75,aweisberg,CASSANDRA-8714,aweisberg,,Comment,4:915 - 4:923,1,arjan
89:8,Something doesn’t sit right with me for the diference between JNA acce…,CASSANDRA-8714, Something doesn’t sit right with me for the diference between JNA accessing  jemalloc via JNI and Unsafe. ,,Architectural solution benefits and drawbacks,4:925 - 4:1031,1,arjan
89:9,Since you are benchmarking access path I think you only need  to alloc…,CASSANDRA-8714,"Since you are benchmarking access path I think you only need  to allocate 1-byte. Make sure to store a value to the location so the page is touched.
",,Architectural design configuration,4:1032 - 4:1180,1,arjan
89:10,If Unsafe is slower I would be comfortable with,CASSANDRA-8714,If Unsafe is slower I would be comfortable with ,,Architectural solution benefits and drawbacks,4:1182 - 4:1229,1,arjan
89:11,JNA to allocate.,CASSANDRA-8714,"JNA to allocate.
",,Technology solution,4:1236 - 4:1252,1,arjan
89:12,"You mention address translation (addr_to_java), but that is just a cas…",CASSANDRA-8714,"You mention address translation (addr_to_java), but that is just a cast to get things to  compile.",,Architectural component behavior and structure,4:1254 - 4:1351,1,arjan
89:13,I followed it through to os.cpp and I don’t see any real extra work.,CASSANDRA-8714,"I followed it through to os.cpp and I don’t see any real extra work.
",,Architectural solution benefits and drawbacks,4:1353 - 4:1422,1,arjan
89:14,It’s quite possible the results are accurate and JNI just ended up bet…,CASSANDRA-8714,"It’s quite possible the results are accurate and JNI just ended up better optimized then  the native function calls in Unsafe. JNI has received a lot of attention.
",,Architectural solution benefits and drawbacks,4:1423 - 4:1587,1,arjan
89:74,snazy,CASSANDRA-8714,snazy,,Comment,4:1591 - 4:1595,1,arjan
89:15,I just wanted to benchmark allocation performance - and not accessing…,CASSANDRA-8714," I just wanted to benchmark allocation performance - and not accessing memory  since that would add a constant overhead to the comparison. Maybe it would also add some  ""negative"" value to the bigger systems (c3/c4).
But this is an artifcial benchmark. ",,Architectural solution benefits and drawbacks,4:1597 - 4:1850,1,arjan
89:16,"To benchmark a ""real scenario"" I’d had to allocate  more memory, keep…",CASSANDRA-8714,"To benchmark a ""real scenario"" I’d had to allocate  more memory, keep memory allocated, use diferent allocation sizes and so on. ",,Architectural design configuration,4:1851 - 4:1979,1,arjan
89:17,IMO that’s  too heavy for a JMH.,CASSANDRA-8714,"IMO that’s  too heavy for a JMH.
",,Architectural solution benefits and drawbacks,4:1980 - 4:2013,1,arjan
89:18,Yea - maybe it’s really the thing that JNI is more optimized.,CASSANDRA-8714,"Yea - maybe it’s really the thing that JNI is more optimized.
",,Architectural solution benefits and drawbacks,4:2014 - 4:2076,1,arjan
89:73,snazy,CASSANDRA-8714,snazy,,Comment,4:2080 - 4:2084,1,arjan
89:20,Ah! I think I found the reason why Unsafe.allocateMemory is slower:,CASSANDRA-8714,Ah! I think I found the reason why Unsafe.allocateMemory is slower:,,"Architectural solution benefits and drawbacks
Assumptions",4:2087 - 4:2153,2,arjan
89:21,It’s in {{os.cpp  os::malloc}}. It uses two stat counters - one for #…,CASSANDRA-8714,It’s in {{os.cpp  os::malloc}}. It uses two stat counters - one for # of allocations and one for # of al-  located bytes.,,Technology solution,4:2155 - 4:2275,1,arjan
89:19,"If these might be interesting, we could prefer Unsafe.allocateMemory o…",CASSANDRA-8714,"If these might be interesting, we could prefer Unsafe.allocateMemory over  Native.malloc.",,Architectural solution benefits and drawbacks,4:2277 - 4:2365,1,arjan
89:72,aweisberg,CASSANDRA-8714,aweisberg,,Comment,4:2371 - 4:2379,1,arjan
89:22,Those stats counters are not compiled in for the release build. There…,CASSANDRA-8714,"Those stats counters are not compiled in for the release build. There is also  padding in the debug build which might make Unsafe slower, but all that stuf probably isn’t  in the release build.
",,Architectural solution benefits and drawbacks,4:2382 - 4:2576,1,arjan
89:71,snazy,CASSANDRA-8714,snazy,,Comment,4:2580 - 4:2584,1,arjan
89:23,Aleksey Shipilev from Oracle provided a detailed answer to the questio…,CASSANDRA-8714,Aleksey Shipilev from Oracle provided a detailed answer to the question - in short:  it’s Unsafe itself. Here http://cr.openjdk.java.net/~shade/scratch/unsafe-allocate.txt and  here http://mail.openjdk.java.net/pipermail/hotspot-dev/2015-February/017089.html,,"Architectural solution benefits and drawbacks
Technology solution",4:2587 - 4:2844,2,arjan
89:70,snazy,CASSANDRA-8714,snazy,,Comment,4:2850 - 4:2854,1,arjan
89:24,Note: similar overhead exists for all other {{Unsafe}} methods like {{…,CASSANDRA-8714," Note: similar overhead exists for all other {{Unsafe}} methods like {{GetLong}} -  JNA {{Native}} has counterparts for some of them.
",,"Architectural solution benefits and drawbacks
Technology solution",4:2856 - 4:2990,2,arjan
89:69,snazy,CASSANDRA-8714,snazy,,Comment,5:103 - 5:107,1,arjan
89:25,In theory it’s true - but intrinsics come into play and make {{Unsafe.…,CASSANDRA-8714," In theory it’s true - but intrinsics come into play and make {{Unsafe.get/put}}  orders of magnitude faster.
",,Architectural tactics,5:109 - 5:219,1,arjan
89:68,snazy,CASSANDRA-8714,snazy,,Comment,5:224 - 5:228,1,arjan
89:26,Regarding the frst point: it wasn’t JNA - it was jemalloc itself. Don’…,CASSANDRA-8714,"Regarding the frst point: it wasn’t JNA - it was jemalloc itself. Don’t really  understand why, but using a self-compiled, recent version of jemalloc (3.6.0) works fne.
",,Architectural solution benefits and drawbacks,5:231 - 5:400,1,arjan
89:67,aweisberg,CASSANDRA-8714,aweisberg,,Comment,5:442 - 5:450,1,arjan
89:27,"OK, so it doesn’t matter which access path you use to get to jemalloc?…",CASSANDRA-8714,"OK, so it doesn’t matter which access path you use to get to jemalloc? Unsafe  vs JNI? They are both JNI if I understood Aleksey?
",,"Assumptions
Technology solution",5:453 - 5:583,2,arjan
89:66,snazy,CASSANDRA-8714,snazy,,Comment,5:588 - 5:592,1,arjan
89:28,Regarding performance: JNA’s Native.malloc() is up to 3x faster than U…,CASSANDRA-8714,"Regarding performance: JNA’s Native.malloc() is up to 3x faster than Unsafe.allocateMemory().
",,Architectural tactics,5:721 - 5:815,1,arjan
89:65,snazy,CASSANDRA-8714,snazy,,Comment,5:820 - 5:824,1,arjan
89:29,Also added new OHC version 0.3.3 that changes default allocation metho…,CASSANDRA-8714,"Also added new OHC version 0.3.3 that changes default allocation method to {{Native.malloc}}.
",,Technology solution,5:1048 - 5:1142,1,arjan
89:64,aweisberg,CASSANDRA-8714,aweisberg,,Comment,5:1318 - 5:1326,1,arjan
89:30,I suspect that the change to MemoryUtil.getByteBufer could be slower.,CASSANDRA-8714,I suspect that the change to MemoryUtil.getByteBufer could be slower.,,"Architectural solution benefits and drawbacks
Assumptions",5:1329 - 5:1397,2,arjan
89:31,The  JNA implementation requires a JNI call which I suspect then uses…,CASSANDRA-8714,"The  JNA implementation requires a JNI call which I suspect then uses the JNI call newDirect-  ByteBufer. The Java implementation is all intrinsics and plain Java.
",,"Assumptions
Technology solution",5:1399 - 5:1563,2,arjan
89:32,Conceptually I get  it and it looks as reasonable a way as any to fnd…,CASSANDRA-8714,"Conceptually I get  it and it looks as reasonable a way as any to fnd where jemalloc is hiding.
",,Architectural solution benefits and drawbacks,5:1895 - 5:1991,1,arjan
89:33,I am +1 conditional on:,CASSANDRA-8714,I am +1 conditional on:,,Architectural solution benefits and drawbacks,5:1992 - 5:2014,1,arjan
89:63,snazy,CASSANDRA-8714,snazy,,Comment,6:876 - 6:880,1,arjan
89:34,good catch with the JNI roundtrip. JMH result are pretty obvious: 16…,CASSANDRA-8714,"good catch with the JNI roundtrip. JMH result are pretty obvious: 16  ops/Âţs for {{Native.getByteBufer}}, 12000 ops/Âţs for the {{Unsafe}} variant. I’ll revert  that thing.
",,Architectural solution benefits and drawbacks,6:896 - 6:1070,1,arjan
89:62,snazy,CASSANDRA-8714,snazy,,Comment,6:1075 - 6:1079,1,arjan
89:35,Unfortunately there’s nothing like {{LD_PRELOAD}} on Win. Although the…,CASSANDRA-8714,"Unfortunately there’s nothing like {{LD_PRELOAD}} on Win. Although there are [some  approaches how to do it|https://en.wikipedia.org/wiki/DLL_injection], none of them really  convinces me.
",,Architectural solution benefits and drawbacks,6:1392 - 6:1581,1,arjan
89:61,JoshuaMcKenzie,CASSANDRA-8714,JoshuaMcKenzie,,Comment,6:1586 - 6:1599,1,arjan
89:36,Yeah - the lack of respectable LD_PRELOAD alternative means we’ll  lik…,CASSANDRA-8714,Yeah - the lack of respectable LD_PRELOAD alternative means we’ll  likely sit tight on this efort for a bit. ,,Motivation of design issue,6:1602 - 6:1710,1,arjan
89:37,I compiled jemalloc-win32 and ran their benchmarks,CASSANDRA-8714,I compiled jemalloc-win32 and ran their benchmarks,,Technology solution,6:1711 - 6:1760,1,arjan
89:38,"it’s reported numbers are considerably faster (82+%), but I haven’t du…",CASSANDRA-8714," it’s reported numbers are considerably faster (82+%), but I haven’t dug into what  their benchmarks are actually measuring w/regards to contention and sampling, etc.",,Architectural solution benefits and drawbacks,6:1766 - 6:1931,1,arjan
89:60,aweisberg,CASSANDRA-8714,aweisberg,,Comment,6:2069 - 6:2077,1,arjan
89:39,I am +1 with one comment.,CASSANDRA-8714,"I am +1 with one comment.
",,Architectural solution benefits and drawbacks,6:2080 - 6:2106,1,arjan
89:40,"Thinking on the change to MemoryUtil.setBytes, you switched to getting…",CASSANDRA-8714,"Thinking on the change to MemoryUtil.setBytes, you switched to getting the address by  casting to an interface and then invoking vs accessing the feld by ofset. ",,Architectural component behavior and structure,6:2107 - 6:2267,1,arjan
89:41,setBytes might  loop over a fair number of bytes so startup overhead i…,CASSANDRA-8714,"setBytes might  loop over a fair number of bytes so startup overhead is not as important, but it could also  be used to copy just a few so startup time will matter there.
",,Architectural solution benefits and drawbacks,6:2268 - 6:2439,1,arjan
89:42,If the JVM can fgure out that the ByteBufer in play there is always th…,CASSANDRA-8714,"If the JVM can fgure out that the ByteBufer in play there is always the same kind (or  maybe the method is always the same one) it will de-virtualize and inline, ",,"Architectural design configuration
Architectural solution benefits and drawbacks",6:2440 - 6:2601,2,arjan
89:43,but testing for  that is beyond me. [~benedict] might know what will h…,CASSANDRA-8714,"but testing for  that is beyond me. [~benedict] might know what will happen.
",,Architectural solution benefits and drawbacks,6:2602 - 6:2679,1,arjan
89:59,snazy,CASSANDRA-8714,snazy,,Comment,7:245 - 7:249,1,arjan
89:44,"I mean, if jemalloc-win32 via JNA  is faster than the âĂİstockâĂİ mall…",CASSANDRA-8714,"I mean, if jemalloc-win32 via JNA  is faster than the âĂİstockâĂİ malloc, it’s a reasonable option.
",,Architectural solution benefits and drawbacks,7:509 - 7:609,1,arjan
89:58,snazy,CASSANDRA-8714,snazy,,Comment,7:614 - 7:618,1,arjan
89:45,Just changed that in order to remove an unsafe call. In the end it sho…,CASSANDRA-8714,"Just changed that in order to remove an unsafe call. In the end it shouldn’t make any  diference since both access the same thing (esp. after hotspot did its job).
",,"Architectural component behavior and structure
Architectural solution benefits and drawbacks",7:656 - 7:820,2,arjan
89:57,aweisberg,CASSANDRA-8714,aweisberg,,Comment,7:825 - 7:833,1,arjan
89:46,I’m not brave enough to assume it’s going to be able to fgure out that…,CASSANDRA-8714," I’m not brave enough to assume it’s going to be able to fgure out that  in all cases at that call site there will only be DirectByteBufers. That particular line will  only ever be invoked with DirectByteBufers, but the surrounding method will have both so  I don’t know what information the compiler is going to have to deduce that.
You could run with print inlining and a single call site for setBytes and pass in randomly a  direct/non-direct bufer and see if it is inlined.
",,Architectural design configuration,7:844 - 7:1323,1,arjan
89:56,snazy,CASSANDRA-8714,snazy,,Comment,7:1328 - 7:1332,1,arjan
89:47,Hm - the micro bench itself tells that neither approach has any beneft…,CASSANDRA-8714,"Hm - the micro bench itself tells that neither approach has any beneft.
",,Architectural solution benefits and drawbacks,7:1335 - 7:1406,1,arjan
89:55,aweisberg,CASSANDRA-8714,aweisberg,,Comment,7:2722 - 7:2730,1,arjan
89:48,Looking at the micro benchmark it isn’t measuring the right thing.,CASSANDRA-8714,Looking at the micro benchmark it isn’t measuring the right thing.,,Architectural solution benefits and drawbacks,7:2733 - 7:2798,1,arjan
89:49,The same  call site has to potentially contain direct and non-direct b…,CASSANDRA-8714,"The same  call site has to potentially contain direct and non-direct bufers. The JVM also does JVM  6
wide class hierarchy analysis, but I don’t know what it does for call site specifc analysis.
There are actually several potential direct and non-direct byte bufer classes. Take a look at  the type hierarchy for ByteBufer it’s pretty long.
",,Architectural design configuration,7:2800 - 8:241,1,arjan
89:50,This would only be a factor for very small copies Say 4-16 bytes or si…,CASSANDRA-8714,"This would only be a factor for very small copies Say 4-16 bytes or similar. Say when  serializing variable length felds that can be very small. You would end up calling this which  is basically a memcpy equivalent, and that is where the overhead of starting the memcpy  matters.
",,Architectural solution benefits and drawbacks,8:242 - 8:522,1,arjan
89:54,aweisberg,CASSANDRA-8714,aweisberg,,Comment,8:527 - 8:535,1,arjan
89:51,"I should add, you can use the compiler control annotation to prevent i…",CASSANDRA-8714," I should add, you can use the compiler control annotation to prevent inlining  and then you would get a sense of the diference even if there were multiple call sites. I am  +1 either way. I don’t think it’s worth fussing over.
",,Architectural solution benefits and drawbacks,8:537 - 8:765,1,arjan
89:53,snazy,CASSANDRA-8714,snazy,,Comment,8:770 - 8:774,1,arjan
89:52,I tried it anyway - just to know the results. Mixed workloads are a bi…,CASSANDRA-8714,I tried it anyway - just to know the results. Mixed workloads are a bit slower - hard  at the edge of measurement error ;),,Architectural solution benefits and drawbacks,8:777 - 8:898,1,arjan